## 9.3 生成技术
本节将介绍经过验证的代码生成技术，包括一些代码示例。我们将代码生成技术分为不同类别：

- 模板 + 过滤
- 模板 + 元模型 
- 框架处理器
- 基于 API 的生成器 
- 行内生成
- 代码属性
- 代码编织

我们将简要介绍所有这些技术，并举例说明。除了行内生成（以及某种程度上的代码属性）外，所有这些方法都需要明确的集成。

尽管各种生成技术之间存在一些重要的差异，但它们都有以下共同点：

- 元模型或抽象语法总是存在的，至少是隐含的。
- 建立在元模型基础上的转换总是存在的。
- 存在某种读取模型（规范）并将其提供给转换的前端。

### 9.3.1 模板和过滤
这种生成技术描述了代码生成的最简单情况。如图 9.1 所示，我们使用模板来遍历文本表示模型的相关部分，例如通过 XML 使用 XSLT。

![Figure 9.1](../img/f9.1.png)

要生成的代码可以在模板中找到。模板中的变量可以绑定到模型中的值。下面，我们将介绍一个简单的示例，其中 Java Bean Person 是根据 XML 规范生成的（为简化起见，我们不使用 XMI 作为模型表示法，而是使用自定义schema）。这就是规范：

```xml
<class name=“Person” package=“com.mycompany”>
  <attribute name=“name” type=“String”/>
  <attribute name=“age” type=“int”/>
</class>
```

生成的代码应如下所示：

```java
package com.mycompany;
public class Person {
  private String name;
  private int age;
  public String get_name() {return name;}
  public void set_name( String name) {this.name = name;}
  public int get_age() {return age;}
  public void set_age( int age ) {this.age = age;}
}
```

执行这种转换的 XSLT 样式表大致如下：

```xml
<xsl:template match=“/class">
  package <xsl:value-of select=“@package”/>;
  public class <xsl:value-of select=“@name”/> {
    <xsl:apply-templates select=“attribute”/>
  }
    </xsl:template>
 
<xsl:template match=“attribute">
 
  private <xsl:value-of select=“@type”/>
    <xsl:value-of select=“@name”/>;
public <xsl:value-of select=“@type”/>
  get_<xsl:value-of select=“@name”/>() {
    return <xsl:value-of select=“@name”/>;
}
 
public void set_<xsl:value-of select=“@name”/> (
  <xsl:value-of select=“@type”/>
    <xsl:value-of select=“@name”/>) {
      this.<xsl:value-of select=“@name”/> =
        <xsl:value-of select=“@name”/>;
  }
</xsl:template>
```

使用模板和过滤进行生成是相当直接和可移植的，但样式表很快就会变得非常复杂。因此，这种方法完全不适合大型系统，尤其是在规范基于 XMI 的情况下。

如果分几个步骤进行工作，XMI 的问题可以得到一定程度的缓解：最初的转换将 XMI 转换为具体的、特定领域的 XML schema。接下来的转换步骤可以根据该schema生成代码。这样，模板与具体的 XMI 语法就有了一定程度的脱钩，而实际的代码生成（即第二步）就变得容易多了。不过，我们仍然要在 XML 元模型的抽象层上工作，而这个问题显然可以通过接下来介绍的方法来解决。

### 9.3.2 模板和元模型
为了避免从（XML）模型直接生成代码的问题，我们可以实现一个多级生成器，它首先解析 XML，然后实例化一个元模型（由用户调整），最后将其与模板一起用于生成。图 9.2 演示了这一原理。

![Figure 9.2](../img/f9.2.png)

这种方法的优势在于，一方面，它可以更大程度地独立于模型的具体语法，例如 UML 及其不同的 XMI 版本。另一方面，我们可以将更强大的模型验证逻辑--约束--集成到元模型中。与模板不同的是，这可以用 Java 等真正的编程语言来实现。正如我们在第 6 章中指出的，这种代码生成在 MDSD 中具有特殊意义。

openArchitectureWare 生成器的一个有趣的实施方面属于这一工具类别，不应忽略：从编译器构建的角度来看，元模型实施（例如 Java）和模板是转换的一部分。元模型承担了抽象语法的角色。由于抽象语法和转换是编译器的参数，因此我们实际上是在处理一个开放的编译器框架。值得注意的是，语法的构造--即元模型元素--是自己编译的。换句话说，编译器是面向对象的，这有助于避免繁琐的类型转换。从概念上看，模板是元模型的编译器方法，就像 Java 中实现的帮助方法一样。这一点可以从模板定义（“DEFINE method FOR metaclass”）中看出。与 Java 一样，模板语言也支持多态性和覆盖--两者都是构建面向对象编译器的必要条件--只有类的定义被委托给 Java 部分。这就是为什么我们认为模板语言是面向对象的，尽管在模板语言中不能直接定义任何类。
