## 9.2 分类
本节探讨了处理元程序（生成其他程序的程序）时的各种问题。这包括元程序和 *基本程序* (base program, 生成的程序) 的混合/分离，以及整合生成代码和非生成代码的方法，从而避免元程序和程序混合。

### 9.2.1 元编程
代码生成器是一种元程序，它处理作为输入参数的规格（或模型），并生成作为输出的源代码。

元程序可以在与生成的程序相关的不同时间点运行：

- 完全独立于基本程序 -- 即在基本程序之前。
- 在编译基本程序时。
- 在基本程序运行时。

典型的 MDA/MDSD 生成器采用第一种方法。在这里，元程序和要手动创建的基本程序部分通常是分开指定的。生成的代码也与手动创建的代码分开，两者必须由开发人员进行整合（参见第 8.3.1 节）。

C++ 预处理器或 C++ 模板机制等系统也可用于元编程。在这里，基本程序和元程序是混合的，同样，生成过程的结果已经包含了手工创建的代码和生成的代码，因此也是混合的。不过，生成的程序不再知道元程序的任何信息。我们称之为 *静态元编程 (static metaprogramming)*。

Lisp 和 CLOS [Kos90](../ref.md#kos90) 允许通过 *元对象协议 (meta object protocol)* 在运行时执行元程序。这是因为在 Lisp 中，程序是以数据（列表）的形式表示的。元程序可以修改这些列表，从而在运行时创建或修改基本程序。通过修改基本程序中的元程序，可以修改基本程序的语义。

### 9.2.2 程序与元程序的分离/混合
在元程序和基本程序混合的情况下，编程和元编程使用一种共同的（或至少是一体化的）语言，源代码组件不是分离的，而是混合的。这可能导致两个层次之间的调用关系，原则上是双向的。C++ 模板元编程、Lisp 和 CLOS 都属于这种情况。

混合使用程序和元编程是一种非常强大的方法。然而，由此产生的系统很容易变得极其复杂，因此它与主流软件开发的相关性非常有限。混合方法的另一个含义是，目标语言不再是代码生成过程的参数。

如果将程序和元程序分开，系统的创建就会分为两个不同的阶段。元程序运行并创建基本程序（或其部分内容）作为输出，然后终止。程序并不知道元程序的存在<sup>[1](#1)</sup>。在整个（元）编程过程（包括构建过程）中，都会保持这种分离。

程序和元程序是否用同一种语言编写，在这里并不重要。例如，我们可以很容易地用 Java 编写一个元程序，并将 Java、C++ 或 C# 作为输出。

元程序和基本程序分离的方法确实支持元对象协议，但由于其复杂性较低，更适合典型的以架构为中心的模型驱动型软件开发。我们书中使用的生成器 openArchitectureWare [OAW](../ref.md#oaw)，在元编程语言方面是一个混合体：它的一部分用 Java 实现（应用程序系列的元模型），另一部分用模板语言 *Xpand* 实现。这样，我们就可以将模板语言的表现力与 “真正” 编程语言的强大功能结合起来，而不会让模板过多地使用元编程逻辑。

### 9.2.3 生成代码与非生成代码的隐式或显式集成
两种程序类型的隐式集成所产生的代码已经是生成代码与非生成代码的混合体。因此，我们不必再担心两类代码的整合问题。

在另一种情况下，生成的代码最初是独立于手写代码部分的。这两种代码必须以适当的方式进行整合：上一章对此进行了描述。

### 9.2.4 关系
一般来说，我们可以说生成器分类的两个方面之间存在着某种关系：

- 程序和元程序分离的生成器通常也会生成与手工创建的代码分离的生成代码，因此必须进行手工整合。
- 程序和元程序混合的生成器则不需要这种手工整合 -- 生成器已经创建了组合系统。

在实践中，我们建议将程序和元程序分开，并明确整合生成代码和手工创建的部分。我们将在稍后详细介绍相应的技术，但首先我们要为第二类技术举几个例子。

### 9.2.5 混合程序和元程序的示例
C++ 预处理器是一个融合了程序和元程序的系统。这里应用的语言是相互独立的：我们也可以将 C++ 预处理器与其他编程语言一起使用，因为它是以纯文本方式处理源代码的。由于该系统基于宏扩展，因此预处理器产生的源代码已将生成的代码和手动创建的代码融为一体。下面是一个简单的 C++ 宏：

```c
#define MAX(x,y) (x<y ? y : x)
```

如果在源代码中使用了该宏，预处理器将根据上述规则对其进行扩展：

```c
int a, b;
int greaterValue = MAX(a, b);
```

成为以下表达式：

```c
int greaterValue = (a<b ? a : b);
```

生成的代码已直接插入要扩展的宏原来所在的位置。

另一个同样来自 C++ 的例子是模板。模板首先是在 C++ 中实现类型泛型的一种方法。函数或类可以用类型参数化。由于 C++ 使用静态代码生成实现了这一特性，因此这种方法也可用于 *模板元编程 (template metaprogramming)* [Ale01](../ref.md#ale01) 。在这里，生成是通过对模板的评估进行的<sup>[2](#2)</sup> 。这种方法主要用于性能优化、代码量优化、静态程序优化，在某些特殊情况下，还可用于接口调整、生成式编程或 [Ale01](../ref.md#ale01)  中描述的其他有趣用途。

在这里，程序和元程序也是融合在一起的。由于模板机制了解并使用 C++ 的类型系统，因此与预处理器的集成显然更为紧密。同样，由此产生的系统由已生成的代码和手工创建的代码组成。

在这里，代码量的调整可以作为模板元编程的一个例子。具体来说，我们希望使用尽可能小的数据类型（*short int*）来满足此处定义的变量的最大值，从而减少运行时的内存占用。下面的代码片段说明了这一点：

```c
#define MAXVALUE 200
IF<(MAXVALUE<255), short, int>::RET i; // type of i is short
```

上例中的 IF 语句在编译时进行评估。它是使用模板实现的，这一点从 “<” 和 “>” 括号的使用中可以清楚地看出。具体来说，我们应用了 *部分模板特殊化 (partial template specialization)* 。我们首先定义一个模板，它有三个参数：一个布尔值，以及用于 *true* 情况和 *false* 情况的类（类型）。

```c
template<bool condition, class Then, class Else>
struct IF {
  typedef Then RET;
};
```
在 C++ 模板定义的上下文中，我们现在使用 *typedef* 定义一种新类型。根据公认的惯例，这种类型被称为 *RET* 。它是模板评估的返回值。在默认情况下，我们将返回类型 --模板实例的值-- 定义为上文定义为 *true* 的类型，即名称为 *Then* 的模板参数。

接下来，我们针对布尔表达式为 *false* 的情况对模板进行了部分特化。现在模板只有两个参数，因为布尔表达式被设置为 *false*。

```c
//specialization for condition==false 
template<class Then, class Else>
struct IF<false, Then, Else> {
  typedef Else RET;
};
```

现在，返回值 *RET* 就是为 *false* 情况指定的类型参数（参数 *Else*）。如果编译器发现该模板的实例，如上文的 *short/int* 示例，它将使用最特殊的模板 -- 在本例中为 *false* 情况。这样，*RET* 就被定义为 *Else* 类型，因此是 *short*。

---
#### 1
程序可以通过描述性元对象部分了解元程序的存在。

#### 2
由于这一步骤是在 C++ 编译过程中进行的，因此源代码并不是必然的结果，而是编译器中的直接机器代码或相应的中间表示。
