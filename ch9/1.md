## 9.1 代码生成--为什么？
我们反复提到，在 MDSD 中，建模、代码生成和框架开发之间有着密切的联系，例如，MDSD 平台的框架完成代码 (framework completion) 可以从 DSL 生成。丰富的、特定领域的平台（如第 [7](../ch7/0.md) 章所述）简化了代码生成，减少了对代码生成的需求。另一方面，与纯粹的通用方法相比，代码生成具有优势，或者至少是一种补充。

### 9.1.1 性能
在许多情况下，使用代码生成是因为希望在保持一定灵活性的同时达到特定的性能水平。传统的面向对象技术（如框架、多态性或反射）并不总能满足性能要求。使用代码生成，配置被抽象地陈述（这也是其灵活性所在），并生成高效的代码。

### 9.1.2 代码量
代码生成的另一个原因是代码量。如果在编译时就知道运行时需要哪些功能，代码生成器只需将这一部分添加到代码中。这有助于缩小 image 大小。反之亦然，在源代码级过度扩展构造会大大增加 image。C++ 模板实例化就是一个例子。

### 9.1.3 可分析性
复杂的通用框架或运行时系统往往会将编程语言相关的复杂性转移到专有配置层面。它们通常会大量使用解释，这阻碍了对程序属性进行静态分析的可能性，有时还会影响错误检测。相比之下，生成的编程语言源代码具有人工编程代码的可分析性。正如我们所指出的，理想的做法是在这两种方法之间取得合理的平衡。

### 9.1.4 早期错误检测
灵活的系统通常使用弱类型，以便在运行时做出决策（Java 中的 *Object*、C/C++ 中的 *void**）。因此，错误检测被推迟到程序运行时进行，这通常是不可取的，也是这种编程方式在嵌入式系统中不受欢迎的原因之一。通过使用 “静态框架” ，可以克服其中的一些缺点。在编译前就能识别出配置的缺陷，编译器通常也能获得更多信息，从而报告错误信息。

### 9.1.5 平台兼容性
在 MDA 范畴内使用代码生成的经典案例是，应用逻辑的编程通常可以独立于实现平台。这样就可以更容易地过渡到更新、可能更好的平台。

### 9.1.6 （编程）语言的限制
大多数编程语言在表达能力方面都有一些不便的限制，这些限制可以通过代码生成来规避。例如，Java 中的类型泛型（至少在 1.5 版之前），或 downcast 到变量类。另一个例子是在非面向对象的语言中引入面向对象的概念。

### 9.1.7 切面
系统的横向 (cross-cutting) 属性（如日志或持久性）通常可以通过代码生成在本地实现，即不会分散到整个应用中。我们将在本章中进一步阐述这一问题。

### 9.1.8 自省
自省(introspection) 问题不容忽视。自省描述了程序对自身的（只读）访问。这允许程序获取关于自身的信息，例如关于类、其属性和操作的信息。在某些编程语言（如 Java）中，这种机制是动态支持的。其他语言（如 C++）则不提供自省功能。在这种情况下，代码生成可以静态地创建一个替代品：不是在运行时分析程序结构，而是在生成时（即运行前）分析程序结构，并生成可访问相应结构的代码。
