## 18.7 关键问题
在前面的章节和第 5 章中，我们已经讨论了对 MDSD 的一些偏见。其中一些偏见可以追溯到 20 世纪 80 年代和 90 年代，源于使用 CASE 工具的负面经验，现在被普遍地投射到模型驱动方法上。严肃而重要的问题出现了：这些问题的答案既不琐碎，也不容易找到。下面我们将讨论其中一些问题的答案：

- MDSD 新在哪里？

当然，它的个别概念，例如从高层描述/模型生成源代码，并不新鲜。然而，每个开发人员在其职业生涯的某个阶段都会使用或编写简单的代码生成器，而最新一代的 MDA/MDSD 工具具有高度灵活性，可以自由定义建模语言和模块转换，而且相对简单。MDSD 不仅仅是一种技术，它主要涉及工程原理。

- 如果这种方法如此出色，为什么没有更受欢迎呢？

因为还不具备所需的先决条件，如灵活的工具，最重要的是，还不具备对该方法更全面的了解。在工具领域，MDSD 的日益普及无疑起到了推动作用。另一方面，以整体架构为中心的 MDSD 观点--特别是其生成性使用--已经在早期采用者中确立。与流程相关的 MDSD 核心概念也是如此。

- MDSD 是否会对应用程序源代码的性能或可读性产生负面影响？

在模型驱动方法中，必要的基础架构和相应的设计模式最初是以手工创建的小型参考实现的形式开发的。这个参考实现可能很小，但却很深入。它涵盖了架构的所有层，由经验丰富的团队成员在项目的第一阶段建立。在项目过程中，参考实现会不断完善和优化，以便通过生成技术将其属性和改进转移到整个源代码中。平均而言，模型驱动方法的性能至少与传统开发方法相同。源代码的可读性也是如此（见第 8.2.4 节）。

- 今天基于 UML 的集成开发环境支持往返(round-trip)运行，难道不比 MDA/ MDSD 工具成熟得多吗？

这在某种程度上可能是对的，但这并不重要，因为这些工具构成了另一类工具。由于缺少抽象层次，它们不具备上述 MDSD 的优势（见第 18.2 节和第 5 章）。

- MDSD 会不会对特定工具或某种技术组合产生不合理的强烈依赖？

模块化、自动化的转换，以及将模型转换视为一等工件，保证了对工具的依赖仍然是局部的（见第 11.2 节）。由于 MDA 尚未建立转换语言的标准，人们在选择 MDA/MDSD 工具时会受到特定转换语言的约束。不过，MDSD 工具越来越多地被视为日常工具，特别是如果它们是开源软件的话。由于基于模板的现代生成器对目标语言没有限制，因此要创建的应用程序的特定技术组合也没有限制。

- 模型驱动方法不是意味着瀑布模型吗，它与敏捷性不是特别冲突吗？它与 CASE 的区别是什么？

MDSD 的迭代、双轨过程（见第 13.2 节）中，基础架构与应用并行开发，必须与基于 “前期大设计” 理念的传统瀑布式方法明确区分开来。MDSD 以特定领域平台为基础，与试图使用通用语言预测所有情况的 CASE 方法截然相反。敏捷方法特别适合创建 MDSD 参考实施。MDSD 还有助于扩展敏捷方法，因为所获得的经验和专家知识可以以软件形式提供给所有开发人员。MDSD促进了测试驱动方法（见第14章）。

- 如何确保模型和代码不会在某一点上出现分歧？

在 MDSD 中，生成是基于模型的，因此生成的代码与非生成的代码是分开的。手写代码不会过时。相反，MDSD 认为开发人员和生成人员是互补的合作伙伴，必须高效合作。开发人员和生成人员之间的合作规则并不是一成不变的，而是根据实际需求确定的。开发人员在团队中的互动规则也是如此。不过，MDSD 生成器可以确保开发人员不会越过领域架构所设定的边界，特别是因为在迭代再生过程中，对生成代码的操作是可以撤销的。

- 开发生成器或转换需要多少时间和精力？是否值得花费时间和金钱？

目前已有重点明确、成熟的通用工具，尤其是在开源领域。这些工具拥有简单而强大的模板语言。有些工具还定义了强大的模型到模型转换语言。在转换开发过程中，我们应该以这些生成器为基础。

现代模板语言可以非常直观地概括复杂的手写代码。对源代码进行泛化或 “模板化” 所需的工作量，仅为提取模板的参考实现手工编码工作量的 20% 至 25%。从一定的项目规模开始，特别是当预计会有类似的后续项目时，MDSD 方法比传统的软件开发方法更有效（见第 18.6 节）。

- 在模型中更改属性类型，然后进行再生，这难道不比在代码中的某个地方手动更改声明花费的时间更长吗？

如果我们有丰富的语义，例如属性的持久性，那么仅仅更改代码中的一处是不够的；接口（getters/setters）、序列化器和 DDL 脚本中的所有地方都必须进行一致的调整。

- 通过手动调整生成的代码而不是调整 MDSD 转换（生成规则）来适应因维护而产生的变化不是更快吗？

如果遵守 MDSD 的指导原则，并将生成的代码与非生成的代码严格分开，对代码模板的修改总是比对大量源文件的手动修改要快。

- 在时间紧迫的应用程序开发阶段，我们不能总是等待领域架构的下一个版本。因此，必须对生成的代码进行人工干预，而 MDSD 方法则会因为无法继续使用生成器而失败。如何避免这种情况？

对于较小的补丁，可以创建一个特定的、临时的领域架构分支，在领域架构的下一个版本发布时停止使用。如果领域体系结构出现严重不足，就必须暂时或永久性地依赖手动编程。这不是通过操作生成的代码来实现的，而是通过在相关位置打开领域架构来实现的：转换的方式会发生变化，从而只生成一个（可修改的）默认实现。如果适用，领域架构的开放还可以作为一个临时的、特定于项目的分支。

- 与其使用生成器，不如实现一个面向对象的框架，这样不是更好吗？是否存在面向对象生成器和高质量的面向对象生成代码？

面向对象框架和生成器是理想的搭配（参见第 3 章）。这两种方法的结合是一种真正的进步。

在 MDSD 中，框架和生成器以类似于面向对象模型的动态和结构方面的方式相互补充。现代生成器通常是在面向对象语言中实现的，与每个程序员都曾编写过的简单实用程序完全不同。

- 大型团队中的模型驱动软件开发不可避免地意味着分布式建模。目前可用的（UML）建模工具不是帮倒忙吗？

当然，选择合适的建模工具对大型项目中 MDSD 的成功至关重要。然而，也有一些成熟的（UML）工具支持分布式建模，即使在大型团队中也是如此。无论采用哪种方法，将应用模型简单划分为几个松散耦合的部分模型都会有所帮助。分区可以横向进行（与架构层一起），也可以纵向进行（与松散耦合的用例实现一起）。DSL 和生成器必须允许并支持分割（参见第 15 章）。

- 明确制定架构不是更费时吗？

每个应用程序都有一个架构，无论是否已正式定义，但只有在明确制定出架构（无论以何种形式）后，它才会成为一个 “好” 架构。可维护性、可扩展性等质量属性可以反复创建，但不能随意创建。

- 手写代码不是比生成代码更可靠吗？我们是否可以在所有情况下都相信生成器，还是说在某些情况下总是需要人工干预？

如果认为设计模式中的几个不可预测的例外情况会导致生成器的使用不切实际或不经济，那是错误的。MDSD 的目标并不是完全消除源代码的手工创建。相反，MDSD 提供了实用的技术，在明确定义的位置用非生成代码来补充生成代码。

为了证明手写代码效率更高、错误率更低，有时会引用一些奇怪的编译器或汇编器错误。但人们忽略了一个事实，即生成器技术的这一所谓弱点早就阻碍了当今编程语言的开发和使用。事实恰恰相反：实践表明，由于对已实现的设计模式的高度关注，许多错误通常是在从参考实现中推导模板的过程中被发现的。否则，通过传统的复制和粘贴技术，这些错误就会被忽视并进一步扩散。

我们承认，必须非常谨慎地划定生成代码与手动执行之间的界限。这是在自动化和必要的自由度之间的一种平衡行为。通常情况下，只有数量有限的备选解决方案才能实现目标（见第 7 章）。

