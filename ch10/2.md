## 10.2 M2M 语言要求
在深入探讨 QVT 本身的细节之前，我们不妨先讨论一下模型到模型转换语言及其实现的，一些更重要但可能不太明显的要求：

- 大多数现实的模型到模型转换场景都要求转换规则能够查询其他转换规则的计算结果，因为每个规则通常只涉及整个转换的一个小方面。只有当引擎有能力对 *转换轨迹 (transformation trace)* 进行某种记账时，查询才有可能实现。转换轨迹可被理解为转换执行的运行时足迹。这种轨迹的具体形式和用户可见性在不同的 M2M 语言中大相径庭。通常，命令式 (imperative) 转换语言有更明确的查找过程，而声明式 (declarative) 语言则以隐式方式利用轨迹信息。

  即使是三种 QVT 语言，其显示轨迹的方式也大相径庭。实现各种优化和调试方案也需要转换轨迹。与任何实用的编程语言一样，调试能力对于发现困难和微妙的错误至关重要。模型转换也是如此。例如，复杂的模型到模型转换可能会根据源模型中一个小属性的值而表现出微妙的不同。如果生成的目标模型出现异常，那么对于转换编写者来说，跟踪执行轨迹并发现哪些规则做出了错误的决定是非常有帮助的。

- 除了首次运行 M2M 转换时，用户很少在一张白纸上生成模型。如果再次运行转换，重要的是只对现有目标模型进行必要的更改，而不是每次运行转换时都不断添加模型元素。只有在目标模型上有识别机制，才有可能实现对目标模型的这种理解。这可以通过目标元模型的内在属性来实现，如模型元素的名称，甚至 MOF id，或者通过对目标模型与其源模型之间的实际关系，进行编码标识来实现。通常，转换轨迹包含这些信息。让重复转换正确运行，以便更新目标模型的要求，有时被称为 *变更传播 (change propagation)* 。
- 转换隐式或显式地定义了源模型和目标模型之间的关系。在某些情况下，源模型和目标模型在转换执行之前就已经存在，早于关系建立之前。在这种情况下，转换可能会被要求验证关系是否存在，并有选择地改变目标模型，使关系发生 (happen) 。这个问题与变更传播场景不同，因为前者可以假定存在转换轨迹，而在后者，转换可能从未运行过。
- 一般来说，转换的源模型可能非常大。在第一次执行转换后，通常只会对源模型进行相对较小的修改。在这种情况下，可以大致确定哪些转换规则必须再次执行，以及涉及哪些源模型元素的子集。要做到这一点，可能需要对转换规则进行 *影响分析 (impact analysis)* ，并提供轨迹信息。不能低估这种优化的必要性，因为转换用户希望在开发过程中，期望获得合理快速的迭代周期。这与当今的非 MDSD 开发场景相比，大型项目的完整构建非常罕见，构建通常是在构建服务器晚上完成的。这种优化要求有时被称为 *增量更新 (incremental update)*。
- 在许多使用场景中，目标模型通常是特定于平台的，可能需要建模人员手动更改。这种更改通常是可以避免的，因为它们可能只是表明与更抽象的平台无关的模型出现了问题，甚至是转换本身出现了问题。尽管如此，PIM 有时并不会有意修改 (fix) 特定平台的细节，而是希望平台建模人员或开发人员，在应用另一个模型转换或代码生成之前进行受控变更。要做到这一点，模型转换编写者需要有能力定义：目标模型中允许进行此类更改的位置。这样，转换引擎就可以避免覆盖这些（也只能覆盖这些）手动更改。这让人想起第 [8.3.1](../ch8/3.md#831-生成代码与人工部分的显式集成) 节中讨论的代码生成保护区问题。转换编写者定义如何手动更改目标模型的能力有时被称为 *保留策略 (retainment policy)* 。
- 模型到模型的转换在将源模型映射到目标模型时，通常会对源模型进行大量的结构修改。通常情况下，这种转换会分为多个阶段。在典型的 M2M 场景中，源元模型中的一些类在初始阶段被映射到目标元模型中的类上。在第二阶段，源元模型中的一些关联被映射到目标元模型的关联上。然而，由于后者通常被编码为属性，因此可能无法在一次操作中构建一个目标模型元素。更一般地说，重要的是目标模型元素的构建必须是渐进式的。在这种情况下，可以说这种语言允许定义 *M x N 变换 (M x N transformations)* 。
- 对于是否需要支持 *双向转换 (bidirectional transformations)* ，目前还存在争议。这可以通过编写两个或多个单向转换，或一个可双向执行的转换来实现。后者只有在声明式方案中才有可能实现。不过，我们对这一要求在实践中的实用性表示怀疑。只有在描述同构关系 (isomorphic) 时，双向变换的定义才有意义。在实践中，这种情况几乎从未出现过，因为不同的元模型通常以不同的完整性描述不同抽象层次的方面。

  即使给出了非同构问题的双向变换（无论是两个单向变换，还是一个可在两个方向上执行的变换），在实践中也很难使用，因为源模型和目标模型的变化很容易以意想不到和不受控制的方式发生振荡。在最坏的情况下，不同人对源模型和目标模型的更改会使两个模型都失去作用，因为转换必须做出默认假设，因为问题不是同构的。这种转换将使本书所倡导的架构方法失效，即架构决策只应在 PIM 层做出。

以上是用 Java 这样的通用编程语言编写模型到模型转换可能不够充分的一些重要原因。如果决定用 Java 编写转换，就需要一个复杂的框架来支持转换编写者管理输入和输出模型以及转换轨迹：如果没有隐式或显式轨迹，就无法编写有用的转换。然而，这将使 Java 调试器的使用变得非常困难，因为用户必须处理框架的内部问题。然而，调试转换的能力在实践中是必须的。

QVT 的设计目标之一是支持或至少不禁止实现上述至少部分要求。QVT 最终提供了三种特定领域的语言，每种语言都以自己的方式处理模型到模型的转换。在第 [10.6](../ch10/6.md) 节中，我们将对 QVT 是否不负众望，实现了设计目标进行评估。

您可能会问为什么 QVT 代表 “查询、视图和转换” ，因为它实际上只涉及模型到模型的转换。*查询 (Queries)* 是任何模型到模型转换的固有组成部分，因为查询被用于从源模型中收集模型元素。在 QVT 中，这是通过 [OCL](../ref.md#ocl) 实现的。同时，*视图 (View)* 的概念是提供一种查看元模型特定方面的方法。尽管目前采用的规范明确地避免了解决视图问题，但人们认为模型转换提供了这样一种机制。如果视图需要可编辑，我们就会再次遇到双向转换要求及其问题后果。QVT 声称支持双向转换，因为三种 QVT 语言中的两种都能指定双向规则，但它并没有说明如何用它来定义视图。

