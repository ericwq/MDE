## 13.4 目标架构开发流程
领域架构开发流程的最佳实践是一方面。其他重要问题包括
- 如何制定合理的目标架构？
- 如何使其'为 MDSD 做好准备'？
- 如何在非小型项目中实施？

下面的章节将在这方面提供一些帮助：它们涉及流程最佳实践，重点是目标架构 -- 当然，这也反映在元层面的领域架构中。换句话说，它是上文介绍的架构开发主线中所有活动的相关视角。下面许多关于目标架构开发的陈述和建议都与 MDSD 无关，但其中有些是与 MDSD 相关的，我们将看到这一点。

软件架构通常过于受技术驱动。你会听到这样的说法：“我们有一个网络服务 (Web Service) 架构”。这种说法的信息量并不大，因为它只描述了整个系统的一个方面（通信），而且网络服务只是该方面的一种特定实现技术。关于架构，甚至关于其通信方面，还有比实现技术更多的东西需要说明。"EJB 架构“ 或 ”瘦客户端架构" 也是如此。 过早地承诺采用特定技术通常会导致对概念的盲目性，并过分依赖于特定技术。而后者又会导致复杂的编程模型、糟糕的可测试性，以及随着 QoS 需求的发展而丧失改变技术的灵活性。它掩盖了真正重要的问题。

另一个问题是 “炒作因素 (hype factor)” 。虽然将架构描述为实现了某种架构风格或模式 [POSA1](../ref.md#posa1) 是一种很好的实践，但如今使用的一些流行语甚至都没有明确的定义。"基于服务的架构" 就是一个典型。没有人知道这到底是什么，也不知道它与设计良好的基于组件的系统有什么不同。这样的误解有很多。人们说 “SOA” ，而其他人则理解为 “Web 服务” ！此外，由于技术经常被炒作，基于炒作的架构往往会导致过早地做出错误的技术决策。

另一个问题就是我们通常所说的行业标准 (industry standards) 。很久以前，制定标准的过程基本如下：尝试几种备选方案，看看哪种最好，然后成立一个委员会，根据以往的经验来定义标准。因此，标准通常接近于最有效的解决方案。如今情况不同了。标准通常由一群（未来的）供应商来定义。要么是他们已经有了工具，而标准必须适应该小组中所有供应商的所有工具的所有解决方案；要么是没有以往的实际经验，而标准是从头开始定义的。这种方法的后果是，标准往往因为没有经验而无法使用，或者过于复杂（因为必须满足所有供应商的要求）。因此，如果在系统的太多方面使用标准，系统就会变得复杂！

最后，还有政治因素。

所有这些因素加在一起，阻碍了人们对架构真正相关方面的思考。在我们看来，这些方面包括架构模式 (architectural patterns)、逻辑结构（logical structures, 架构元模型）、开发人员编程模型 (programming models)、可测试性以及实现关键 QoS (key QoS concerns) 的能力。

下文将简要介绍我们认为合理的软件架构方法，即 MDSD-目标架构。它还为软件开发的许多方面实现自动化铺平了道路，而这正是 MDSD 和产品线工程 (product-line engineering) 的关键要素。

当然，并非只有我们在当前的软件架构中发现了这个问题。您绝对应该阅读一些优秀的架构资源，如 [POSA1](../ref.md#posa1) 、[POSA2](../ref.md#posa2) 和 [POSA3](../ref.md#posa3) ，以及 [JB00](../ref.md#jb00) 、[VSW02](../ref.md#vsw02) 和 [VKZ04](../ref.md#vkz04)。

### 13.4.1 三个阶段

软件架构的开发，尤其是可用于 MDSD 的软件架构的开发，应分三个阶段进行。在这三个阶段中，每个阶段都要创建某些核心产出物 -- 下文将用小标题突出显示这些工件：

- *详细设计 (Elaboration)* 。在第一阶段，即详细设计阶段，您需要定义一个 **独立于技术的架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE)** 。在此基础上，为使用该架构的开发人员定义一个可行的 **编程模型 (PROGRAMMING MODEL)** 。为了让开发人员在本地运行他们的应用程序， **模拟平台 (MOCK PLATFORM)** 是必不可少的。最后，在这一阶段，您需要定义一个或多个 **技术映射 (TECHNOLOGY MAPPINGS)** ，将 **独立于技术的架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE)** 投射到特定的平台上，这些平台可以提供所需的/期望的 QoS 功能。**垂直原型 (VERTICAL PROTOTYPE)** 验证系统是否按预期运行 --在此阶段，您将进行首次负载测试并优化性能-- 同时确保开发人员能够高效地使用 **编程模型 (PROGRAMMING MODEL)** 。 
- *迭代 (Iteration)* 。第二阶段对第一阶段的步骤进行迭代。虽然我们通常建议采用敏捷方法，但我们也要强调一个事实，那就是你通常不会第一次就做对。您通常需要多次执行某些步骤，尤其是 **技术映射 (TECHNOLOGY MAPPINGS)** 和由此产生的 **垂直原型 (VERTICAL PROTOTYPE)** 。在进入第 3 阶段（自动化） *之前* ，完成这些工作非常重要。
- *自动化 (Automation)* 。第三阶段的目标是将第一阶段定义并在第二阶段完善的部分步骤自动化，使架构适用于大型项目和团队。首先，您通常需要生成 **胶水代码 (GENERATE GLUE CODE)** 来自动进行 **技术映射 (TECHNOLOGY MAPPING)** 。另外，你可能经常会注意到，即使是 **编程模型 (PROGRAMMING MODEL)** 也会涉及一些繁琐的重复执行步骤，而这些步骤可以用 **基于 DSL 的编程模型 (DSL-BASED PROGRAMMING MODEL)** 来更简洁地表达。最后，**基于模型的架构验证 (MODEL-BASED ARCHITECTURE VERIFICATION)** 有助于确保架构的正确使用，即使在大型团队中也是如此。

### 13.4.2 第 1 阶段：详细设计
本阶段的最佳实践与领域架构开发主线的 *原型设计、文档编程模型和平台开发* 活动相关。

***技术独立架构***

如何定义一个定义明确、使用寿命长、在实践中可行的软件架构？架构必须相当简单，并能在啤酒杯垫上解释清楚。要确保架构概念能够传达给利益相关者和开发人员。功能需求的实现应尽可能高效。架构必须能够长期存在，比典型的炒作或技术周期更长。架构可能还必须在性能、资源消耗或可扩展性等 QoS 层面上不断发展。

为实现这些目标，应独立于具体技术和实现策略来定义架构概念。明确定义架构构件的概念、约束和关系 -- 术语表或架构元模型 (ARCHITECTURAL METAMODEL) 可以在这方面提供帮助。在后期阶段定义技术映射 (TECHNOLOGY MAPPI)，将此处定义的构件映射到特定的实现平台。使用众所周知的架构风格和模式。通常，这些都是独立于特定技术的某类系统架构的最佳实践。它们为定义系统架构的（各个方面）提供了一个合理的起点。

如果你使用的技术不那么复杂，你就可以把更多精力放在系统的结构、职责和各部分之间的协作上。功能的实现也会变得更有效率，你也不必向所有开发人员讲解最终要使用的各种技术的所有细节。

然而，一个有趣的问题是：在技术独立的架构中， 究竟包含了多少技术？例如，AOP<sup>[1](#1)</sup> 可以吗？我们认为，所有能提供额外表达概念 (additional expressive concepts) 的技术或方法在技术独立架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) 中都是有用的。AOP 就是这样一种候选技术。组件概念也是这样一个概念。消息队列、管道和过滤器以及通用的的架构模式也很有用。

在记录和交流技术独立架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) 时，模型非常有用。我们讨论的 *不是* MDSD 中使用的正式模型 -- 我们稍后再看这些模型。简单的框图和线图、层图、序列图、状态图或活动图可以帮助描述架构的内容。它们可用于说明目的、帮助推理系统或交流架构。正因为如此，它们通常画在啤酒垫、挂图上，或借助 Visio 或 PowerPoint。虽然这些图并不正式，但您仍应确保直观地定义特定视觉元素的含义 -- 即使是非正式图，没有定义含义的方框和线条也不是很有用。

***编程模型***

一旦定义了技术独立的架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) ，并且架构已经推出，开发人员就必须根据架构实现功能。架构是许多非功能性需求和基本功能应用结构的结果，这可能会使架构变得不简单，让开发人员难以理解。如何让（大量）开发人员了解架构？

要确保架构的优势能够真正实现，就必须确保架构得到正确使用。项目团队中有不同资历的开发人员。他们都必须使用架构。您希望能够轻松有效地审查应用代码。您的应用必须保持可测试性。

为了实现这一切，需要定义一个简单一致的编程模型。编程模型从开发人员的角度描述了如何使用架构。它就是 “架构 API” 。编程模型必须针对典型任务进行优化，但也允许在必要时进行更高级的应用。请注意，“如何开发” 指南是编程模型的主要组成部分，它指导开发人员如何构建应用。

在定义编程模型时，最重要的准则是开发人员的可用性和可理解性。因此，编程模型的文档应始终采用教程或演练的形式，而不是参考手册！在这里，框架、库以及 --正如我们将在第 [270](#1344-第-3-阶段自动化) 页的 “基于 DSL 的编程模型 (DSL-BASED PROGRAMMING MODEL)” 中看到的-- 特定领域语言都很有用。

有时，编程模型的定义不可能完全独立于其运行平台（见下一节，技术映射 TECHNOLOGY MAPPING）。有时，平台会对编程模型产生影响。例如，如果您希望以 Enterprise Bean  的形式部署某些东西，您就不应该自己创建对象，因为应用服务器稍后会创建对象。有几条简单的指导原则可以帮助你建立一个编程模型，使其很有可能被映射到各种执行平台上：

- 始终针对接口而非实现进行开发
- 永远不要自己创建对象，一定要使用工厂
- 使用工厂访问资源（如数据库连接）
- 在企业系统中，无状态设计是个好主意
- 分离关注点：确保特定的工件只做一件事，而不是五件。

埃里克-埃文斯（Eric Evans）关于领域驱动设计（domain-driven design）的精彩著作 [Eva03](../ref.md#eva03) 是了解良好编程模型 (PROGRAMMING MODELS) 和技术独立架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) 的好方法。

在项目早期做出技术决策的原因之一是受到政治压力，必须使用特定的技术。例如，您的客户公司可能已经获得了 IBM Websphere 和 DB2 的全球终身许可证：因此，您别无选择，只能使用这两种技术。您可能会问，基于独立技术架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) 和显式技术映射 (TECHNOLOGY MAPPINGS) 的方法是否仍然有效。如果强加的技术是一个很好的选择，那么本文所述方法的优点仍然适用。如果该技术不合适（因为过于复杂，或功能没必要的强大），那么如果在技术映射 (TECHNOLOGY MAPPING) 中将其分离出来，该技术的使用将变得更加容易。

***技术映射***

您的软件必须达到一定的服务质量（QoS）水平。作为项目的一部分实施 QoS 成本高昂。您的团队甚至可能不具备相应的技能。此外，您的系统可能必须根据部署方案在不同的 QoS 级别下运行。您不希望自己实现所有非功能需求的高级功能。您希望在概念讨论和编程模型中不涉及此类技术问题。

因此，应将技术独立架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) 映射到能提供所需 QoS 的特定平台上。显式地进行技术映射。定义有关如何将系统的概念结构（元模型）映射到当前技术的规则。清晰地定义这些规则，使其适用于胶水代码生成 (GLUE CODE GENERATION) 。

在这里而不是之前决定标准的使用。如前所述，标准可能是一个问题，但也可能是一个巨大的好处。对于与核心业务无关的问题，使用标准往往很有用。但请记住：先解决问题，*再* 寻找标准，而不是相反。使用编程模型 (PROGRAMMING MODEL) 来隐藏复杂性。

在此使用特定技术的设计模式。一旦确定了特定的平台，就必须确保正确使用。平台往往不容易使用。不过，如果它是一个常用平台，特定平台的最佳实践和模式已被记录下来。现在正是研究这些内容并将其作为技术映射 (TECHNOLOGY MAPPING) 基础的时候。

让我们来回顾一下：技术独立架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) 定义了可用于构建系统的概念。编程模型 (PROGRAMMING MODEL) 从开发人员的角度定义了如何使用这些概念。技术映射（TECHNOLOGY MAPPING）定义了有关如何将编程模型 (PROGRAMMING MODEL) 工件映射到特定技术的规则。

现在的问题是，您应该选择哪种技术？一般来说，这取决于您必须满足的 QoS 需求。平台善于处理技术问题，如事务、分发 (distribution)、多线程、负载均衡、故障转移 (failover) 或持久性 (persistence)，您不希望自己实现这些功能。因此，请使用能提供所需服务的平台，并达到所要求的 QoS 水平。这通常是针对具体部署的。

当然，有时您必须根据政治因素来决定您的平台。如果一家公司在 Oracle 和 Websphere 上构建了一切，你就很难反对这些。不过，基于此以及前面提到的两个最佳实践，技术独立架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) 和编程模型 (PROGRAMMING MODEL) 仍然有用，因为它可以让你了解 *不使用* 理想平台的后果。你可能不得不使用一种折衷方案，但至少你会知道这是一种折衷方案！

***模拟平台***

基于编程模型 (PROGRAMMING MODEL) ，开发人员现在知道如何构建应用。除此之外，开发人员还必须能够在本地运行（部分）系统，至少是运行单元测试。如何确保开发人员能够在本地运行 “他们的东西”，而无需关心技术映射 (TECHNOLOGY MAPPING) 及其对调试和测试设置可能带来的复杂情况？您还希望确保开发人员能尽早运行他们的代码。您希望尽量减少特定开发人员对其他项目成员的依赖，特别是那些关心非功能性需求和技术映射 (TECHNOLOGY MAPPING) 的成员。您必须确保开发人员能够高效地运行单元测试。

定义能运行的最简单的技术映射 (TECHNOLOGY MAPPING)。提供一个尽可能模拟或 stubs 架构的框架。确保开发人员可以测试他们的应用代码，而无需关心 QoS 和技术基础设施。

这种模拟平台对于规模较大且可能是分布式的团队来说至关重要，它允许开发人员运行自己的代码，而无需过多考虑其他人或基础设施。这对单元测试至关重要！如果系统模块化良好，测试业务逻辑就很简单。如果遵守编程模型 (PROGRAMMING MODEL) 中给出的指导原则（接口、工厂、关注点分离），就可以很容易地模拟其他人开发的技术基础架构和其他工件。

请注意，您必须有一个定义明确的编程模型，否则您的技术映射（TECHNOLOGY MAPPING）将无法可靠运行。此外，在模拟平台上运行的测试不会发现 QoS 问题 -- QoS 由执行平台提供。

***垂直原型***

您的架构必须实现的许多非功能性要求取决于技术平台，而您最近才在技术映射 (TECHNOLOGY MAPPING) 中选择了技术平台。由于模拟平台 (MOCK PLATFORM) 忽略了这些方面的大部分内容，因此无法使用模拟平台 (MOCK PLATFORM)  对这些方面进行验证。映射机制甚至可能是低效的。如何确保不走入死胡同？您希望您的架构尽可能不受特定技术的影响。但是，您要确保能够满足所有非功能性需求。您要确保不会投资于不可行的技术映射。

因此，一旦你对技术独立架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE)  和技术映射 (TECHNOLOGY MAPPING) 有了合理的理解，就要确保对非功能性需求进行测试。构建纵向原型 (vertical prototype) ：使用上述所有技术，但仅实现一小部分功能需求集的应用。尤其包括性能和负载测试。

垂直原型是一种众所周知的降低风险的方法。在这里建议的架构方法中，垂直原型比其他方法更为重要，因为您必须验证编程模型不会导致日后的 QoS 问题。您必须确保您在架构中定义的各个方面能够真正协同工作。

### 13.4.3 第二阶段：迭代
既然已经建立了基本机制，就应该确保它们在项目中真正发挥作用。因此，要对上述步骤进行迭代，直到它们达到合理的稳定性和实用性。

然后，如果您的项目团队规模较大，则将架构推广到整个团队。如果您想启动模型驱动的开发流程，请继续第 3 阶段。

### 13.4.4 第 3 阶段：自动化
本阶段的最佳实践与领域架构开发主线中的：*衍生参考实现/模型、衍生转换和领域分析/设计* 等活动相关。

您有一个技术独立架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) 。您希望将软件开发过程中的各种任务自动化。为了实现自动化，您必须编写技术映射 (TECHNOLOGY MAPPING) 规则并定义基于 DSL 的编程模型 (DSL-BASED PROGRAMMING MODEL) 。在这两方面，您都必须非常清楚和准确地了解技术独立架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) 中定义的工件。如果不能形式化转换规则，就无法实现自动化。基于文档 (prose) 的架构定义不够形式化：您需要能够检查模型的架构一致性。

因此，要定义一个正式 (formal) 的架构元模型。架构元模型形式化地定义了技术独立架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) 的概念。理想情况下，这种元模型还可用于自动开发的转换器/生成器。

形式化是一把双刃剑。虽然它有一些明显的好处，但也需要比非正式模型做更多的工作。要证明额外工作的合理性，唯一的方法就是获得额外的好处。最有用的好处是元模型不会被束之高阁，而是在开发过程中真正为工具所用。因此，元模型的使用至关重要，例如在基于 DSL 的编程模型 (DSL-BASED PROGRAMMING MODELS) 和基于架构的模型验证 (ARCHITECTURE-BASED MODEL VERIFICATION) 中作为代码生成的一部分。

***胶水代码生成***

技术映射 (TECHNOLOGY MAPPING) --如果足够稳定-- 通常是重复性的，因此实现起来既繁琐又容易出错。此外，在技术映射代码 (TECHNOLOGY MAPPING) 中还经常需要重复编程模型 (PROGRAMMING MODEL) 工件中已经定义好的信息（方法签名就是典型的例子）。重复的、标准化的技术映射是好的，因为它是一个深思熟虑的架构的标志。重复的实现总是容易导致错误和挫折。

要解决这些问题，可以使用基于技术映射 (TECHNOLOGY MAPPING) 规范的代码生成来生成胶合代码层，以及其他适应性工件，如描述符、配置文件等。为了实现这一点，你可能需要将技术独立架构 (TECHNOLOGY-INDEPENDENT ARCHITECTURE) 形式化为架构元模型（ARCHITECTURAL METAMODEL）。为了获取代码生成所需的信息，您可能需要使用基于 DSL 的编程模型 (DSL-BASED PROGRAMMING MODELS) 。

构建和测试自动化是当前软件开发中公认的最佳实践。下一步自然是编程自动化 -- 至少是那些重复性的、受明确规则约束的问题。技术映射 (TECHNOLOGY MAPPING) 所需的代码和配置文件就是典型的候选对象。生成这些工件有几个好处。首先，它效率更高。其次，以生成器的形式 “实现” 技术映射 (TECHNOLOGY MAPPING) 的要求有助于完善技术映射 (TECHNOLOGY MAPPING) 规则。代码质量通常会得到改善，因为代码生成器不会犯任何意外错误 -- 它也可能是错的，而这样生成的代码通常总是错的，因此更容易发现错误。最后，开发人员不必再重复执行乏味的胶水代码，这是一项枯燥、令人沮丧、容易出错的工作。


***基于 DSL 的编程模型***

您已经定义了一个编程模型 (PROGRAMMING MODEL) 。但是，您的编程模型 (PROGRAMMING MODEL) 仍然过于复杂，其中有大量重复实现的特定领域算法。领域专家很难在日常工作中使用编程模型 (PROGRAMMING MODEL)。胶水代码生成 (GLUE CODE GENERATION) 需要有关程序结构的信息，而这些信息很难或不可能从作为编程模型 (PROGRAMMING MODEL) 一部分编写的代码中获得。编程模型 (PROGRAMMING MODEL) 仍处于编程语言的抽象层面。特定领域的语言特点无法实现。解析代码以获取有关生成何种胶合代码的信息非常繁琐，而且代码也不具备必要的丰富语义。

定义特定领域语言，开发人员可以用这种语言简明扼要地描述应用的结构和行为。根据这些模型生成底层实现代码。生成骨架，开发人员可根据该骨架对无法从模型中完全生成的方面进行编码。

基于 DSL 的编程模型标志着进入了模型驱动软件开发领域。为系统的各个方面定义 DSL，然后根据上述定义的编程模型 (PROGRAMMING MODEL) 生成实现代码，是一种非常强大的方法。另一方面，定义有用的 DSL、提供合适的编辑器以及实现生成高效代码的生成器都是一项非同小可的任务。因此，只有在生成器经常被重复使用，“正常” 编程模型 (PROGRAMMING MODEL) 非常复杂，DSL 可以提高工作效率，或者想要进行复杂的基于模型的架构验证 (MODEL-BASED ARCHITECTURE VALIDATION) 时，这一步才有意义。

对领域的理解越深刻，DSL 的表现力就越强（生成器的功能也就越强大）。为了管理复杂性，您应该建立级联的 DSL/生成器对。最底层基本上是胶水代码生成器 (GLUE CODE GENERATOR) ：更高层提供越来越强大的基于 DSL 的编程模型 (DSL-BASED PROGRAMMING MODELS)。

***基于模型的架构验证***

现在，您已经准备好了所有的工件，并向更多的开发人员推出了您的架构。您必须确保编程模型 (PROGRAMMING MODEL) 的使用符合预期。不同的人可能有不同的资质。正确使用编程模型对于架构实现其 QoS 承诺也至关重要。检查系统是否符合架构要求至关重要。然而，仅使用人工审核来开展这项活动并不适合大型团队和潜在的分布式团队。由于开发人员不需要考虑大量的技术复杂性（这些复杂性都在生成的胶水代码 GENERATED GLUE CODE 中），因此无需检查这些问题。在源代码层面检查编程模型 (PROGRAMMING MODEL) 的使用情况非常复杂，这主要是所使用编程语言的复杂细节造成的。

确保关键的架构问题要么作为基于 DSL 的编程模型 (DSL-BASED PROGRAMMING MODEL) 的一部分加以规定，要么限制开发人员在生成的骨架中添加 3GL 代码。这样就可以在模型层面上进行架构验证，这一点非常简单：可以根据架构元模型 (ARCHITECTURE METAMODEL) 中定义的约束条件来指定。

这就是你想要的结果。在大型项目中，您必须能够从架构的角度，通过自动检查来验证系统的特性。其中一些检查可以在代码层面通过使用度量 (using metrics) 等方法来完成。但是，如果系统的关键方面是用模型来描述的，你就可以使用更强大的验证和确认工具。

使用架构元模型 (ARCHITECTURE METAMODEL) 来验证模型/规范是至关重要的。良好的模型驱动软件开发工具（如 openArchitectureWare 生成器 [OAW](../ref.md#oaw) ）可以读取（架构）元模型，并使用它们来验证输入模型。这样，元模型就不是 “单纯的文档”，而是开发工具使用的工件。下面的内容展示了该工具的工作原理。

---
#### 1
面向方面编程 [Lad03](../ref.md#lad03)。
