## 8.4 解释器的使用
Arno Haase

本书在讨论 MDSD 时主要考虑代码生成。这可能是目前最广泛采用的 MDSD 实现方式，但解释器是一种采用不同方法的实现方式，其遵循相同的底层原理，并符合 “自动将形式化模型转换为可执行代码” 的定义，只是实现方式有所不同。

解释器和生成器在功能上是等同的。每个模型都可以作为其中任何一种的输入，至少原则上是这样。不过，更常见的情况是，生成器用于系统的结构方面，而解释器用于行为方面。这样做的理由是，结构方面是结构性的。 许多处理结构化方面（如持久化、远程通信或任何类型的组件交互与集成）的主流库，要求数据结构以显式源代码的形式存在，因此需要生成代码才能将其作为平台的一部分使用。 这主要是一个品味问题，很容易构想出 (基于通用数据结构的) 结构框架，从而允许使用解释器。然而，目前被广泛使用的主流库走的是一条不同的道路，其中一个主要原因是传统上对性能的关注。

另一方面，行为方面历来被认为对系统整体性能的影响较小<sup>[7](#7)</sup> 。此外，行为模型的抽象通常比将它们粘合在一起的代码量（例如工作流中的步骤）要大，从而进一步降低了解释器对性能的影响。与生成器相比，表达式解释器更便于构建和测试。此外，改变解释器的模型只需重启系统即可，这也增加了这种方法的便利性。因此，系统的行为方面通常使用解释器而不是生成器来实现。

下文将结合 MDSD 对解释器进行更深入的探讨。

### 8.4.1 解释器
解释器是一种软件，它在 *运行* 时读取和评估模型，执行模型中指定的任何操作。与生成器一样，解释器也是针对具有精确定义语义的形式化模型工作的，这两种技术的结果都是执行模型中指定的操作。“操作执行” 这一术语的使用非常宽泛：它的含义包括编译器生成的用于处理生成结构定义的代码。

<ins>这两种方法都需要一个模型解析器，即把模型从具体语法转换为抽象语法（通常是内存中的对象图）的软件。这两种方法的解析器，在生成器和解释器对同一模型的共享程度上是相同的。</ins>

解释器在两个方面不同于生成器（或 *编译器* ，使用编程语言术语）：分析模型的时间点和执行操作的方式。让我们来详细看看这两方面的区别：

- *分析时间* 。对于要构建的系统，生成器通常在构建时对模型进行分析，而解释型方法可以在运行时对模型进行读取和分析，允许对运行中的系统进行后期绑定和更改。
- *执行模式* 。据称，解释器会依次查看模型的各个部分，区分不同类型的模型元素，并根据所看到的内容执行不同的代码。这与生成式方法不同，在生成式方法中，生成器会查看模型的各个部分，并将不同部分的代码组合成源文件，然后进行编译。解释器在执行时还会使用一个间接层次。

不过，这些区别并不像看上去那么严格（对于怀旧的人来说，也不像以前那么严格）。例如，在某些领域，在执行时生成 Java 字节代码已经成为一种常见的做法，从而使生成器获得了延迟绑定的好处。此外，越来越多的解释器都带有预处理组件，可在构建时检查和验证模型，确保在构建时而不是在执行时发现某些类型的错误。

越来越多的解释器更进一步，采用了两步法。在构建时读取和验证原始模型，然后将其转换为优化的中间格式，通常称为 *字节码* <sup>[8](#8)</sup> 。然后，实际解释器（或虚拟机）只读取和解释字节码。使用这种中间格式的优势与分几步转换模型的优势相同：通过引入精心选择的中间抽象，简化了每一步。

结合这两种方法的另一种特别常见的做法是生成在执行时解释的模型。对于配置文件和平台库（如持久性框架）来说，这种做法非常常见。

因此，尽管区分解释器和生成器很有用，但最好记住，决定使用其中一种还是另一种并不是一个非黑即白的问题。相反，我们可以将这两种方法结合起来，或者在需要特定非功能特性时，逐步从一种方法过渡到另一种方法。

许多规则引擎采用了另一种方法来处理这种二元性。这些引擎通常为同一模型同时提供解释器和生成器，由使用该引擎的开发人员在两者之间做出选择，并考虑其非功能性影响。

### 8.4.2 重温 MDSD 术语
解释器和生成器都是实现 MDSD 的技术，因此显然共享 MDSD 的核心抽象。但解释器与生成器来自不同的编程文化背景，涉及不同的权衡取舍，因此从解释器的角度重新审视 MDSD 的关键概念是有益的。

***领域***

我们将领域定义为有边界的知识领域，目的是使该术语具有广泛的适用性。这个定义显然没有对特定领域使用解释器还是生成器做出任何假设。

不过，有些领域显然更适合采用生成器方法，尤其是结构方面，而其他领域则更容易采用解释器方法。因此，在进行领域分析时，有意识地对以后的实现技术持开放态度，推迟决定是为特定领域构建生成器还是解释器，或者是手工编码，直到对该领域有了扎实的了解，这样做是很有帮助的。

<ins>解释器-生成器的决策也会影响我们如何划分领域的边界。生成器和解释器对特定领域的作用范围通常在某种程度上是不同的</ins>：例如，如果模型需要被解释，那么在实体元模型中包含约束检查会更加自然，而如果模型仅作为生成器的输入，则情况则不同。因此，好的做法是稍微改变一下领域边界，以找到最适合特定系统环境的方法。

***元模型***

任何一种元模型都可以作为生成器或解释器的基础。<ins>但更常见的是，结构元模型使用生成器，而描述行为的元模型则使用解释器</ins>。

***元元模型***

解析器 (parser) 对于解释器和生成器来说是相同的，因此元元模型对于两者来说也是相同的 -- 至少在原则上是如此。例如，完全可以用 MOF 来定义解释模型的抽象语法，即使它是围绕 “表达式” 这一关键抽象组织起来的行为元模型。不过，对行为模型来说，这样做远没有对结构模型那么常见。

***形式模型***

任何具有具体语法的模型都可以作为生成器和解释器的输入。但是，行为丰富的文本模型是解释器尤其可以大显身手的领域，因为它们可以容易地使用与底层编程语言语义略有不同的基础构件。由于这些文本模型看起来很像众所周知的 3GL 源代码，因此也经常被称为 “源代码”。

***平台***

生成器和解释器都基于平台代码（即目标平台上已有的代码），通常最好尽可能多地使用平台代码。不过，解释器与平台的交互与生成器不同。

首先，平台库和框架通常只需要一种交互方式，因此无论使用哪种 MDSD 方法，都必须满足它们的需求。举例来说，如果持久化框架要求业务对象存在于类似结构体的类中，那么解释器可能无法直接提供这些对象：它们需要生成。另一方面，API 调用既可以从生成的代码中执行，也可以从解释器中执行。

其次，从概念上讲，解释器本身也可视为平台的一部分。解释器是用底层编程语言编写的，可被视为提供特定服务。但是，即使我们不采取如此激进的观点，解释器与其支持框架和库代码之间的区别也比生成器更加模糊，因为在生成器中，特定代码要么生成，要么不生成。

### 8.4.3 解释器的非功能特性
那么，什么时候应该使用生成式方法，什么时候更适合使用解释器呢？第 [9.1](../ch9/1.md) 节中列出的生成器的大多数优点也适用于解释器。尽管如此，下面的列表讨论了两种方法的不同权衡。

***性能***

只要涉及解释器，这就是首要问题。解释器本身就比生成代码慢，这主要是因为底层编程语言的编译器可以执行的优化较少，而且通常有更多的间接代码 <sup>[note](#note)</sup>。

显然，在某些领域，性能是最重要的，如嵌入式实时系统，这就排除了解释型方法。然而，对于其他系统来说，由于 I/O 操作占据了大部分时间，因此对于特定部分的操作来说，30%-50% 的性能开销可能根本不会引起注意。

因此，虽然性能影响有时会排除使用解释器的可能性，但这绝不意味着解释器普遍无用。性能差异必须根据每个系统的具体情况来衡量，通常在解释器内部进行优化就能提供足够的性能。

***代码量***

除非非常小心，否则生成器生成的代码量会超过原始模型所包含的代码量，从而导致生成器比解释器占用更多代码。另一方面，这对大多数系统来说并不是问题。对于嵌入式系统来说，内存是个问题，可分析性和可预测性是生成器优于解释器的充分理由。

***绑定时间***

解释器允许在运行时进行后期绑定，而生成器代码通常在编译时绑定。与生成器相比，这是解释器的最大优势，为许多有益的实践打开了大门。

首先，可以在运行时更改模型并直接影响系统行为，而无需重新部署或重建，甚至无需重启。虽然这在生产环境中并不十分有用，但却能缩短调试周期，使需求工程师坐在机器前就能发现并修复错误。

其次，它使并行运行多个版本的业务逻辑变得非常简单。这主要在两种情况下非常有用：这主要在两种情况下有用：在基于授权者 (mandator) 的系统中（即由独立的逻辑 “分区” 组成的系统，这些分区对应于不同的用户组——授权者），每个授权者可能拥有略微不同的逻辑版本。 另一种情况是，需要使用旧数据运行旧版本的业务逻辑，而必须使用新业务逻辑处理新数据。在这种系统中，每个任务执行器或数据集都可以引用适用于它的业务逻辑模型，从而允许使用相同的解释器处理所有数据。

### 8.4.4 将解释器集成到系统中
解释器必须与系统的其他部分结合起来才能发挥作用。解释器与外部世界交互的三个关键点：即调用解释器的接口；系统可以从模型调用特定功能的扩展点；以及向解释器提供模型的机制。我们将依次探讨这三点。

***调用解释器***

解释器是用平台编程语言编写的代码，因此可以像其他代码一样调用。解释器通常提供一个简单的接口，基本上只有一个方法，接收作为参数传递给被解释模型的对象，以及描述应执行哪个模型或模型部分的标识符，并返回模型的执行结果。这种简单的调用接口可以很自然地封装在一个组件中。

与其他组件一样，解释器也可以对其他组件或资源（如文件或数据库）进行操作。在这种情况下，必须让解释器知道这些资源，就像必须让任何其他组件知道这些资源一样，例如：使用依赖注入、参数传递、在集中注册表中查找，甚至是全局变量。

***扩展点***

定义一个全面的元模型来处理一个领域的所有方面往往是不可行的。这样做往往会带来巨大的额外复杂性，而简单性正是我们使用 MDSD 的原因之一。因此，最好的做法是在元模型中定义扩展点，允许模型引用用底层编程语言编写的代码。在持久化语言中创建主键值的算法就是一个很好的例子：元模型中应该明确列出常用策略，但也应该有一种方法来处理需要特殊策略的罕见情况。

这种扩展的最佳机制取决于编程语言：以 Java 为例，通常的方法是在模型中提供一个完全限定的类名并使用反射。

***提供模型***

解释器在运行时需要执行模型，因此应用必须提供模型。解释器的模型通常是文本文档，这就为模型的存储和提供提供了多种可能性。

最简单的方法是将其作为系统的一部分部署。如何做到这一点取决于底层语言 -- 例如，在 Java 中，它们可以被打包到组成系统的 JAR 文件中。这种方法实际上去掉了后期绑定的大部分优点，但另一方面，它使部署模型变得简单。

另一种方法是将模型存储为外部资源，并让系统在运行时检索它们。这可以通过文件来实现，对于集群服务器来说，可以将其存储在共享文件服务器上，但也完全可以将其存储在数据库、FTP 服务器或系统可以访问的任何地方。这使它们成为一级 (first-class) 资源，提高了灵活性，但也增加了部署和系统管理的复杂性。

### 8.4.5 解释器和测试
与其他软件一样，解释器也需要测试。与任何一种 MDSD 一样，测试有两种方式。

***测试解释器***

解释器往往比生成器更容易测试，因为它们不需要生成代码。事实上，解释器可以直接使用普通的单元测试进行测试，尤其是在处理文本模型的情况下。

最普遍的方法是使用黑盒测试，为整个解释器提供一个模型，然后检查结果。然而，许多解释器都是天然模块化的，因此可以进行粒度更细的测试。例如，可以采取这样的形式，即只向解析器提供一个表达式作为输入，然后将生成的抽象模型提供给解释器执行部分的表达式部分。

原则上，可以通过将手动组装的抽象语法树传递给解释器的执行引擎，以更精细的粒度进行测试。然而，以这种方式绕过解析器，很少能给文本模型带来额外的好处，因为通常可以直接找到一个具体语法片段来生成给定的抽象模型片段。然而，对于基于非常复杂的具体语法的解释器来说，绕过解析器可能是有用的。

***测试模型***

可以使用普通的单元测试来测试模型，通过官方接口调用解释器并检查结果或副作用。

不过，解释器的另一个好处是，可以在不重启系统的情况下更改模型，使系统立即显示修改后的行为。这就使得与需求工程师一起进行调试成为可能，在调试过程中，双方可以反复修改模型，直到系统的行为符合预期。

---
#### 7
显然，这种情况也有例外。但即使在数值模拟领域，系统读取并解释待解决问题的模型也是很常见的。通过使用大型构件（如微分方程的整个求解器）作为平台的一部分，可以实现良好的性能。

#### 8
这种字节码可以使用现有的虚拟机（如 JVM），但也完全可以定义一种特别适合相关领域的特定字节码。其中一个例子就是 Eclipse GMT ATL 模型到模型转换引擎。

#### note
译注：这句话，应该将编译器改为解释器更合理。
