## 8.3 构建转换的技术方面
除了本节描述的最佳实践外，我们还将在下面两章中描述代码生成和模型到模型转换的一些细节。

### 8.3.1 生成代码与人工部分的显式集成
显式集成意味着一开始生成的代码完全独立于手写代码。开发人员可以自行整合这些人工制品。只有极少数情况下，这两种代码实际上是完全独立的--非生成代码经常依赖于生成代码，因为它们在系统上下文中通常是一起使用的。

最简单的集成方法是在生成代码中创建保护区域，开发人员可以在其中插入手写代码。这些区域的指定方式可以让生成器读取，这样手写代码就不会在生成器的后续运行中被覆盖。

UML 工具通常以这种方式工作。在这里，类存根由模型数据生成，然后开发人员将行为集成到类存根中。图 8.14 展示了这一点：

![Figure 8.14](../img/f8.14.png)

这种方法有许多缺点：
- 生成器更加复杂，因为它必须承认保护区的管理、认可和保存。
- 保护区的内容并不总是那么容易实现。在实践中，代码有时会丢失。
- 生成代码和手写代码的分离消失了，因为两者都在同一个文件/类中。

最后一点是最棘手的问题，因为开发人员必须在生成的代码中工作。为此，他们必须首先理解代码，而这并非易事。软件开发的其他方面（如版本控制）也变得更加复杂。

因此，应考虑其他集成机制。一种经常采用的解决方案（同时也能处理与平台的集成）是三层实现。在许多情况下，必须生成的系统组件包括三种功能：

- 对某一类型的所有组件都相同的功能。
- 针对每个组件的不同功能，但可以从模型中生成。
- 必须由开发人员手动实现的功能。

图 8.15 所示的方法是在面向对象语言中实现这种功能的一种行之有效的技术：

![Figure 8.15](../img/f8.15.png)

作为平台的一部分，为某一类型的所有组件实现了一个抽象超类。对于每个组件，生成器都会生成一个抽象的中间类，该类继承于超类，并实现了可从模型中推导（从而生成）的所有方面。最后但并非最不重要的一点是，开发人员要创建一个非抽象的实现类，该类继承自生成类。系统随后将通过实例化的方式使用该类。这个手动实现的类可以 “填补” 生成的中间类的 “漏洞” 。借助 “四人帮” 模式 [GHJ+94](../ref.md#ghj94) ，可以非常优雅地完成这一工作。本节的其余部分以及图 8.16 将解释如何做到这一点。

![Figure 8.16](../img/f8.16.png)

在图 8.16 案例 a) 中，生成的代码调用非生成的代码。这几乎是微不足道的。在生成的代码中，我们总是会访问非生成的代码--毕竟，我们会继续使用久经考验、值得信赖的库。在这种情况下，应进一步解释：应尽可能少生成代码，并在可行的情况下，使用现有的、经过测试的代码，这些代码在平台形状的领域架构中占有一席之地。

情况 b) 就不那么明显了。在这里，手动实现的代码调用生成的代码。为此，手动实现的代码必须 “了解” 生成的代码，这可能会在构建过程中产生令人不快的依赖关系。案例 c) 可以在这方面提供帮助。在这里，生成的代码可以从手动创建的类继承，或分别实现一个手写接口。然后，手写代码可以根据该接口进行编程。运行时，生成类的实例将被实例化，例如使用工厂操作。

让我们回到有保护区的例子：避免保护区的一种方法是使用继承，如案例 d) 所示。在这里，一个实现类继承自生成的超类。实现类覆盖生成的操作，并以这种方式提供行为。工厂可以再次帮助实例化。当然，如案例 e) 所示，生成的代码可以继承自非生成类，并在必要时调用其操作。

情况 f) 也很有趣，手动实现的类或其操作会调用生成子类的操作。这基本上是模板方法 (Template Method) 模式的一种用法。非生成的超类定义了一些抽象操作，这些操作会被生成的类覆盖。超类的其他操作会调用这些抽象操作。此外，工厂还有助于实例化。
