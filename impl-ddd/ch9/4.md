## `Agile Project Management Context`的模块

#### ▶[上一节](3.md)

SaaSOvation 目前的 [Core Domain (2)](../ch2/0.md) 是`Agile Project Management Context`，因此，我们有必要了解其模块的设计方式。

ProjectOvation 团队选择了三个顶级模块：`tenant`、`team` 和 `product` 。首先来看第一个模块：

```java
    com.saasovation.agilepm.domain.model.tenant
        <<value object>> TenantId
```

其内容是一个简单的`value Object` `TenantId`，用于存储特定租户的唯一标识，该标识来源于`Identity and Access Context`。在该模块的情况下，模型中几乎所有其他模块都会依赖于它。它对于实现不同租户对象之间的隔离至关重要。并且，这种依赖关系是无环的，`tenant`模块并不依赖其他模块。

`team`模块包含`Aggregates`以及一个用于管理产品团队的`Domain Service`：

```java
    com.saasovation.agilepm.domain.model.team
         <<service>> MemberService
         <<aggregate root>> ProductOwner
         <<aggregate root>> Team
         <<aggregate root>> TeamMember
```

这里包含三个`Aggregates`和一个`Domain Service`接口。`Team` 类中包含一个 `ProductOwner` 实例，以及一个存储任意数量 `TeamMember` 实例的集合。`ProductOwner` 和 `TeamMember` 实例由 `MemberService` 创建。这三个`Aggregate Root Entities`均引用了 `tenant` 模块中的 `TenantId`：

```java
package com.saasovation.agilepm.domain.model.team;
import com.saasovation.agilepm.domain.model.tenant.TenantId;
public class Team extends ConcurrencySafeEntity {
    private TenantId tenantId;
    ...
}
```

`MemberService` 是 [Anticorruption Layer (3)](../ch3/0.md) 的前端接口，负责将产品团队成员与`Identity and Access Context`中的标识和角色进行同步。该同步操作在后台进行，与常规用户请求相互独立、异步执行。这个服务是主动式的，当用户在远端上下文中完成注册后，它会自动创建对应的团队成员。虽然该同步与远端系统最终会保持一致，但相较于远端发生的实际变更，会存在短暂的延迟。此外，它还会根据需要更新成员的详细信息，例如姓名和电子邮箱地址。

`Agile Project Management Context`拥有一个名为 `product` 的父模块，以及三个子模块，具体如下：

```java
    com.saasovation.agilepm.domain.model.product
        <<aggregate root>> Product
        ...
    com.saasovation.agilepm.domain.model.product.backlogitem
        <<aggregate root>> BacklogItem
        ...
    com.saasovation.agilepm.domain.model.product.release
        <<aggregate root>> Release
        ...
    com.saasovation.agilepm.domain.model.product.sprint
        <<aggregate root>> Sprint
        ...
```

这正是 Scrum 核心概念的建模落地之处。在这里，你可以找到`Product`、`BacklogItem`、`Release`和`Sprint`这些`Aggregates`。在 [Aggregates (10)](../ch10/0.md) 章节中，你会了解到为何这些概念会被建模为相互独立的`Aggregates`。

---

| ||
|---|---|
|团队很喜欢这些模块依据`Ubiquitous Language`呈现出的自然可读性：`product`，`product backlog item`，`product release`和`product sprint`。|<img src="../img/cbl.2.png" width="50%"/>|

既然只有四个联系紧密的`Aggregates`，数量如此之少，团队为何没有将它们全部放在`product`模块中呢？需要说明的是，这里并未展示每个`Aggregate`包含的所有其他组成部分——比如`Product`包含的`ProductBacklogItem Entity`、`BacklogItem`包含的`Task Entity`、`Release`包含的`ScheduledBacklogItem`，以及`Sprint`包含的`CommittedBacklogItem`。此外，每种`Aggregate`类型还包含其他一些`Entities`和`Value Objects`，部分`Aggregates`还会发布不少`Domain Events`。总而言之，将近 60 个类和接口放在单个模块中，会让该模块变得十分臃肿繁杂，给人一种明显缺乏条理的印象。因此，团队优先考虑了模块的条理性，而非跨模块耦合的相关顾虑。

与`ProductOwner`、`Team`和`TeamMember`一样，`Product`、`BacklogItem`、`Release`和`Sprint`所有这些`Aggregate`类型，都会引用`TenantId`。除此之外，它们之间还存在其他依赖关系。`Product`为例：

```java
package com.saasovation.agilepm.domain.model.product;

import com.saasovation.agilepm.domain.model.tenant.TenantId;

public class Product extends ConcurrencySafeEntity {
    private ProductId productId;
    private TeamId teamId;
    private TenantId tenantId;
    ...
}
```

此外，我们来看一下`BacklogItem`：

```java
package com.saasovation.agilepm.domain.model.product.backlogitem;

import com.saasovation.agilepm.domain.model.tenant.TenantId;

public class BacklogItem extends ConcurrencySafeEntity {
    private BacklogItemId backlogItemId;
    private ProductId productId;
    private TeamId teamId;
    private TenantId tenantId;
    ...
}
```

对`TenantId`与`TeamId`的引用均为非循环依赖，其依赖关系呈单向性。然而，`BacklogItem`待办项对产品标识的引用看似形成了从待办项模块指向产品模块的非循环依赖，实际却是双向依赖。每个产品均充当工厂，用于创建待办项、发布版本和迭代冲刺的实例，因此二者存在双向依赖关系。尽管如此，这三个子模块均隶属于产品模块，我们可对依赖规则稍作放宽。在此场景下，我们选择以组织层面的设计优势换取一定的耦合性。此外，待办项、发布版本和迭代冲刺本就是产品所包含的固有且理应存在的子概念，因此除聚合边界外，再对这些概念进行拆分并无实际意义。

`TenantId`和`TeamId`的引用属于无环依赖，它们的依赖关系是单向的。
然而，尽管`BacklogItem`对`ProductId`的引用，表面上看形成了从 backlogItem 模块到 product 模块的无环依赖，但实际上这是一种双向依赖。原因在于：每个`Product`都充当了创建`BacklogItem`（以及`Release`、`Sprint`）实例的`Factory`。因此，二者之间的依赖关系是双向的。
即便如此，这三个子模块（backlogItem、Release、Sprint）都是 product 模块的子模块，我们可以适当放宽依赖规则。在这里，我们做了一个权衡：优先选择组织上的合理性，而非过度追求低耦合。
再者，BacklogItem、Release 和 Sprint 本质上都是 Product 理应包含的子概念，因此，除了在`Aggregate`边界之外，再试图拆分这些概念是毫无意义的。

不过，团队难道就不能通过使用一种通用标识类型（generic identity type），来实现这些元素之间的松耦合吗？在这种方式下， BacklogItem 、Release 和 Sprint 都会以一种非绑定的方式（nonbinding manner）来引用它们所属的 Product 。

```java
public class BacklogItem extends ConcurrencySafeEntity {
    private Identity backlogItemId;
    private Identity productId;
    private Identity teamId;
    private Identity tenantId;
    ...
}
```

诚然，团队本可以实现更低的代码耦合度。但与此同时，这也会带来潜在的代码 Bug 风险，因为各类标识 Identity 类型 之间将无法被有效区分。

`Agile Project Management Context`将会持续演进。SaaSOvation 公司计划支持其他敏捷方法和工具，这一举措将会对当前的模块产生影响：至少会推动新模块的创建，而且很可能也会促使现有模块发生变更。秉持敏捷思维的团队，承诺会以审慎严谨的态度，对这些模块进行重构优化。

---

接下来，让我们通过系统的源代码来考虑模块在其他位置的使用方式。

#### ▶[下一节](5.md)
