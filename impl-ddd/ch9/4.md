## `Agile Project Management Context`的模块

#### ▶[上一节](3.md)

SaaSOvation 目前的 [Core Domain (2)](../ch2/0.md) 是`Agile Project Management Context`，因此，我们有必要了解其模块的设计方式。

ProjectOvation 团队选择了三个顶级模块：`tenant`、`team` 和 `product` 。首先来看第一个模块：

```java
    com.saasovation.agilepm.domain.model.tenant
        <<value object>> TenantId
```

其内容是一个简单的`value Object` `TenantId`，用于存储特定租户的唯一标识，该标识来源于`Identity and Access Context`。在该模块的情况下，模型中几乎所有其他模块都会依赖于它。它对于实现不同租户对象之间的隔离至关重要。并且，这种依赖关系是无环的，`tenant`模块并不依赖其他模块。

`team`模块包含`Aggregates`以及一个用于管理产品团队的`Domain Service`：

```java
    com.saasovation.agilepm.domain.model.team
         <<service>> MemberService
         <<aggregate root>> ProductOwner
         <<aggregate root>> Team
         <<aggregate root>> TeamMember
```

这里包含三个`Aggregates`和一个`Domain Service`接口。`Team` 类中包含一个 `ProductOwner` 实例，以及一个存储任意数量 `TeamMember` 实例的集合。`ProductOwner` 和 `TeamMember` 实例由 `MemberService` 创建。这三个`Aggregate Root Entities`均引用了 `tenant` 模块中的 `TenantId`：

```java
package com.saasovation.agilepm.domain.model.team;
import com.saasovation.agilepm.domain.model.tenant.TenantId;
public class Team extends ConcurrencySafeEntity {
    private TenantId tenantId;
    ...
}
```

`MemberService` 是 [Anticorruption Layer (3)](../ch3/0.md) 的前端接口，负责将产品团队成员与`Identity and Access Context`中的标识和角色进行同步。该同步操作在后台进行，与常规用户请求相互独立、异步执行。这个服务是主动式的，当用户在远端上下文中完成注册后，它会自动创建对应的团队成员。虽然该同步与远端系统最终会保持一致，但相较于远端发生的实际变更，会存在短暂的延迟。此外，它还会根据需要更新成员的详细信息，例如姓名和电子邮箱地址。

`Agile Project Management Context`拥有一个名为 `product` 的父模块，以及三个子模块，具体如下：

```java
    com.saasovation.agilepm.domain.model.product
        <<aggregate root>> Product
        ...
    com.saasovation.agilepm.domain.model.product.backlogitem
        <<aggregate root>> BacklogItem
        ...
    com.saasovation.agilepm.domain.model.product.release
        <<aggregate root>> Release
        ...
    com.saasovation.agilepm.domain.model.product.sprint
        <<aggregate root>> Sprint
        ...
```

这正是 Scrum 核心概念的建模落地之处。在这里，你可以找到`Product`、`BacklogItem`、`Release`和`Sprint`这些`Aggregates`。在 [Aggregates (10)](../ch10/0.md) 章节中，你会了解到为何这些概念会被建模为相互独立的`Aggregates`。

---

| ||
|---|---|
|团队很喜欢这些模块依据`Ubiquitous Language`呈现出的自然可读性：`product`，`product backlog item`，`product release`和`product sprint`。|<img src="../img/cbl.2.png" width="50%"/>|

既然只有四个联系紧密的`Aggregates`，数量如此之少，团队为何没有将它们全部放在`product`模块中呢？需要说明的是，这里并未展示每个`Aggregate`包含的所有其他组成部分——比如`Product`包含的`ProductBacklogItem Entity`、`BacklogItem`包含的`Task Entity`、`Release`包含的`ScheduledBacklogItem`，以及`Sprint`包含的`CommittedBacklogItem`。此外，每种`Aggregate`类型还包含其他一些`Entities`和`Value Objects`，部分`Aggregates`还会发布不少`Domain Events`。总而言之，将近 60 个类和接口放在单个模块中，会让该模块变得十分臃肿繁杂，给人一种明显缺乏条理的印象。因此，团队优先考虑了模块的条理性，而非跨模块耦合的相关顾虑。

---




#### ▶[下一节](5.md)
