## 基于模块进行设计

#### ▶[上一节](0.md)

在 DDD 的语境中，模型中的模块是具有名称的容器，用于存放彼此高度内聚的领域对象类。我们的目标应当是实现不同模块中的类之间的低耦合。由于 DDD 中所使用的模块并非平淡无奇或通用的存储容器，因此为模块进行恰当命名也同样重要。模块的名称是`Ubiquitous Language`的一个重要组成部分。

- 选择那些能够讲述系统故事、且包含一组内聚概念的模块。这通常能实现模块间的低耦合，但若未能达到这一效果，则需寻找修改模型的方法，以梳理清楚这些概念之间的关联……给模块赋予能够成为`Ubiquitous Language`一部分的名称。模块及其名称应体现出对领域的深刻理解。[[Evans, pp. 110, 111](../bibli.md#evans)]

正如 [表 9.1](#table-91) 中所指出的，设计模块时需要牢记几条简单的规则。

#### Table 9.1


|模块设计的应做与不应做|理由|
|---|---|
|应设计贴合建模概念的模块。|通常情况下，你会为一个或几个内聚的 [Aggregates (10)](../ch10/0.md) 创建一个模块，即便这种内聚性仅通过引用关系实现。|
|应依据`Ubiquitous Language`为模块命名。|这是 DDD 的一个基本目标，而且如果你围绕待建模的概念进行思考，这一点也往往会自然而然地达成。|
|不应按照模型中使用的通用组件类型或模式机械地创建模块。|例如，倘若我们将所有`Aggregates`都归到一个模块，所有 [Services (7)](../ch7/0.md ) 归到另一个模块，所有 [Factories (11)](../ch11/0.md) 又归到第三个模块，我们的模型将无法获得任何益处。这既违背了 DDD 模块的初衷，还可能限制你进行丰富建模的创造性。你将不再以开放的思维去思考领域本身，而只会局限于思考自己用于解决当前问题的组件类型或模式。|
|应设计低耦合的模块。|确保模块在很大程度上独立于其他模块，所带来的益处与实现低耦合类是相同的。这将使你更容易维护和重构建模概念，也更便于使用粗粒度的模块化工具，例如 OSGi 和 Jigsaw。|
|在必须存在耦合的情况下，应力求同级模块之间不存在循环依赖。（同级模块指处于同一 “层级”，或在设计中具有同等重要性与影响力的模块。）|模块之间完全相互独立，这种情况几乎不可能实现，甚至也不具备实际可行性。毕竟，领域模型本身就意味着存在一定的耦合性。不过，如果你着力将两个同级模块之间的依赖关系设计为单向依赖（例如，产品模块依赖团队模块，而团队模块不依赖产品模块），就能降低组件间的耦合程度。|
|在父子模块之间，可适当放宽规则。（父模块处于更高层级，子模块比其父模块低一个层级，例如父模块。子模块的形式。）|要防止父模块与子模块之间产生依赖，实际上是非常困难的。如果有可能，仍应努力实现父子模块间的无环依赖；但如果实在无法避免，也可允许循环依赖的存在（例如，父模块创建子模块，而子模块必须引用其父模块，即便这种引用仅通过标识实现）。|
|不应将模块视为模型的静态概念，而应允许它们随其所组织的对象一同被塑造调整。|如果模型中的概念具有可塑性，并且会随着时间的推移呈现出不同的形态、行为和名称，那么组织这些概念的模块，很可能也应当相应地被创建、重命名和删除。这并非必须，但如果你发现名称不匹配，就进行重构。诚然，这可能会很麻烦，但这种麻烦很可能小于使用命名不当的模块所带来的困扰。|

*模块设计的简单规则*

将模块视为模型中的一等公民，并努力赋予其与 [Entities (5)](../ch5/0.md) 、[Value Objects (6)](../ch6/0.md)、`Services`和 [Events (8)](../ch8/0.md) 同等程度的含义考量与命名考量。这意味着要有足够的魄力，以创建新模块时同样的果敢，去重命名已有的模块。始终根据当下的认知，果断地将全新的、更新后的领域概念放入合适的模块中。

我们没有人会愿意在自家厨房打开一个抽屉，却发现里面杂乱地混放着餐叉、餐刀、勺子、扳手、螺丝刀、套筒和锤子。即便能凑齐一整套餐具，我们至少也会不愿意用这些金属餐具进餐。我们可能会避免在这个杂乱的抽屉里翻找某一把特定的螺丝刀，因为害怕被一把没注意到的屠宰刀划伤。

与之形成对比的是，厨房抽屉里的餐具被整齐地归为餐叉、餐刀和勺子各一组，车库里的工具箱中，每一类工具也都有各自整理妥当的收纳格。我们能毫不费力地找到特定用途所需的物品，也不会对将其用于既定用途而感到迟疑。一切都井然有序，整洁清爽。
有了这种模块化的组织方式，没人会指望在放着餐具的抽屉里找到杯子和茶碟，尽管它们都属于厨房。整齐堆放的餐具会让我们认为杯子和茶碟有它们自己的合适位置。稍微快速地看看附近那些显眼的柜子，它们就会在那里。同样，我们也会期望在一个能保护刀刃并保护使用者的地方找到锋利的餐具。

另一方面，我们大概不会用机械的方式来整理厨房物品，比如把所有坚固的东西放在一个抽屉里，把所有可能易碎的东西放在高处的橱柜中。我们不会仅仅因为花瓶和精致的茶杯都有些易碎，就非得把它们放在一起收纳。我们也不会仅仅因为不锈钢松肉锤和精致餐具都不容易被其他坚固物品损坏，就把它们归置在一处。

如果我们对厨房进行建模，看到一个名为「餐具组」的模块是非常自然的，在其中我们会看到餐叉、勺子和餐刀这类对象。我们甚至可能决定将餐巾也放在这个模块里，这表明并非只有金属材质的对象才能归入「餐具组」模块。另一方面，如果我们分别创建名为「带叉齿的」「可舀取的」和「钝头的」这样的模块，对于餐具组的建模则毫无助益。

请注意，软件模块化领域的最新进展带来了不同层次的软件模块化。这种方法旨在将低耦合但逻辑内聚的软件片段，按版本打包为一个部署单元。在 Java 生态系统中，我们仍会从 JAR 文件的角度进行考量，只是如今会通过版本对其进行组装，例如使用 OSGi bundles 或 Java 8 的 Jigsaw 模块。因此，各类高层级模块、其版本及其依赖项均可作为 bundle/modules 进行管理。
这类 modules/bundle 与 DDD 中的模块略有不同，但二者可以相互补充。当然，依据 DDD 的模块划分，将领域模型中低耦合的部分打包为更粗粒度的模块是合理的。毕竟，正是 DDD 模块的低耦合设计，使得你能够借助 OSGi 进行打包，或是基于 Jigsaw 实现模块化。

|牛仔逻辑||
|---|---|
|LB：“你肯定会好奇这家加油站的洗手间怎么能保持得这么整洁干净。”</br> AJ：“得了吧，LB，就算龙卷风刮进这个洗手间，都能给它带来价值一万美元的改善。” |<img src="../img/cbl.1.png" width="50%"/>|

我们将重点探讨 DDD 模块的使用方式。围绕模型中特定`Entities`、`Value Objects`、`Services`和`Events`的 *用途* 进行思考，这对模块设计大有裨益。接下来，我们来看几个经过深思熟虑的模块设计示例。

#### ▶[下一节](2.md)
