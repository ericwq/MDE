## 如何实践 DDD

#### ▶[上一节](2.md)

让我们暂时搁置繁重的实现讨论，聚焦 DDD 最具赋能性的特性之一，`Ubiquitous Language`。这是支撑 DDD 核心优势的两大支柱之一，另一支柱则是 [Bounded Context (2)](../ch2/0.md) ，二者缺一不可。

---
➜**上下文中的术语**

目前可将`Bounded Context`视为围绕整个应用程序或有限系统设置的概念边界。设置此边界的目的是强调：在边界内使用特定领域术语、短语或句子（即`Ubiquitous Language`）时，其含义具有特定的上下文背景。若在边界外使用相同术语，则可能产生不同含义。[第 2 章](../ch2/0.md) 将深入阐述`Bounded Context`的概念。

---

### Ubiquitous Language

`Ubiquitous Language`是团队共享的语言。领域专家和开发人员共同使用它。事实上，项目团队中的每个人都使用它。无论你在团队中担任何种角色，只要你属于这个团队，就必然使用项目的`Ubiquitous Language`。


---
➜**所以，你以为自己知道什么是`Ubiquitous Language`？**

*显然，它应该是商业语言。*

不，并非如此。

*它肯定采用了行业标准术语。*

不，其实不然。

*显然这是领域专家使用的行话。*

抱歉，并非如此。

*`Ubiquitous Language`是由团队共同开发的共享语言 —— 这个团队由领域专家和软件开发人员共同组成。*

就是这样。现在你明白了！

当然，领域专家对语言的影响力很大，因为他们最了解业务的这一部分，且可能受行业标准影响。然而，该语言更侧重于业务本身的思维方式和运作模式。此外，领域专家们常常在概念和术语上存在分歧，有时甚至会出现错误，因为他们未能预见到所有可能的情况。因此，当专家与开发者协作构建领域模型时，他们通过兼顾共识与妥协的讨论，为项目打造最优语言体系。团队绝不妥协语言质量，仅在最佳概念、术语及含义上作出权衡。但初始共识并非终点。如同任何活语言，随着大大小小的突破不断涌现，该语言体系将持续演进与变革。

---

这绝非让开发人员与领域专家达成共识的花招，也并非强加给开发人员的商业术语堆砌。这是由整个团队共同创造的真实语言 —— 领域专家、开发人员、业务分析师以及所有参与系统构建的人员。该语言最初可能采用领域专家惯用的术语，但绝不限于此，因为语言必须随着时间推移而发展。值得一提的是，当多位领域专家共同构建该语言时，他们常会对某些自认为已成共识的术语含义产生细微分歧。

在 [表 1.4](#table-14) 中，我们不仅用代码建模了流感疫苗的接种流程，团队还必须公开使用该语言进行交流。当团队讨论模型这一部分时，他们会直接使用诸如 “护士按标准剂量为患者接种流感疫苗” 等表述。

围绕专家心中既有的语言体系及其衍生形态，必然会出现讨价还价与争论不休的局面。这一切都是发展最佳语言的自然进程，这种语言将在未来漫长岁月里发挥重要作用。这一进程通过开放讨论、审视现有文档、发掘最终浮出水面的行业隐性知识，以及参考标准、词典和词库来实现。我们终将接受这样一个事实：某些词汇和短语并不像我们曾经认为的那样契合业务语境，而另一些词汇则更具适配性。

#### Table 1.4
|<p align="left">哪种方案更适合业务需求？</br> 尽管第二和第三种表述相似，代码设计应如何选择？</p>||
|---|---|
|**可能的观点：**|**结果代码**|
|*“谁在乎？直接写代码就行。”*</br> 嗯，差得远了。|patient.setShotType(ShotTypes.TYPE_FLU);</br> patient.setDose(dose);</br> patient.setNurse(nurse);|
|*“我们为患者提供流感疫苗接种。”*</br> 更好，但遗漏了关键概念。|patient.giveFluShot();|
|*“护士按标准剂量为患者注射流感疫苗。”*</br> 这似乎是我们当前最理想的方案，至少在掌握更多信息前如此。|Vaccine vaccine = vaccines.standardAdultFluDose();</br> nurse.administerFluVaccine(patient, vaccine);|

*分析适合业务的最佳模型*

<ins>那么，如何捕捉这种至关重要的`Ubiquitous Language`呢？以下是一些行之有效的方法，实验推动进步：</ins>

- 绘制物理领域和概念领域的图示，并标注名称与操作。这些图示大多非正式，但可能包含某些正式软件建模的要素。即使团队采用统一建模语言（UML）进行正式建模，也应避免任何可能拖慢讨论节奏、扼杀最终目标语言创造力的繁文缛节。

- 创建术语表并附简明定义。列出替代术语，包括有前景的和未被采纳的术语及其原因。在添加定义的过程中，你将不可避免地为该语言开发可复用短语，因为你被迫使用领域语言进行书写。

- 若您不喜欢术语表的形式，仍需记录某种文档，其中包含重要软件概念的非正式草图。同样，此处的目标是促使更多语言术语和短语浮现出来。

- 由于可能只有一两名团队成员负责整理术语表或其他书面文件，请务必与其余成员反复核对最终形成的表述。团队成员对所有语言表述达成完全一致的情况实属罕见，因此请保持灵活态度，做好大幅修改的准备。

这些是构造适合特定领域的`Ubiquitous Language`的理想初始步骤。然而，这绝非你正在开发的模型。它仅仅是`Ubiquitous Language`的雏形，很快就会在系统的源代码中体现出来。我们讨论的是 Java、C#、Scala 或其他选定的编程语言。这些图纸和文档也未能体现`Ubiquitous Language`将持续演进的特性。最初引领我们踏上开发实用通用语言征程的成果，那些完美契合特定领域的初始成果，很可能在时间长河中逐渐过时。 *这就是为什么最终团队的言语和代码中的模型是最持久的，也是对`Ubiquitous Language`唯一有保证的当前表达方式。* 。

<ins>由于团队语言和代码将成为`Ubiquitous Language`的持久载体，请做好放弃图纸、术语表及其他文档的准备，随着口头`Ubiquitous Language`和源代码的快速迭代，这些文档将难以保持同步。这并非 DDD 的强制要求，但出于实用考量，因为让所有文档与系统保持同步实属不切实际。</ins>

基于此认知，我们可以重构`saveCustomer()`示例。若选择让`Customer`类映射其必须支持的每个潜在业务目标，会怎样？

```Java
public interface Customer {
    public void changePersonalName(
        String firstName, String lastName);
    public void postalAddress(PostalAddress postalAddress);
    public void relocateTo(PostalAddress changedPostalAddress);
    public void changeHomeTelephone(Telephone telephone);
    public void disconnectHomeTelephone();
    public void changeMobileTelephone(Telephone telephone);
    public void disconnectMobileTelephone();
    public void primaryEmailAddress(EmailAddress emailAddress);
    public void secondaryEmailAddress(EmailAddress emailAddress);
}
```

我们可以争论这并非`Customer`的最佳模型，但在实施 DDD 时，质疑设计本就是常态。作为团队，我们有权就最佳模型展开讨论，只有在达成共识的`Ubiquitous Language`确立后才最终定案。尽管如此，前述接口仍明确体现了`Customer`必须支持的各项业务目标，即便`Ubiquitous Language`仍可通过反复打磨不断完善。

同样重要的是，需要理解`Application Service`也将被重构，以反映当前业务目标的明确意图。每个`Application Service`方法都会被修改，以处理单一的用例流程或用户故事：

```Java
@Transactional
public void changeCustomerPersonalName(
    String customerId,
    String customerFirstName,
    String customerLastName) {

    Customer customer = customerRepository.customerOfId(customerId);

    if (customer == null) {
        throw new IllegalStateException("Customer does not exist.");
}
    customer.changePersonalName(customerFirstName, customerLastName);
}
```

这与原始示例不同，因为在该代码中，单个方法用于处理多种不同的用例流程或用户故事。在新示例中，我们限定单个`Application Service`方法仅用于更改`Customer`的个人姓名，除此之外不处理其他操作。因此，在使用 DDD 时，我们需要相应地优化`Application Service`。这意味着用户界面同样应反映更窄的用户目标——这在先前可能已然成立。但现在，这个特定的`Application Service`方法不再要求客户端在姓氏和名字参数之后传递十个空值参数。

这个新设计难道不让人安心吗？你可以轻松阅读代码并理解其含义，还能进行测试来确认它完全符合预期功能，且不会执行任何不该执行的操作。

因此，`Ubiquitous Language`是一种团队模式，用于在软件模型本身中捕捉特定核心业务领域的概念和术语。该软件模型正式纳入了紧密协作团队所制定和使用的名词、形容词、动词及更丰富的表达方式。无论是软件本身，还是验证模型的测试都遵循领域原则，捕捉并遵循着这种语言，即团队所使用的语言。

无处不在，但非无所不包
关于通用语言的覆盖范围，有必要进一步澄清。我们需要牢记几个基本概念：

### 无处不在，但非普遍 (Universal)

关于`Ubiquitous Language`的覆盖范围，有必要进一步澄清。我们需要牢记几个基本概念：

- “无处不在” 意指 “弥漫的 (pervasive)” 或 “遍布各处”，这是团队内部的常用表述，也体现于团队开发的单一领域模型之中。

- 使用 “无处不在” 一词并非试图描述某种覆盖整个企业、整个公司或全球范围的通用领域语言。

- <ins>每个`Bounded Context`对应一种`Ubiquitous Language`。</ins>

- `Bounded Context`相对较小，比我们最初想象的更小。`Bounded Context`的规模仅需足以涵盖独立业务领域完整的`Ubiquitous Language`，绝不超出此范围。

- 该语言仅在开发独立`Bounded Context`项目的团队内部无处不在。

- 在开发单一`Bounded Context`的项目中，总会存在一个或多个额外的独立`Bounded Context`，它们通过 [Context Maps (3)](../ch3/0.md) 实现集成。每个参与集成的`Bounded Context`都拥有自己的`Ubiquitous Language`，尽管其中某些术语可能存在重叠。

- 若试图将单一`Ubiquitous Language`应用于整个企业，或更糟糕的是在多个企业间普遍推行，终将以失败告终。

当你开始一个新的项目，并且正确使用 DDD 时，识别正在开发的独立`Bounded Context`。这会在你的领域模型周围划定一个明确的边界。在这个明确的`Bounded Context`内，讨论、研究、概念化、开发并使用该独立领域模型的`Ubiquitous Language`。拒绝所有不属于你独立上下文约定的`Ubiquitous Language`的概念。

#### ▶[下一节](4.md)
