## 应用 DDD 的挑战

#### ▶[上一节](4.md)

在实施 DDD 的过程中，您将面临诸多挑战。所有成功实践者都曾经历过这些挑战。面对这些挑战时，常见的障碍有哪些？我们又该如何论证采用 DDD 的合理性？本文将探讨其中较为普遍的挑战：

- 为创建`Ubiquitous Language`预留必要的时间和精力投入
- 从项目初期就引入领域专家并使其全程参与
- 改变开发者在各自领域内思考解决方案的方式

使用 DDD 面临的最大挑战之一，在于需要投入大量时间和精力去思考业务领域、研究概念术语，并与领域专家交流沟通，从而发现、捕捉并完善`Ubiquitous Language`，而非沉溺于技术术语的编码。若想完整践行 DDD 并为业务创造最大价值，必然需要投入更多思考与精力，耗费更长时间。这就是现实，毋庸置疑。

从领域专家那里获得必要的参与也可能是一个挑战。无论多困难，都要确保做到。如果你至少没有得到一位真正专家的承诺，你就无法挖掘出该领域的深层知识。当你确实获得了领域专家的参与时，责任就回到了开发人员身上。开发人员必须与真正的专家交流并仔细倾听，将他们的语言转化为反映其领域思维模型的软件。

若您所处的领域对业务具有核心价值，那么领域专家的头脑中往往蕴藏着关键知识，您需要设法将其挖掘出来。我参与过不少项目，真正的领域专家却鲜少现身。他们常年奔波在外，有时与他们进行一小时会议的间隔竟达数周之久。在小型企业中，这类专家可能是 CEO 或某位副总裁，而他们手头还有诸多看似更重要的事务要处理。

|牛仔逻辑||
|---|---|
|AJ：“要是抓不住那头大公牛，你就得挨饿了。”|<img src="../img/cbl.2.png" width="50%"/>|

要让领域专家参与进来，可能需要发挥创造力……

---

|<p align="left">如何让领域专家参与你的项目</p>||
|---|---|
|咖啡。使用这种无处不在的语言：</br> “嗨，莎莉，我给你买了杯特大杯半脱脂半 1% 脂肪超热四倍浓缩拿铁配奶油。你有几分钟聊聊……吗？”</br> 学会使用 C 级经理的`Ubiquitous Language`：“……利润……营收……竞争优势……市场主导地位。” 说真的。</br> 冰球门票。|<img src="../img/tips.1.png" width="50%"/>|

---

大多数开发者都不得不 *改变思维方式* 才能正确应用 DDD 。我们开发者是技术思维者，技术解决方案对我们而言信手拈来。这并非否定技术思维的价值，而是某些情境下更需要跳出技术框架思考。若多年来我们始终习惯以技术手段实践软件开发，或许现在正是转变思维模式的良机。而构建领域`Ubiquitous Language`，正是开启这种转变的最佳起点。

|牛仔逻辑||
|---|---|
|LB：“那家伙的靴子太小了。要是他再不找双合适的，脚趾头可要遭罪了。”</br> AJ：“没错。不听劝告的话，就得亲身体验了。”|<img src="../img/cbl.1.png" width="50%"/>|

DDD 需要超越概念命名的更高层次思考。当我们通过软件建模领域时，必须仔细思考哪些模型对象执行哪些操作，这涉及 *对象行为的设计* 。诚然，我们需要为行为命名以准确传达`Ubiquitous Language`的精髓。但更关键的是要考量对象通过具体行为实现的功能。这种深度思考远非在类中创建属性、向模型客户端公开访问器和设置器所能涵盖。

现在让我们转向一个更有趣的领域，它比之前探讨的初级领域更具挑战性。我特意在此重复之前的指导，以强化这些概念。

那么，如果我们仅为模型提供数据访问器 (accessors) 会怎样？需要再次强调的是，若仅暴露模型对象的数据访问器，其结果将与数据模型极为相似。请审视以下两个示例，自行判断哪个需要更深入的设计考量，哪个能为客户端带来更大效益。该需求基于 Scrum 模型，要求将待办事项 (backlog) 提交至冲刺阶段 (sprint)。这可能是你日常操作的领域，因此应该很熟悉。

第一个示例采用当今常见的属性访问器方式：

```Java
public class BacklogItem extends Entity {
    private SprintId sprintId;
    private BacklogItemStatusType status;
    ...
    public void setSprintId(SprintId sprintId) {
        this.sprintId = sprintId;
    }

    public void setStatus(BacklogItemStatusType status) {
        this.status = status;
    }
    ...
}
```

至于该模型的客户：

```Java
// client commits the backlog item to a sprint
// by setting its sprintId and status
backlogItem.setSprintId(sprintId);
backlogItem.setStatus(BacklogItemStatusType.COMMITTED);
```

第二个示例使用了表达领域`Ubiquitous Language`的领域对象行为：

```Java
public class BacklogItem extends Entity {
    private SprintId sprintId;
    private BacklogItemStatusType status;
    ...

    public void commitTo(Sprint aSprint) {
        if (!this.isScheduledForRelease()) {
            throw new IllegalStateException(
                "Must be scheduled for release to commit to sprint.");
        }

        if (this.isCommittedToSprint()) {
            if (!aSprint.sprintId().equals(this.sprintId())) {
                this.uncommitFromSprint();
            }
        }

this.elevateStatusWith(BacklogItemStatus.COMMITTED);

        this.setSprintId(aSprint.sprintId());

        DomainEventPublisher
            .instance()
            .publish(new BacklogItemCommitted(
                this.tenant(),
                this.backlogItemId(),
                this.sprintId()));
    }
    ...
}
```

这个显性模型的客户似乎在更安全的基础上运作：

```Java
// client commits the backlog item to a sprint
// by using a domain-specific behavior
backlogItem.commitTo(sprint);
```

第一个例子使用了非常以数据为中心的方法。全部责任都在客户端，客户端必须知道如何将待办事项正确提交到一个冲刺。这个模型，实际上并不是真正的领域模型，根本没有任何帮助。如果客户端错误地只更改了`sprintId`，但没有更改`status`，或者相反呢？或者如果将来必须设置另一个属性呢？客户端代码必须被分析，以确保数据值正确映射到`BacklogItem`的相应属性上。

这种方法还暴露了`BacklogItem`对象的结构，明确将关注点集中在其数据属性而非行为上。即使你认为`setSprintId()`和`setStatus()`属于行为，关键在于这些 “行为” 并无实际业务价值。这些 “行为” 并未明确体现领域软件应建模的场景意图，即将待办事项投入冲刺。当客户端开发者试图在`BacklogItem`属性中筛选投入冲刺所需项时，确实会引发认知负荷。由于采用以数据为中心的模型，这类属性可能数量庞杂。

现在考虑第二个示例。它没有将数据属性暴露给客户端，而是暴露了一种行为，该行为明确清晰地表明客户端可以将待办事项提交到冲刺中。该领域的专家们讨论了该模型的以下要求：

- 允许每个待办事项提交至冲刺。仅当该事项已排入发布计划时方可提交。若该事项已提交至其他冲刺，则必须先取消提交。提交完成后，通知相关方。

因此，第二个示例中的方法在上下文中捕获了模型的`Ubiquitous Language`，即`BacklogItem`类型被隔离的`Bounded Context`。通过分析此场景，我们发现第一个解决方案存在缺陷且包含错误。

在第二种实现中，客户端无需了解提交操作所需的具体条件，无论操作简单还是复杂。该方法的实现逻辑可多可少，完全根据需求而定。我们轻松添加了保护机制，防止提交尚未排入发布计划的待办事项。诚然，第一种实现方式也可在设置器内部添加保护逻辑，但此时设置器需承担理解对象完整状态上下文的责任，而不仅限于处理`sprintId`和`status`的条件。

这里还存在另一个微妙的差异。请注意，若待办事项已提交至其他冲刺，系统将首先将其从当前冲刺中取消提交。这一细节至关重要，因为当待办事项从冲刺中取消提交时，需向客户端发布`Domain Event`：

- 允许每个待办事项从冲刺中取消提交。当待办事项被取消提交时，通知相关方。

通过使用领域行为`uncommitFrom()`就可以免费获得未提交通知的发布。方法`commitTo()`甚至不需要知道它会发送通知。它只需要知道在提交到新的迭代之前必须从任何当前的迭代中取消提交。此外，`commitTo()`领域行为的最后一步也会通过事件通知相关方。如果不将这种丰富的行为放在`BacklogItem`中，我们就不得不从客户端发布事件。这肯定会泄露模型中的领域逻辑。这是不可取的。

显然，创建第二个示例的待办事项比第一个需要更多的思考。然而，所需的思考并不是多得惊人，而收益却高得多。我们越是学会以这种方式进行设计，就会变得越容易。最终，确实需要更多的思考、更多的努力、更多的团队协作和协调，但并不会使 DDD 变得沉重。新的思考非常值得付出努力。

---
**白板时间**

- 基于你当前所处的具体领域，思考该模型的常用术语和操作动作。
- 将术语写在白板上。
- 接着，写下团队在讨论项目时应使用的短语。
- 与真正的领域专家讨论这些内容，探讨如何优化（记得带上咖啡）。

---

### 领域建模的合理性论证

*战术建模* 通常比 *战略建模* 更为复杂。因此，若计划采用 DDD 战术模式（`Aggregates`、`Services`、`Value Objects`、`Event`等）开发领域模型，则需投入更多审慎思考与资源投入。鉴于此，组织应如何论证战术领域建模的合理性？哪些标准能证明某个项目值得额外投入，以确保从上到下正确应用 DDD？

想象你正带领一支远征队穿越陌生领地。你需要了解周边的地形与边界。你的团队会研究地图，甚至绘制自己的地图，并制定战略方针。你会考量地形的各个方面，思考如何将其转化为优势。无论计划多么周密，此类行动的某些环节终究会异常艰难。

若你的策略显示需要攀登垂直岩壁，就必须配备相应的战术工具和攀登技巧。站在岩底仰望时，或许能察觉某些特定挑战和危险区域的迹象，但除非亲临岩壁，否则无法看清所有细节。你可能需要将岩钉钉入光滑岩壁，也可利用不同尺寸的岩塞卡入天然裂缝。为固定这些攀登保护装置，你需携带登山扣。虽力求路线尽可能笔直，但每个支点都需精准判断。有时甚至要根据岩壁状况折返改道。许多人视攀岩为危险刺激的运动，但真正攀登者会告诉你它比驾车或飞行更安全。显然，要实现这种安全性，攀岩者必须精通装备技巧并懂得判断岩壁特性。

若开发某个 [Subdomain (2)](../ch2/0.md) 需要如此艰难甚至危险的攀登，我们便会携 DDD 战术模式一同登攀。符合`Core Domain`标准的业务举措不应轻易放弃战术模式的应用。`Core Domain`是未知且复杂的疆域，唯有采用正确战术，团队才能最大程度规避资产中途坠毁的灾难性风险。

以下提供若干实践指南，我将从宏观层面逐步深入细节：

- 若将`Bounded Context`作为`Core Domain`进行开发，其对业务成功具有战略性重要意义。核心模型尚未被充分理解，需要大量实验和重构。它值得投入长期精力进行持续优化。它未必永远是你的`Core Domain`。然而，如果`Bounded Context`复杂、具有创新性且需要在经历变革时长期稳定运行，请务必考虑采用战术模式作为对业务未来的投资。这意味着你的`Core Domain`值得配备最高技能水平的开发资源。

- 一个可能成为 [Generic Subdomain (2)](../ch2/0.md) 或`Supporting Subdomain`的领域，对消费者而言，实际上可能是你业务的`Core Domain`。你不必总是从最终消费者的角度来评判一个领域。如果你正在开发一个`Bounded Context`作为你的主要业务举措，那么无论外部客户如何看待它，它都是你的`Core Domain`。请认真考虑使用战术模式。

- 若您正在开发某个`Supporting Subdomain`，且因种种原因无法将其作为第三方`Generic Subdomain`进行获取，那么战术模式或许能为您的工作提供助力。此时需考量团队的技术水平，以及该模型是否具备创新性。若其能创造特定商业价值、捕捉特殊知识，而非仅具技术吸引力，则可视为创新。若团队能妥善运用战术设计，且该`Supporting Subdomain`具备创新性并需长期支撑未来发展，则值得通过战术设计对软件进行投资。但需注意：该模型仍不属于`Core Domain`范畴，因其在业务视角中仅属辅助性质。

若贵公司拥有众多经验丰富且对领域建模驾轻就熟的开发人员，这些指南可能略显局限。当团队经验极为丰富，且工程师们认为战术模式是最佳选择时，信任他们的判断是明智之举。诚实的开发者无论资历深浅，都会在具体场景中明确指出：构建领域模型是否为最佳选择。

业务领域类型本身并非决定开发方法的唯一因素。团队应综合考量关键问题以做出最终决策。以下是更详细的决策参数清单，这些参数基本遵循并扩展了前文所述的高层级指导原则：

- 是否具备领域专家资源，且您是否承诺围绕这些专家组建团队？

- 尽管当前业务领域相对简单，但未来是否会逐渐复杂化？使用`Transaction Script` <sup>[1](#1)</sup> 处理复杂应用存在风险。若当前采用`Transaction Script`，当上下文变得复杂时，后续重构为行为领域模型的可行性如何？

- 采用 DDD 战术模式是否能更轻松、更切实地实现与其他`Bounded Context`（无论是第三方还是自研系统）的集成？

- 使用`Transaction Script`真的能让开发更简单、代码更少吗？（实践证明，`Transaction Script`往往需要同样甚至更多的代码量。这很可能是因为项目规划阶段未能充分理解领域复杂性和模型创新性。低估领域复杂性和创新性是常见现象。）

- 关键路径和时间线是否为战术投资所需的冗余留有余地？

- `Core Domain`中的战术投资能否保护系统免受架构变更的影响？`Transaction Script`可能使其暴露于风险中。（领域模型通常具有持久性，而架构影响往往更易对其他层造成破坏性。）

- 客户是否能从更简洁、持久的设计与开发方法中获益？还是他们的应用程序明天就会被现成的解决方案取代？换言之，我们为何要从一开始就将其开发为定制应用程序/服务？

- 采用战术性 DDD 开发应用程序/服务，是否比使用`Transaction Script`等其他方法更困难？（领域专家的技能水平和可用性是解答此问题的关键。）

- 如果团队工具箱已配备 DDD 实现工具，我们还会自觉选择其他方法吗？（某些工具能使模型持久化成为可能，例如使用对象关系映射、完整的`Aggregates`序列化和持久化、`Event Store`，或支持战术性 DDD 的框架。可能还存在其他实现工具。）

此清单并非针对贵领域制定的优先级排序，您可能需要补充更多评估标准。您深知必须运用最优且最具赋能性的方法来创造价值，也清楚自身业务与技术环境的特点。最终需要取悦的是商业客户，而非工具实践者和技术专家。请明智抉择。

### DDD 并不沉重

我绝非暗示正确实践 DDD 会导致流程繁琐、仪式感十足，还得维护大量陈旧的文档产物。这绝非 DDD 的本意。它旨在完美融入团队希望采用的任何敏捷项目框架，例如 Scrum。其设计理念更倾向于通过快速的测试驱动迭代来精炼真实的软件模型。当需要开发新的领域对象（如`Entity`或`Value Object`）时，测试驱动方法的实践流程如下：

1. 编写一个测试，演示新的领域对象应如何被领域模型的客户端使用。
2. 创建新的领域对象，并编写足够的代码以使测试能够编译通过。
3. 重构二者，直到测试正确地表示客户端如何使用领域对象，并且领域对象具有适当的行为方法签名。
4. 实现每个领域对象的行为，直到测试通过，同时重构领域对象，直至不存在不合适的代码重复。
5. 向团队成员（包括领域专家）展示代码，以确保测试使用领域对象的方式符合当前`Ubiquitous Language`的意义。

你可能会认为这与你已实践的测试驱动开发并无二致。诚然略有不同，但本质上仍是相同理念。此阶段的测试并非要绝对证明模型无懈可击。后续环节将通过测试实现这一目标。当前重点在于聚焦客户端对模型的使用方式，这些测试将驱动模型设计。好消息是这确实是敏捷方法。DDD 提倡轻量级开发，而非繁文缛节的前置设计。从这个角度看，它与常见的敏捷开发并无二致。因此，尽管前文步骤可能未能让你领悟敏捷精髓，但我认为它们阐明了 DDD 的定位，它本就该以敏捷方式实践。

随后你还需添加测试，从所有可能（且实际）的角度验证新领域对象的正确性。此时你关注的是新领域对象所体现的领域概念表达是否正确。阅读示范性客户端测试代码时，必须能体现`Ubiquitous Language`的恰当表达力。非技术背景的领域专家在开发人员协助下，应能通过代码清晰感知模型是否达成团队目标。这意味着测试数据必须真实可信，既要支撑又要强化所需的表达力。否则领域专家将无法对实现方案作出完整判断。

这种测试优先的敏捷方法论将持续迭代，直至构建出符合当前迭代任务要求的运行模型。前述步骤体现了敏捷特性，正是极限编程最初倡导的核心理念。采用敏捷方法并不意味着舍弃任何关键的 DDD 模式与实践，二者实则相辅相成。当然，您也可以选择不采用测试优先开发，直接实施完整的 DDD。您始终可以针对现有模型对象编写测试。然而，从模型客户视角出发的设计能增添极具价值的维度。

#### ▶[下一节](6.md)

---
#### 1
此处我对术语进行了概括化处理。在本列表中，我使用`Transaction Script`来代表若干非领域模型方法。
