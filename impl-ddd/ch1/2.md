## 为何要采用 DDD

#### ▶[上一节](1.md)

其实，我已经给出了不少相当充分的理由，说明 DDD 为何如此具有实践价值。尽管有违 DRY 原则（“不要重复自己”），我仍要在此重申这些理由，并补充先前未提及的观点。有人听到回声了吗？

- 让领域专家与开发者站在同一起跑线上，这样生成的软件不仅让程序员理解，更能让业务方完全认同。这并非仅仅容忍对方群体，而是要成为一个凝聚力强、紧密协作的团队。
- “符合业务需求”的本质在于：通过打造最贴近业务领导者与专家设想的软件（假设他们亲自编程时会如何设计），实现对业务的实质性投入。
- 你实际上能让企业更深入地了解自身。没有任何领域专家、高管或任何人能完全掌握业务的方方面面。这是一个持续探索的过程，随着时间推移会带来更深刻的洞察。通过 DDD，每个人都能参与探索讨论，从而实现共同学习。
- 知识集中化至关重要，因为这能确保企业避免将软件理解锁定在 “部落知识” 中，这种知识通常仅限于少数人掌握，而这些人往往只有开发人员。
- 领域专家、软件开发人员与软件之间不存在任何翻译障碍。这并非指偶尔需要少量翻译，而是完全消除翻译需求，因为团队已建立起共同的语言体系，每位成员都能流畅沟通。
- 设计即代码，代码即设计。设计就是运作方式。通过敏捷探索流程快速构建实验模型，方能洞悉最佳代码设计方案。
- DDD 提供成熟的软件开发技术，同时涵盖战略设计与战术设计。战略设计帮助我们明确最重要的软件投资方向，确定如何利用现有软件资产以最快捷、最安全的方式达成目标，并界定必须参与的团队成员。战术设计则借助久经考验的软件构建模块，帮助我们打造出解决方案的优雅统一模型。

如同任何优质的高回报投资，DDD 对团队而言也需要前期投入时间和精力。考虑到软件开发过程中普遍存在的挑战，这更凸显了采用健全软件开发方法的必要性。

### 创造商业价值并非易事

开发真正创造商业价值的软件，与开发普通商业软件截然不同。真正创造商业价值的软件需与企业战略目标保持一致，并提供具有明确竞争优势的解决方案 —— 这类软件的核心在于商业价值而非技术本身。

业务知识从不集中化。开发团队必须在多方利益相关者的需求与诉求间权衡取舍，协调具备多元技能的人才协作，共同挖掘软件的功能性与非功能性需求。在收集所有信息后，团队如何确保任何特定需求都能创造真正的商业价值？事实上，究竟该追求哪些商业价值？又该如何发掘、排序并实现这些价值？

商业软件开发过程中最严重的脱节现象之一，体现在领域专家与软件开发人员之间的鸿沟。通常而言，真正的领域专家专注于创造商业价值；而软件开发人员则往往倾向于通过技术手段解决业务问题。这并非开发者动机有误，而是其关注点使然。即便开发者与领域专家开展合作，协作往往停留在表面层面，最终产出的软件常沦为商业思维与运作模式与开发者解读之间的转换映射。最终产出的软件通常未能准确体现领域专家的思维模型，或仅实现部分映射。这种认知断层随时间推移将造成巨大成本。当开发者转入其他项目或离职时，领域知识向软件的转化成果便随之流失。

另一个不同但相关的问题是，当一位或多位领域专家意见不一致时。这种情况往往源于每位专家在建模的特定领域中经验深浅不一，或是他们本身属于相关但不同的专业领域。更常见的是，多名 “领域专家” 实则缺乏特定领域的专业知识，他们更像是业务分析师，却被期望为讨论提供深刻的指导方向。若放任这种情况发展，将导致思维模型模糊不清而非清晰明了，最终形成相互冲突的软件模型。

更糟糕的是，当软件开发的技术方法错误地改变了企业的运作方式时。虽然情境不同，但众所周知，企业资源规划（ERP）软件往往会改变组织的整体业务运营，以适应 ERP 的功能运作。ERP 的总拥有成本无法仅通过许可证和维护费用来完全计算。业务重组和运营中断造成的损失，可能远高于这两项有形成本。当软件开发团队将业务需求转化为新软件的实际功能时，类似的动态也在发生。这不仅会给企业、客户和合作伙伴带来高昂成本和运营干扰，而且这种技术解读本可通过成熟的软件开发技术避免。解决方案是关键投资。

### DDD如何助力

DDD是一种软件开发方法论，专注于以下三个核心方面：

- DDD 将领域专家与软件开发人员凝聚在一起，旨在开发出能准确反映业务专家思维模式的软件。这并非意味着要耗费精力去建模 “真实世界”，而是致力于构建对业务最具价值的模型。有时实用模型与现实模型会不期而遇，但在两者产生分歧时，DDD 始终选择实用性。

  在此方面，领域专家与软件开发人员共同致力于为其专注建模的业务领域开发通用语言。`Ubiquitous Language`需经全团队共识形成，通过口头表达传递，并直接融入软件模型。值得重申的是，团队由领域专家与软件开发人员共同组成，绝非 “我们和他们” 的对立关系。始终是我们。这正是核心商业价值所在——它使业务知识得以超越初始开发阶段的短暂生命周期，不仅延续至软件前几版的交付周期，更超越了开发团队的更替。正是在这个节点上，软件开发成本才成为合理的商业投资，而非单纯的成本中心。

  这项工作使最初意见相左或缺乏领域核心知识的专家达成共识。更重要的是，它通过向所有团队成员（包括软件开发人员）传播深厚的领域洞察力，强化了团队的凝聚力。这堪称企业为知识工作者投入的必备实践培训。

- DDD 致力于解决业务层面的战略举措。这种战略设计方法虽自然包含技术分析，但更关注业务的战略方向。它有助于定义最佳的跨团队组织关系，并提供预警系统以识别特定关系可能导致软件甚至项目失败的风险。战略设计的技术层面旨在清晰划分系统边界与业务关注点，从而保护每个 *业务级服务* 。这为实现整体 *面向服务的架构* 或 *业务驱动架构* 提供了切实可行的动因。

- DDD 通过运用战术设计建模工具来分析和开发可执行的软件交付物，满足软件的实际技术需求。这些战术设计工具使开发人员能够产出符合领域专家思维模式的正确编码软件，该软件具备高度可测试性、低错误率（可证明的特性）、符合服务级别协议（SLA）的性能、可扩展性，并支持分布式计算。DDD 最佳实践通常涵盖十余项高阶架构与低阶软件设计要点，核心在于识别真实业务规则与数据不变性，并保护规则免受错误场景影响。

采用这种软件开发方法，您和您的团队能够成功交付真正的商业价值。

### 应对领域复杂性的挑战

我们主要希望在对业务至关重要的领域应用 DDD 。你不会投资于那些轻易可被替代的事物。 *投资应当投向非平凡的、更复杂的事物，投向最具价值和最重要的领域，那些能带来最大回报的领域* 。因此我们称此类模型为 [Core Domain (2)](ch2/0.md) 。这些核心领域，以及次要的重大 [Supporting Subdomains (2)](ch2/0.md) ，才值得并应当获得最大投入。因此，我们必须准确把握 “复杂” 的真正含义。

---
➜**运用 DDD 来简化，而非复杂化**

运用 DDD 以最简洁的方式建模复杂领域。切勿利用 DDD 使解决方案变得更加复杂。

---

何谓复杂性因企业而异。不同公司面临不同挑战，发展成熟度各异，软件开发能力也存在差异。因此与其定义复杂性，不如界定非平凡性更为可行。由此，团队与管理层需共同评估：拟投入开发的系统是否值得进行 DDD 的成本投入。

**DDD 评分卡**：使用 [表 1.1](#table-11) 判断您的项目是否符合采用 DDD的投资条件。若评分卡中某行描述符合您的项目情况，请在右侧列对应位置填写该项分数。统计项目总分，若达到7分或以上，请认真考虑采用 DDD。

#### Table 1.1
|您的项目总分达到7分或更高吗？||||
|---|---|---|---|
|如果您的项目…… |得分|支持性说明|您的得分|
如果您的应用完全以数据为中心，且真正符合纯 CRUD 解决方案的要求，即每项操作本质上都是创建、读取、更新或删除的简单数据库查询，那么您无需采用 DDD 。团队只需为数据库表编辑器设计一个美观的界面即可。换言之，若能确保用户直接向表中插入数据、更新内容甚至偶尔删除记录，甚至无需用户界面。虽然这种情况不切实际，但概念上具有参考价值。若仅需借助基础数据库开发工具即可实现解决方案，请勿让公司为 DDD 浪费时间和资金。|0|这看似不言而喻，但区分简单与复杂通常并非易事。并非所有非纯 CRUD 的应用都值得投入时间和精力采用 DDD 。因此，或许我们可以制定其他衡量标准，帮助我们划清复杂与非复杂的界限……||
|如果您的系统仅需 30 个或更少的业务操作，那么它很可能相当简单。这意味着您的应用程序总共不会超过 30 个用户故事或用例流程，且每个流程仅包含最基础的业务逻辑。若您能使用 Ruby on Rails 或 Groovy 与 Grails 快速轻松地开发此类应用，且不会因功能不足或难以应对复杂变更而感到困扰，那么您的系统很可能无需采用 DDD 。|1|需要明确的是，我指的是 25 到 30 个独立的业务方法，而非 25 到 30 个完整的服务接口（每个接口包含多个方法）。后者可能较为复杂。||
|那么假设当用户故事数量达到 30 到 40 个左右时，系统复杂度可能开始攀升。此时你的系统或许正步入 DDD 的范畴。|2|买者自慎：很多时候复杂性没有被及时意识到。 *我们软件开发者在低估复杂性和工作量方面真的非常擅长。* 仅仅因为我们可能想编写一个 Rails 或 Grails 应用程序，并不意味着我们应该这样做。从长远来看，这些可能弊大于利。||
|即使当前应用程序并不复杂，它是否会逐渐变得复杂？在实际用户开始使用之前，你可能无法确定这一点，但 “支持性说明” 栏中的某个步骤或许能帮助揭示真实情况。</br>请务必谨慎。若存在任何迹象表明应用程序具有中等复杂度 ——此时保持高度警惕至关重要—— 这可能已足够说明其实际复杂度将远超中等水平。建议倾向于采用 DDD 。|3|在此阶段，与领域专家共同梳理更复杂的使用场景并观察其发展方向将大有裨益。领域专家是否……</br>1. ……已开始要求更复杂的功能？若如此，这很可能表明应用程序已然或即将变得过于复杂，无法采用 CRUD 方法。</br>2. ……对现有功能感到厌倦，甚至不愿讨论？那么复杂性可能并不高。||
|该应用程序的功能将在未来数年内频繁变更，且无法预料这些变更会是简单的类型。|4|DDD 能助您应对模型随时间推移而重构的复杂性。||
|你不理解这个 [Domain (2)](ch2/0.md) 是因为它很新颖。就你和团队所知，此前无人涉足此领域。这很可能意味着它相当复杂，或者至少需要通过分析性审查进行尽职调查，以确定其复杂程度。|5|你需要与领域专家协作并尝试各种模型才能找到正确方案。既然你在前述标准中已满足一项或多项要求，那么请务必采用 DDD 。||

*DDD 评分卡*


这次评分练习可能让团队得出以下结论：

- 遗憾的是，当发现自己陷入复杂性困境时，我们无法迅速轻松地调整方向——无论这种困境比预期更复杂还是更简单。
- 确实如此，但这恰恰说明我们在项目规划初期就必须大幅提升判断简易性与复杂性的能力。这将为我们节省大量时间、成本和麻烦。
- 一旦作出重大架构决策并深入开发多个用例后，我们通常就难以回旋。因此必须审慎抉择。

如果这些观察结果与您的团队产生共鸣，说明您正在有效运用批判性思维。

### 贫血与记忆丧失

贫血是一种严重的健康问题，可能引发危险的副作用。当 “贫血领域模型 (`Anemic Domain Model`)” [\[Fowler, Anemic\]](..//bibli.md#fowler-anemic) 这一术语首次出现时， *绝非褒义* ，它并非暗示缺乏内在行为特性的弱化领域模型可能具有积极意义。令人费解的是，`Anemic Domain Model`在业界已随处可见。问题在于多数开发者似乎认为这种现象理所当然，甚至在系统中采用时也拒绝承认其严重性。这确实是个大问题。

你是否在担心自己的模型是否感到疲惫、无精打采、健忘、笨拙，需要一剂强心针？如果你突然陷入技术疑病症，这里有一个很好的自我检查方法。你将要么安心，要么确认最坏的担忧。请使用 [表 1.2](#table-12) 中的步骤进行检查。

#### Table 1.2
|说明|是/否|
|--|--|
|你所称的 “领域模型” 是否主要由公共的`getter`和`setter`构成，几乎不包含业务逻辑 —— 也就是那些主要充当属性值容器的对象？||
|频繁调用你 “领域模型” 的软件组件是否承载着系统大部分业务逻辑？这些组件是否大量调用 “领域模型” 的公共`getter`和`setter`？你很可能将这种特定的 “领域模型” 客户端层称为 [Service Layer (4)](../ch4/0.md) 或 [Application Layer](../ch14/0.md) 。若此描述对应的是你的用户界面，请回答 “是”，并在白板上写一千遍：永远、永远不要再这么做了。||
|**提示：正确答案要么是两个问题都回答 “是”，要么是两个问题都回答 “否”。**||

*确定您的领域模型健康状况历史*

你做得如何？

- 若两个问题都回答“不”，说明你的领域运作良好。
- 若两个问题都回答“是”，说明你的 “领域模型” 病入膏肓。它已然虚弱不堪。好消息是，继续阅读本文就能获得救治良方。
- 若你对其中一个问题回答 “是”，而另一个问题回答 “否”，那么你要么处于否认状态，要么正遭受妄想或其他可能由贫血引发的神经系统问题困扰。若答案相互矛盾该怎么办？请直接回到第一个问题，重新进行自我检查。请耐心完成，但请记住：两个问题的答案都必须是斩钉截铁的 “是！”

正如 [\[Fowler, Anemic\]](..//bibli.md#fowler-anemic) 所言，贫血领域模型是糟糕的设计，因为你付出了开发领域模型的大部分高昂成本，却几乎得不到任何收益。例如，由于对象关系阻抗失配，此类 “领域模型” 的开发者需耗费大量时间精力在对象与持久化存储之间进行映射。这无疑是付出高昂代价却几乎毫无回报的行为。我还要补充一点：你所谓的领域模型根本不存在，它不过是将关系模型（或其他数据库）投影到对象上的数据模型。这实为冒牌货，其本质或许更接近`Active Record`模式的定义 [\[Fowler, P of EAA\]](../bibli.md#fowler-p-of-eaa) 。若能放下虚饰坦承所用实为`Transaction Script`变体 [\[Fowler, P of EAA\]](../bibli.md#fowler-p-of-eaa) ，反而能简化架构。

### 贫血发生的原因

既然贫血的领域模型是设计执行不善导致的病态产物，为何众多开发者仍将其奉为圭臬，坚信自己的模型健康良好？这固然反映出过程化编程思维的惯性，但我认为并非根本原因。我们行业中有相当一部分人是示例代码的追随者，只要示例代码质量上乘，这本身并非坏事。然而，示例代码往往刻意追求以最简洁的方式展示某个概念或应用程序接口（API）特性，却忽视了良好的设计原则。那些过度简化的示例代码，通常充斥着大量`getter`和`setter`，每天都被照搬使用，而人们对设计本身却毫不思量。

还有另一种更古老的影响。微软 Visual Basic 的悠久历史与我们今日的处境息息相关。我并非认为 Visual Basic 是糟糕的编程语言和集成开发环境（IDE），它始终是高效的生产环境，在某些方面对行业产生了积极影响。当然，有人可能完全避开了它的直接影响，但 Visual Basic 最终几乎间接影响到了每位软件开发者。请参阅 [表 1.3](#table-13) 所示的时间线即可明了。

#### Table 1.3
|1980s|1991|1992-1995|1996|1997|1998-|
|---|---|---|---|---|---|
|对象因 Smalltalk 和 C++ 而产生影响| Visual Basic 属性与属性表| 可视化工具与 IDE 蓬勃发展| Java JDK 1.0 发布| JavaBean 规范| 基于属性的 Java 与 .NET 平台反射工具爆发式增长|

*从行为丰富到恶名昭彰的贫血症发展历程*

我所指的是属性与属性表的影响力，它们背后都依托着属性`getter`和`setter`，正是原始 Visual Basic 窗体设计器让这些特性广受欢迎。你只需在窗体上放置几个自定义控件实例，填写其属性表，瞧！一个功能完整的 Windows 应用程序就诞生了。相比使用 C 语言直接调用 Windows API 编写类似应用程序需要数天时间，这种方式仅需几分钟即可完成。

那么这一切与贫血领域模型有何关联？ *JavaBean 标准最初旨在协助开发 Java 可视化编程工具*，其初衷是将微软 ActiveX 功能引入 Java 平台。它曾寄望于催生如 Visual Basic 般琳琅满目的第三方定制控件市场。很快，几乎所有框架和库都加入了 JavaBean 的行列。这包括大部分 Java SDK/JDK，以及像流行的 Hibernate 这样的库。就我们关注的领域驱动设计而言， *Hibernate 的引入正是为了实现领域模型的持久化* 。当 .NET 平台出现时，这一趋势仍在延续。

有趣的是，早期使用 Hibernate 持久化的任何领域模型，都必须为每个领域对象中的持久化简单属性及复杂关联暴露公共的`getter`和`setter`方法。这意味着即使你想设计一个具有丰富行为接口的 POJO（ 普通 Java 对象），也必须公开内部实现，以便 Hibernate 能够持久化和重建领域对象。当然，你可以采取措施隐藏公共 JavaBean 接口，但总体而言，大多数开发者既不愿费心实现，甚至不明白为何需要这样做。

---
➜**在领域驱动设计中使用对象关系映射器 (Object-Relational Mappers) 是否值得担忧？**

前文对 Hibernate 的批评基于历史视角。事实上，Hibernate 早已支持隐藏的 `getter/setter`方法，甚至允许直接访问字段。后续章节将演示如何在使用 Hibernate 及其他持久化机制时避免模型贫血症。因此，不必为此忧心。

---

大多数（若非全部）Web 框架也仅基于 JavaBean 标准运行。若希望 Java 对象能填充网页内容，这些  Java 对象最好支持 JavaBean 规范。若希望 HTML 表单提交至服务器端时能填充 Java 对象，Java 表单对象最好支持 JavaBean 规范。

如今市面上几乎所有框架都要求，进而推广，在简单对象上使用公共属性。大多数开发者难免受到企业中遍布的贫血类的影响。承认吧，你也被它咬过一口，不是吗？结果导致我们陷入一种堪称 “贫血泛滥” 的局面。


### 看看贫血症如何摧毁你的模型

好吧，假设我们都认同这既真实又令人烦恼。遍布 *各处的贫血症* 与 *记忆丧失* 有何关联？当你阅读贫血领域模型的客户端代码（例如冒牌 [Application Service (14)](../ch14/0.md) ，类似于`Transaction Script`）时，通常会看到什么？以下是一个基础示例：

```Java
@Transactional
public void saveCustomer(
    String customerId,
    String customerFirstName, String customerLastName,
    String streetAddress1, String streetAddress2,
    String city, String stateOrProvince,
    String postalCode, String country,
    String homePhone, String mobilePhone,
    String primaryEmailAddress, String secondaryEmailAddress) {

    Customer customer = customerDao.readCustomer(customerId);

    if (customer == null) {
        customer = new Customer();
        customer.setCustomerId(customerId);
    }

    customer.setCustomerFirstName(customerFirstName);
    customer.setCustomerLastName(customerLastName);
    customer.setStreetAddress1(streetAddress1);
    customer.setStreetAddress2(streetAddress2);
    customer.setCity(city);
    customer.setStateOrProvince(stateOrProvince);
    customer.setPostalCode(postalCode);
    customer.setCountry(country);
    customer.setHomePhone(homePhone);
    customer.setMobilePhone(mobilePhone);
    customer.setPrimaryEmailAddress(primaryEmailAddress);
    customer.setSecondaryEmailAddress (secondaryEmailAddress);
    customerDao.saveCustomer(customer);
}
```

---
➜**示例刻意保持简单**

诚然，这个示例所涉及的领域并不十分有趣，但它确实有助于我们审视一个不够理想的设计，并确定如何将其重构为更优方案。需要明确的是，这个练习并非旨在探索更酷炫的数据存储方式，而是聚焦于构建能为业务创造价值的软件模型，尽管这个示例本身看似价值有限。

---

这段代码究竟做了什么？其实它相当灵活。无论客户是新注册还是已有用户，它都能保存`Customer`；无论客户姓氏变更还是搬迁至新居，它都能保存`Customer`；无论客户更换了新固话号码、停用固话服务、首次开通手机号码，还是同时发生上述情况，它都能保存`Customer`。它甚至能识别`Customer`从 Juno 邮箱切换至 Gmail 的情况，或因工作变动而更新工作邮箱的场景。哇，这真是个了不起的方法！

或者说，事实真是如此吗？实际上，我们根本不清楚这个`saveCustomer()`方法究竟在哪些业务场景下被调用 —— 至少无法确切知晓。当初创建这个方法的初衷是什么？还有人记得它最初的设计意图吗？那些促使它不断改版以适应各种业务目标的动机又去了哪里？这些记忆很可能在方法创建并修改后的短短数周或数月内就已消失殆尽。它会变的更糟。不信？看看这个方法的下个版本：

```Java
@Transactional
public void saveCustomer(
    String customerId,
    String customerFirstName, String customerLastName,
    String streetAddress1, String streetAddress2,
    String city, String stateOrProvince,
    String postalCode, String country,
    String homePhone, String mobilePhone,
    String primaryEmailAddress, String secondaryEmailAddress) {

    Customer customer = customerDao.readCustomer(customerId);

    if (customer == null) {
        customer = new Customer();
        customer.setCustomerId(customerId);
    }
    if (customerFirstName != null) {
        customer.setCustomerFirstName(customerFirstName);
    }
    if (customerLastName != null) {
        customer.setCustomerLastName(customerLastName);
    }
    if (streetAddress1 != null) {
        customer.setStreetAddress1(streetAddress1);
    }
    if (streetAddress2 != null) {
        customer.setStreetAddress2(streetAddress2);
    }
    if (city != null) {
        customer.setCity(city);
    }
    if (stateOrProvince != null) {
        customer.setStateOrProvince(stateOrProvince);
    }
    if (postalCode != null) {
        customer.setPostalCode(postalCode);
    }
    if (country != null) {
        customer.setCountry(country);
    }
    if (homePhone != null) {
        customer.setHomePhone(homePhone);
    }
    if (mobilePhone != null) {
        customer.setMobilePhone(mobilePhone);
    }
    if (primaryEmailAddress != null) {
        customer.setPrimaryEmailAddress(primaryEmailAddress);
    }
    if (secondaryEmailAddress != null) {
        customer.setSecondaryEmailAddress (secondaryEmailAddress);
    }
    customerDao.saveCustomer(customer);
}
```

我必须指出，这个例子还算轻微的。很多时候数据映射代码会变得极其复杂，大量业务逻辑都被塞进其中。这个例子里我没展示最糟糕的情况，但你可能自己就见过更离谱的。

现在除了`customerId`之外的所有参数都是可选的。我们现在可以使用这个方法在至少十几种业务场景下保存客户，甚至更多！但这真的好吗？我们该如何实际测试这个方法，以确保它不会在错误的场景下保存客户？

简而言之，这种方法出错的可能性远大于成功。或许数据库约束能阻止完全无效的状态被持久化，但现在你必须查阅数据库才能确认。几乎可以肯定，你需要花时间在脑海中将 Java 属性与列名进行映射。等搞清楚这部分后，你又会发现数据库约束缺失或不完整。

你可以查看可能存在的众多客户端（不包括用户界面完成后为管理自动远程客户端而添加的那些），并比较源代码修订版本，从而了解当前实现方式背后的缘由。在探索答案的过程中，你会发现无人能解释为何这种方法能如此运作，也无人知晓其正确用法究竟有多少种。若想独立理解其中奥妙，可能需要数小时甚至数天时间。

|牛仔逻辑||
|--|--|
|AJ：“那家伙糊里糊涂的，都分不清自己是正在收土豆，还是在野牛群里溜旱冰呢。”|<img src="../img/cbl.2.png" width="50%"/>|

领域专家在此无能为力，因为他们必须具备程序员的编程能力才能理解代码。即便有一两位领域专家精通编程或至少能读懂代码，面对代码所支撑的全部功能时，他们恐怕也会和开发者一样束手无策。考虑到这些顾虑，我们敢于修改这段代码吗？如果敢，又该如何修改？

这里至少存在三个重大问题：

1. `saveCustomer()` 接口几乎未体现任何设计意图。
2. `saveCustomer()` 的实现本身增加了隐性复杂度。
3. `Customer` “领域对象” 根本算不上真正的对象，它本质上只是个笨拙的数据容器。

让我们将这种令人不快的状况称为贫血性记忆丧失。在那些产出此类隐性且完全主观的代码 “设计” 的项目中，这种情况屡见不鲜。

---
➜**等等！**

此刻你们中有些人可能在想：“我们的设计永远停留在白板上。我们只是画些结构图，一旦达成共识，就能自由地去实现。真可怕。”

若真是如此，请别将设计与实现割裂看待。谨记实践 DDD 时， *设计即代码，代码即设计。* 换言之，白板图并非最终设计，只是探讨模型难点的工具。

敬请期待后续内容，你将学会如何将白板上的构想转化为切实可行的方案。

---

此时此刻，你应该开始担忧这类代码，并思考如何设计出更优的方案。好消息是，你完全能够在代码中实现明确且精心构思的设计。

#### ▶[下一节](3.md)
