# `Data Fabric`与基于网格的分布式计算

作者：Wes Williams

#### ▶[上一节](7.md)

随着软件系统变得越来越复杂和先进，用户群体不断扩大，并且需求集中在 “大数据” 周围，传统的数据库解决方案可能会成为性能瓶颈。面临超大规模信息系统现实的组织别无选择，只能寻求能够应对计算挑战的解决方案。`Data Fabric` ——有时也称为网格计算 (Grid Computing) <sup>[12](#12)</sup> —— 提供了这种商业环境所需的性能和弹性可扩展性能力。

|牛仔逻辑||
|---|---:|
|AJ：“你想用一杯饮料换些信息吗？”</br> LB：“抱歉，J。我们这里只有现金。”|<img src="../img/cbl.1.png" width="40%" />|

关于`Data Fabric`的一个优点是它们能够以自然的方式支持领域模型，几乎消除了任何阻抗不匹配。事实上，它们的分布式缓存很容易容纳领域对象的持久化，并且可以专门作为`Aggregate Store`。<sup>[13](#13)</sup> 简单地说，`Aggregate`存储在`Fabric`基于 map 的缓存中 <sup>[14](#14)</sup> ，是键值对中的值部分。键 (key) 由`Aggregate`的全局唯一标识符形成，而`Aggregate`状态本身被序列化为某种二进制或文本表示作为值 (value)：

```Java
String key = product.productId().id();

byte[] value = Serializer.serialize(product);

// region (GemFire) or cache (Coherence)
region.put(key, value);
```

因此，使用与领域模型技术方面密切对齐功能的`Data Fabric`的一个积极结果，是可能缩短开发周期。<sup>[15](#15)</sup>

本节提供的示例演示了`Data Fabric`如何在缓存中承载领域模型，并在分布式规模下启用系统功能。在此过程中，我们将探讨如何通过长时运行进程支持 CQRS 架构模式和事件驱动架构 (EDA) 。

### 数据复制

考虑到内存数据缓存，我们可能会立即想到如果缓存以某种方式失败，系统的全部或部分状态可能会丢失的实际可能性。这确实是一个令人担忧的问题，但当在`Fabric`中内置冗余时，这远不成问题。

考虑在使用按`Aggregate`缓存策略时，由`Fabric`提供的内存缓存。在这种情况下，给定类型的`Aggregate`的`Repository`由专用缓存支持。只支持单个节点的缓存会对单点故障非常敏感。然而，提供多节点缓存并带有复制功能的`Fabric`会相当可靠。你可以根据在任何特定时间可能发生故障的节点数量的概率来选择冗余水平，随着包含的节点越多，这一概率范围会变得非常窄。你也可以在冗余和性能之间进行权衡，因为当然，性能会受到实现`Aggregate`完全提交所需节点复制数量的影响。

这里是一个关于缓存（或区域 (region)，仍然取决于具体的`Fabric`）冗余如何工作的示例。一个节点充当 *主* 缓存/区域，其他任意数量的节点为 *次级* 缓存/区域。如果主节点发生故障，将进行故障切换，其中一个次级节点将成为新的主节点。当原来的主节点恢复时，所有存储在新主节点上的数据都会被复制到恢复的节点，并且该节点将成为次级节点。

故障切换节点的另一个优点是，它们确保从`Fabric`发布的事件能够可靠传递。因此，对`Aggregates`的更新以及由此发布的任何`Fabric`事件都不会丢失。显然，缓存冗余和复制是存储业务关键域模型对象的基本功能。

### 事件驱动`Fabric`和`Domain Events`

`Fabric`的一个主要特性是支持事件驱动的风格，并保证事件的传递。大多数`Fabric`内置了技术性质的事件机制，即自动通知有关缓存级别和条目级别发生的事件。这些不应与`Domain Events`混淆。例如，缓存级事件通知诸如缓存重新初始化的发生，而条目级事件则通知诸如条目创建和更新的发生。

不过，对于支持开放架构的`Fabric`，应该有一种方式可以直接从`Aggregates`发布`Domain Events`。你的`Domain Events`可能需要继承特定框架的事件类型，例如 EntryEvent（例如，GemFire），但为了它们所提供的强大功能，这是一个小代价。

你实际上如何在`Fabric`中使用`Domain Events`呢？如在 [Domain Events (8)](../ch8/0.md) 中讨论的，你的`Aggregates`会使用一个简单的 DomainEvent-Publisher 组件。在`Fabric`的缓存中，这个发布者可能只是将发布的事件放入特定的缓存/区域中。缓存的事件随后会被传递给订阅者（监听器），可以是同步或异步的。为了不浪费这个专用事件缓存/区域的宝贵内存，当每个事件被所有订阅者完全确认后，其在 map 中的条目会被移除。当然，每个事件只有在被一个或多个订阅者发布到消息队列或总线，或者用于刷新 CQRS 查询模型后，才算被完全确认。

由于`Domain Events`的订阅者也可能使用事件来执行其他相关`Aggregates`的同步，因此最终一致性是通过这种架构来保证的。

### 持续查询

一些`Fabric`支持一种称为持续查询 (Continuous Query) 的事件通知。这使得客户端可以向`Fabric`注册查询，从而确保客户端收到缓存中满足该查询的变更通知。持续查询的一个用途是用户界面组件，这使得它们能够监听可能影响当前视图的更改。

你能看到接下来会发生什么吗？CQRS 与持续查询功能非常契合，前提是查询模型维护在`Fabric`中。与其让视图去追赶视图表的更新，通过注册的持续查询发送的通知被处理，从而允许视图及时更新。下面是一个客户端注册 GemFire 持续查询事件的示例：

```Java
CqAttributesFactory factory = new CqAttributesFactory();

CqListener listener = new BacklogItemWatchListener();

factory.addCqListener(listener);

String continuousQueryName = "BacklogItemWatcher";

String query = "select * from /queryModelBacklogItem qmbli "
        + "where qmbli.status = 'Committed'";

CqQuery backlogItemWatcher = queryService.newCq(
        continuousQueryName, query, factory.create());
```

`Data Fabric`构现在将根据`Aggregate`修改向客户端回调对象（由 CqListener 提供）传递 CQRS 查询模型更新，同时包括在满足匹配条件时添加、更新或删除的元数据。

### 分布式处理

`Data Fabric`的一个强大用途是将处理分布到结构中复制的缓存中，并将聚合结果返回给客户端。这使得`Fabric`能够实现事件驱动的分布式并行处理，或许还可以使用长时运行进程处理。

为了说明这一特性，我们需要提及 GemFire 和 Coherence 中的一些具体方法。你的 Process 执行器可以实现为 GemFire Function 或 Coherence Entry Processor 。这两者都可以作为在分布式、复制缓存中并行执行的 Command [[Gamma et al.](../bibli.md#gamma-et-al)]  处理器。（你也可以选择将这个概念理解为`Domain Service`，但它所执行的操作可能并非以领域为中心。）为了一致起见，我们称这个特性为 Function 。Function 可以选择性地接受一个过滤器，以限制其对匹配的`Aggregate`实例的执行。

让我们来看一个示例 Function，该 Function 为之前介绍的电话号码计数进程实现了一个长时运行进程。该`Process`将在使用 GemFire Function 的复制缓存中并行执行：

```Java
public class PhoneNumberCountSaga extends FunctionAdapter {
    @Override
    public void execute(FunctionContext context) {
        Cache cache = CacheFactory.getAnyInstance();
        QueryService queryService = cache.getQueryService();

        String phoneNumberFilterQuery = (String) context.getArguments(); ...
        // Pseudo code
        // - Execute Function to obtain MatchedPhoneNumbersCounted.
        //   - Send answer to the aggregator by invoking the
        //     aggregator.sendResult(MatchedPhoneNumbersCounted).
        // - Execute Function to obtain AllPhoneNumbersCounted.
        //   - Send answer to the aggregator by invoking the
        //     aggregator.sendResult(AllPhoneNumbersCounted).
        // - The aggregator automatically accumulates the answers
        //   from each distributed Function call and returns the
        //   single aggregated answer to the client.
    }
}
```

以下是一个客户端示例代码，该客户端将在分布式复制缓存中并行执行一个长时运行过程：

```Java
PhoneNumberCountProcess phoneNumberCountProcess =
         new PhoneNumberCountProcess();

String phoneNumberFilterQuery =
        "select phoneNumber from /phoneNumberRegion pnr "
        + "where pnr.areaCode = '303'";

Execution execution =
        FunctionService.onRegion(phoneNumberRegion)
                .withFilter(0)
                .withArgs(phoneNumberFilterQuery)
                .withCollector(new PhoneNumberCountResultCollector());

PhoneNumberCountResultCollector resultCollector =
         execution.execute(phoneNumberCountProcess);

List allPhoneNumberCountResults = (List) resultsCollector.getResult();
```

当然，进程可能比这个例子更复杂，也可能更简单。这也表明，`Process`并不必然是事件驱动的概念，而是可以与其他并发、分布式处理方法一起工作。关于基于`Fabric`的分布式和并行处理的完整讨论，请参见 [[GemFire Functions](../bibli.md#gemfire-functions)] 。

<center><img src="../img/ownit.png" align="center" width="30%" /></center>

#### ▶[下一节](9.md)

---

#### 12
这并不是说`Fabric`和`Grid`是完全相同的概念，但对于以一般方式看待该架构的人来说，这些标签通常意味着相同的东西。显然，市场营销和销售通常将它们限定为相同的含义。无论如何，本节使用术语`Data Fabric`，因为它通常代表比网格计算更丰富的功能集合。

#### 13
Martin Fowler 最近提倡了`Aggregate Store`这一术语，尽管这个概念已经存在了一段时间。

#### 14
在 GemFire 中，这被称为 region，但其概念与 Coherence 称为缓存的相同。我为了保持一致性使用 *缓存* 这个词。

#### 15
一些 NoSQL 存储也同样可以作为自然的`Aggregate Stores`，简化了实现 DDD 的技术方面。
