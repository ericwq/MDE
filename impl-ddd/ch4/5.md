## 表征状态转移 —— REST

作者：Stefan Tilkov

#### ▶[上一节](4.md)

近年来，REST 已成为最常被使用（也最常被滥用）的架构流行语之一。正如往常，不同的人使用这个缩写词时想到的含义各不相同。对某些人而言，REST 意味着通过 HTTP 连接发送 XML 而不使用 SOAP；有人将其等同于使用 HTTP 和 JSON；还有人认为实现 REST 需要将方法参数作为 URI 查询参数发送。上述解释皆有谬误，但值得庆幸的是 ——与 “组件” 或 “SOA” 等概念截然不同—— REST 存在权威定义来源：Roy T. Fielding 的博士论文不仅首创该术语，更对其进行了清晰界定。

### REST 作为一种架构风格

理解 REST 的首要前提是掌握架构风格的概念。架构风格之于架构，正如设计模式之于具体设计。它是对不同具体实现中共同特征的抽象提炼，使我们能够聚焦其核心优势展开讨论，而不陷入技术细节的迷宫。分布式系统架构存在多种风格，包括客户端-服务器架构和分布式对象架构。Fielding 论文的前几章阐述了其中几种风格，包括它们对遵循各自风格的架构所设定的约束。架构风格及其约束的概念可能显得有些理论化，这种看法是正确的。它们构成了 Fielding 所提出的一种（当时）新架构风格的理论基础。这就是 REST，即万维网架构理应遵循的架构风格。

当然，万维网 ——以其最重要的标准 URI、HTTP 和 HTML 为载体—— 早于 Fielding 的博士研究。但他曾是 HTTP 1.1 标准化进程的核心推动者，对诸多设计决策产生了深远影响，这些决策最终塑造了我们熟知的万维网形态。<sup>[4](#4)</sup> 从这个角度看，REST 实则是对万维网架构本身的事后理论推演。

那么，为何如今我们将 “REST” 等同于特定的系统构建方式，甚至更狭隘地视为构建 Web 服务的方法？究其原因，正如其他技术一样，Web 协议本身存在多种应用方式。其中有些符合原始设计者的初衷，有些则不然。一个常用的类比，通过人们熟悉的 RDBMS 领域，清晰地阐释了这一点。你可以遵循 RDBMS 的架构理念 —— 即定义包含列、外键关系、视图、约束等元素的表；亦可创建仅含 “键” 与 “值” 两列的单表，直接将序列化对象存储于值列中。当然，你仍在使用 RDBMS，但其诸多优势将无法发挥（如高效查询、关联操作、排序分组等功能）。

同样地，Web 协议既可以遵循其原始设计理念 ——采用符合 REST 架构风格的架构—— 也可以被用于违背该理念的场景。正如 RDBMD 的案例所示，忽视底层架构风格将带来巨大风险。因此，若未能充分利用 “RESTful” 方式使用 HTTP 所带来的优势，或许应采用其他类型的分布式系统架构，正如 NoSQL/键值存储对于存储与单个唯一键相关联的整个值来说是更好的选择。

### RESTful HTTP 服务器的关键方面

那么，使用 “RESTful HTTP” 的分布式架构的关键方面有哪些呢？我们先来看服务器端。请注意，无论我们讨论的是由人使用网页浏览器访问的服务器（ “Web 应用程序” ），还是由某个其他代理使用的服务器，例如用你选择的编程语言编写的客户端（“Web 服务”），这一点都是完全无关的。

首先，顾名思义，资源是核心概念。为何如此？作为系统设计师，你需要确定哪些有意义的 “事物” 需要对外暴露供访问，并为每个事物分配唯一标识。通常每个资源对应一个 URI，更重要的是每个 URI 应指向唯一资源 —— 对外暴露的 “事物” 必须具备独立可寻址性。例如，你可能决定将每位客户、每件商品、每条商品列表、每次搜索结果，甚至商品目录的每次变更都作为独立资源。<ins>资源具有表现形式，即其状态的呈现方式，可采用一种或多种格式</ins>。客户端正是通过这些表现形式（如 XML/JSON 文档、HTML 表单提交数据或二进制格式）与资源进行交互。

下一个关键点是无状态通信的概念，即使用自描述消息。例如 HTTP 请求就包含了服务器处理所需的所有信息。当然，服务器可以（且通常会）利用自身的持久化状态提供辅助，但关键在于客户端与服务器不应依赖单个请求来建立隐式上下文（即会话）。这使得资源访问能够独立于其他请求进行，该特性对实现大规模可扩展性至关重要。

若将资源视为对象 ——这种视角完全合理—— 那么探讨它们应具备何种接口便具有现实意义。答案揭示了 <ins>REST 与其他分布式系统架构风格的关键差异：可调用的方法集是固定的</ins>。每个对象都支持相同的接口。在 RESTful HTTP 中，这些方法就是可应用于资源的 HTTP 动词 —— 最重要的是 GET、PUT、POST、DELETE。

尽管乍看之下似乎如此，这些方法并不等同于 CRUD 操作。创建不代表任何持久化实体的资源非常常见，这类资源实际上封装了行为，当用户对其使用适当的动词时就会被调用。每个 HTTP 方法在规范中都有明确定义。例如 GET 方法仅用于 “安全” 操作：(1) 可执行客户端未主动请求的效果；(2) 始终读取数据；(3) 可被缓存（若服务器通过响应头明确标记）。

HTTP 的 GET 方法曾被 Don Box 誉为 “全球最优化的分布式系统基础架构组件” ，Don 是 SOAP 风格 Web 服务的主要推动者之一。他的评价凸显出：我们习以为常的网络性能与可扩展性，很大程度上源于 HTTP 针对这一特定且极其常见场景所做的优化。

某些HTTP方法具有 *幂等性* ，这意味着当出现错误或结果不明确时，可以安全地再次调用这些方法而不会引发问题。GET、PUT 和 DELETE 方法均具备此特性。

最后，RESTful 服务器通过超媒体机制，使客户端能够探索应用程序可能状态转换的路径。Fielding 在其博士论文中将此称为 *“超媒体作为应用程序状态引擎”（Hyper-media as the Engine of Application State, HATEOAS）* 。简而言之，各个资源并非独立存在，而是相互关联、彼此链接。这本不该令人惊讶。毕竟万维网（Web）的命名正源于此。对服务器而言，这意味着它将在响应中嵌入链接，使客户端能够与关联资源进行交互。

### RESTful HTTP 客户端的关键方面

RESTful HTTP 客户端通过两种方式在资源间迁移：一是追随资源表示中包含的链接，二是因向服务器发送数据处理而被重定向至其他资源。服务器与客户端协同作用，动态影响客户端的分布行为。由于 URI 包含了解析地址所需的所有信息（包括主机名和端口），遵循超媒体原则的客户端最终可能与由不同应用程序、不同主机甚至不同公司托管的资源进行通信。

在理想的 REST 架构中，客户端将从单个已知 URI 开始，随后持续遵循超媒体控制指令。这正是浏览器渲染并向用户展示 HTML（包括链接和表单）时采用的模式。随后，它利用用户输入与众多 Web 应用程序交互，而无需预先了解这些应用的接口或实现细节。

诚然，浏览器并非独立自主的代理。它需要人类来做出实际决策。但程序化客户端可以遵循许多相同的原则，即使某些逻辑是硬编码的。它会追踪链接而非预设特定的 URI 结构，甚至不会假设资源位于同一服务器，同时它会运用对一种或多种媒体类型的认知。

### REST 与 DDD

尽管颇具诱惑力，但直接通过 RESTful HTTP 暴露领域模型并非明智之举。这种做法往往导致系统接口变得比实际需要的更脆弱，因为领域模型的每次变更都会直接反映在系统接口上。将 DDD 与 RESTful HTTP 相结合有两种替代方案。

第一种方法是为系统的接口层创建独立的`Bounded Context`，并采用适当策略从系统接口模型访问实际的`Core Domain`。这可视为经典方案，因其将系统接口视为内聚整体，仅通过资源抽象而非服务或远程接口进行暴露。

让我们通过一个具体示例来阐释这种方法。我们构建一个管理工作组的系统，涵盖其任务、日程安排/预约、子组以及处理这些事务所需的所有流程。我们将设计一个纯粹的领域模型，不受基础设施细节影响，该模型既能体现`Ubiquitous Language `，又能实现必要的业务逻辑。为向外界发布这个精心设计的领域模型接口，我们提供了一组基于 RESTful 资源的远程接口。这些资源反映了客户端所需的使用场景，其形态很可能与纯粹的领域模型不同。然而每个资源都由核心领域中一个或多个`Aggregates`构成。

当然，我们可以直接将领域对象作为 JAX-RS 资源方法的参数 —— 例如 /:user/:task 映射到返回 Task 对象的方法 getTask() 。这看似简单，却存在一个重大问题。对 Task 对象结构的任何修改都会立即反映在远程接口中，可能导致大量客户端失效，即便我们修改的内容与外部世界完全无关。这显然不可取。

<ins>因此首选第一种方案，即将`Core Domain`与系统接口模型解耦</ins>。这样便能先对`Core Domain`进行变更，再根据具体情况决定是否需要反映到系统接口模型中，若需反映则确定最佳映射方式。需注意的是，采用此方案时，系统接口模型中的类通常由`Core Domain`类驱动，但必然受用例驱动。注：即使在此情况下，我们仍可定义自定义媒体类型。

<ins>当更侧重于标准媒体类型时，另一种方法更为适用</ins>。若开发特定媒体类型不仅支持单一系统接口，还要支持一类相似的客户端-服务器交互，则可创建领域模型来表示每种标准媒体类型。此类领域模型甚至可在客户端和服务器间复用，尽管某些 REST 和 SOA 倡导者视此为反模式。注：此方法本质上属于 DDD 中的 [Shared Kernel (3)](../ch3/0.md) 或 [Published Language (3)](../ch3/0.md) 。

这更体现了一种由外而内、横向贯穿的方法论。在前文提及的工作组与任务管理领域中，存在多种通用格式。以 *ical* 格式为例，这是一种通用格式，可被多种不同应用程序使用。在此情况下，我们首先选择媒体类型（ical），然后为该格式创建领域模型。该模型可供任何需要解析此格式的系统使用 —— 例如我们的服务器应用程序，同时也适用于其他系统（如安卓客户端）。当然，采用这种方法时，服务器可能需要处理多种媒体类型，而同一媒体类型也可能被多个服务器使用。

这两种方法的选择在很大程度上取决于系统设计者对可重用性的目标。解决方案越专业化，第一种方法就越有效；而解决方案越具有普遍适用性，其极端形式是由官方标准机构制定的标准化方案，采用第二种以媒体类型为中心的方案就越合理。

### 为何选择REST？

<ins>根据我的经验，遵循 REST 原则设计的系统能够真正实现松耦合的承诺</ins>。通常情况下，在现有资源表示中添加新资源及其关联链接非常容易。同时，在需要时支持新格式也十分便捷，从而显著降低系统连接的脆弱性。基于 REST 的系统更易于理解，因其被拆分为更小的单元，资源，每个资源都提供可独立测试、调试和使用的入口点。HTTP 的设计特性及工具链的成熟度（如支持 URI 重写和缓存功能），使 RESTful HTTP 成为兼具松耦合与高可扩展性架构的理想选择。

#### ▶[下一节](6.md)

---

#### 1
他恰好也是首个被广泛使用的 HTTP 库的作者，Apache HTTP 服务器的原始开发者之一，以及 Apache 软件基金会的创始人。
