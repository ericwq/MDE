## 规则：在边界之外使用最终一致性

#### ▶[上一节](4.md)

在 [[Evans](../bibli.md#evans)] 对`Aggregate`模式的定义中，有一条表述常常被人忽略。
而当单个客户端请求必须影响多个`Aggregates`时，这条表述对于我们实现模型一致性的工作具有至关重要的指导意义：

* 任何跨越`AGGREGATES`的规则，都不要求始终保持实时更新。通过事件处理、批处理或其他更新机制，相关的依赖关系可在特定时间范围内得到解决。——[[Evans, p. 128](../bibli.md#evans)]

因此，若对某个`Aggregate`实例执行命令时，需要在一个或多个其他`Aggregates`上同时执行额外的业务规则，此时应采用最终一致性。
要知道，在大规模、高访问量的企业系统中，所有`Aggregate`实例永远无法达到完全一致的状态；理解并接受这一点，也能帮助我们认识到，即便是在仅涉及少量实例的小规模场景中，最终一致性同样具有合理性。

去询问领域专家，他们是否能容忍某个实例发生修改后，与之相关的其他实例的更新存在一定的时间延迟。
领域专家有时远比开发人员更能接受延迟一致性的理念。
他们清楚业务中始终存在着实际的延迟情况，而开发人员往往受固有观念影响，秉持着原子性变更的思维模式。
领域专家大多还记得业务操作实现计算机自动化之前的日子，那时各类延迟随处可见，数据一致性也从未实现即时达成。
因此，领域专家通常愿意接受在一致性达成前存在合理的延迟——哪怕是数秒、数分钟、数小时，甚至数天的较长时间。

在 DDD 模型中，有一套实现最终一致性的实用方法。
`Aggregate`的命令方法会发布`Domain Event`，该事件随后被异步推送给一个或多个订阅方：

```java
public class BacklogItem extends ConcurrencySafeEntity {
    ...
    public void commitTo(Sprint aSprint) {
        ...
        DomainEventPublisher
            .instance()
            .publish(new BacklogItemCommitted(
                this.tenantId(),
                this.backlogItemId(),
                this.sprintId()));
    }
    ...
}
```

随后，每个订阅方都会获取对应的另一`Aggregate`实例，并基于该实例执行自身业务逻辑。
所有订阅方均在独立事务中执行操作，遵循`Aggregates`设计原则，即每个事务仅修改一个`Aggregate`实例。

若订阅方与其他客户端发生并发冲突，导致修改操作失败，该如何处理？
若订阅方未向消息机制确认操作成功，即可重试此次修改。
消息会被重新投递，系统将启动新事务，再次尝试执行所需命令并完成相应提交。
此重试流程将持续进行，直至达成数据一致性，或达到重试次数上限。<sup>[6](#6)</sup>
若最终执行失败，则需执行补偿操作，至少也应上报失败信息，等待人工介入处理。

在这个具体示例中，发布 BacklogItemCommitted `Domain Event`能够实现什么效果？
要知道，BacklogItem 本身已存储了其被提交至的 Sprint 的标识，我们完全无意维护无实际意义的双向关联。
相反，该事件支持延后创建 CommittedBacklogItem，让 Sprint 可以记录工作提交情况。
由于每个 CommittedBacklogItem 都包含一个 ordering 属性，Sprint 便能为每个 BacklogItem 设置独立的排序规则，与 Product 和 Release 的排序规则相区分，且该排序规则与 BacklogItem 实例自身记录的 BusinessPriority 评估结果无关联。
Product 和 Release 也采用类似的关联方式，分别对应 ProductBacklogItem 和 ScheduledBacklogItem。

---
**白板时间**

- 回顾你列出的大型`Aggregates`清单，以及那些在单个事务中被修改的两个及以上`Aggregates`。

- 描述并绘制图表，说明你将如何拆分这些大型`Aggregates`。圈出并标注每个新拆分出的小`Aggregates`内的所有真正不变量。

- 描述并绘制图表，说明你将如何让相互独立的`Aggregates`最终保持一致。

---

本示例演示了如何在单个`Bounded Context`使用最终一致性，而该方法同样可按照前文所述，以分布式方式加以应用。

### 明确职责归属

<ins>部分领域场景中，判断应采用事务一致性还是最终一致性会面临极大的挑战。</ins>
采用经典传统方式践行 DDD 的从业者，可能更倾向于使用事务一致性；
而采用 CQRS 模式的从业者，则可能更倾向于最终一致性。
但哪种方式才是正确的？
坦率地说，这两种倾向都无法给出贴合具体领域的答案，只是体现了不同的技术偏好而已。
有没有一种更好的方法来打破这种僵局？

|牛仔逻辑||
|------|---:|
|LB：“我儿子跟我说，他在网上找到了能让咱家母牛多产崽的法子。我跟他说，这事儿本就是公牛的职责。”|<img src="../img/cbl.2.png" width="60%" />|

与 Eric Evans 探讨后，得出了一条简洁且合理的指导原则。
<ins>分析用例（或用户故事）时，需明确让数据保持一致是否为执行该用例的用户的职责。
若是，则应尽力实现事务一致性，且必须遵循`Aggregates`的其他设计规则；
若该职责归属于其他用户或系统，则可采用最终一致性。
这一实用经验不仅能巧妙打破选择僵局，还能帮助我们更深入地理解业务领域，
挖掘出真正的系统不变量；即那些必须保持事务一致性的规则。
这份理解，远比单纯默认采用某种技术倾向更具价值。</ins>

这是一条值得纳入`Aggregate`设计经验法则的重要技巧。
由于实际设计中还需考量其他影响因素，该原则未必能直接决定事务一致性与最终一致性的最终选择，但通常能为领域模型设计带来更深刻的洞见。
本章后续内容中，团队重新审视`Aggregate`边界时，便会运用这一指导原则。

#### ▶[下一节](6.md)

---

#### 6

可考虑采用有限指数退避策略执行重试操作。并非默认每隔固定时长重试一次，而是以指数方式增加重试间隔，同时为等待时长设置上限。例如，首次重试等待1秒，后续每次等待时长翻倍，直至操作成功或达到32秒的重试等待上限。

