## 实现

#### ▶[上一节](7.md)

本文中归纳并重点阐述的这些关键因素，能够提升实现方案的健壮性，相关内容还需结合 [Entities (5)](../ch5/0.md) 、[Value Objects (6)](../ch6/0.md)、[Domain Events (8)](../ch8/0.md)、[Modules (9)](../ch9/0.md)、[Factories (11)](../ch11/0.md) 及 [Repositories (12)](../ch12/0.md) 章节做更深入研究。
可将本部分综合内容作为参考依据。

### 创建具有唯一标识的根`Entity`

将其中一个`Entity`建模为`Aggregate`根。
在之前的建模工作中，根`Entities`实体的示例包括 Product 、 BacklogItem 、 Release 和 Sprint 。
根据是否将 Task 从 BacklogItem 中拆分出来的决策结果，Task也可能成为一个根`Entity`。
经过优化的 Product 模型最终明确了以下根`Entity`的定义：

```java
public class Product extends ConcurrencySafeEntity {
    private Set<ProductBacklogItem> backlogItems;
    private String description;
    private String name;
    private ProductDiscussion productDiscussion;
    private ProductId productId;
    private TenantId tenantId;
    ...
}
```

类 ConcurrencySafeEntity 是一个`Layer Supertype` [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] ，用于管理代理身份和乐观并发版本控制，如实体 [Entities (5)](../ch5/0.md) 中所述。

此前未曾提及的一组 ProductBacklogItem 实例，现已被添加至该根中，这一点或许看似费解，但实则具有特定用途。
这组实例与此前在此处组合的 BacklogItem 集合并非同一概念，其用途是为了维护待办项的独立排序。

每个根都必须设计全局唯一标识。
在 Product 模型中，我们定义了一个名为 ProductId 的`Value`类型，
该类型是领域专用标识，与 ConcurrencySafeEntity 提供的代理标识截然不同。
基于模型的标识应如何设计、分配与维护，相关详细说明见 [Entities (5)](../ch5/0.md) 。
 ProductRepository 的实现中，通过 nextIdentity() 方法生成 UUID 格式的 ProductId ：

```java
public class HibernateProductRepository implements ProductRepository {
    ...
    public ProductId nextIdentity() {
        return new ProductId(java.util.UUID.randomUUID().toString().toUpperCase());
    }
    ...
}
```

通过 nextIdentity() 方法，客户端`Application Service`可以实例化一个带有全局唯一标识的 Product 。

```java
public class ProductService ... {
    ...
    @Transactional
    public String newProduct(
        String aTenantId, aProductName, aProductDescription) {
        Product product =
            new Product(
                new TenantId(aTenantId),
                this.productRepository.nextIdentity(),
                "My Product",
                "This is the description of my product.",
                new ProductDiscussion(
                    new DiscussionDescriptor(
                        DiscussionDescriptor.UNDEFINED_ID),
                    DiscussionAvailability.NOT_REQUESTED));

        this.productRepository.add(product);

        return product.productId().id();
    }
    ...
}
```

`Application Service`通过 ProductRepository 完成两项操作：一是生成标识，二是持久化该新的 Product 实例。
随后，它返回新生成的 ProductId 对应的纯字符串表示形式。

### 优先使用`Value Object`组件

尽可能将包含的`Aggregate`部件建模为`Value Object`，而不是`Entity`。
如果一个包含的部件可以被完全替换，并且其替换不会在模型或基础设施中造成重大开销，那么它就是最佳候选对象。

我们当前的 Product 模型设计有两个简单属性和三个`Value`类型属性。
description 和 name 都是字符串属性，可以完全替换。
productId 和 tenantId `Value`被维护为稳定标识；也就是说，它们在构建后永远不会改变。
它们支持通过标识引用，而不是直接引用对象。
实际上，被引用的 Tenat `Aggregate`甚至不在同一个`Bounded Context`中，因此应该仅通过标识来引用。
productDiscussion 是最终一致的`Value`类型 property。
当 Product 首次实例化时，讨论可能会被请求，但直到稍后才会存在。
它必须在`Collaboration Context`中创建。
一旦在另一个`Bounded Context`中完成创建，标识和状态就会在 Product 上设置。

把 ProductBacklogItem 建模为`Entity`而不是`Value`是有充分理由的。
如在 [Value Objects (6)](../ch6/0.md) 中讨论的，由于后台数据库通过 Hibernate 使用，它必须将`Value`的集合建模为数据库实体。
重新排序任何一个元素都可能导致大量，甚至所有 ProductBacklogItem 实例被删除并替换。
这会导致基础设施产生显著的开销。
作为`Entity`，它允许在任何集合元素中，根据产品负责人需要随时更改 ordering 属性。
然而，如果我们从使用 MySQL 的 Hibernate 切换到键值存储，我们可以很容易地将 ProductBacklogItem 改为`Value`类型。
在使用键值或文档存储时，`Aggregate`实例通常作为一个值的表示来序列化存储。

### 使用迪米特法则和 “告诉而非询问”  
迪米特法则 (Law of Demeter) [[Appleton, LoD](../bibli.md#appleton-lod)] 和告诉而非询问 (Tell, Don’t Ask) [[PragProg, TDA](../bibli.md#pragprog-tda)] 都是可以在实现`Aggregates`时使用的设计原则，两者都强调信息隐藏。
考虑这些高层指导原则，可以看看我们如何从中受益:

- *迪米特法则* ：该指导原则强调 *最少知识原则* 。
假设有一个客户端对象，以及该客户端对象为执行某些系统行为而使用的另一个对象，将后者称为服务端对象。
当客户端对象使用服务端对象时，应尽可能少地了解服务端对象的结构。
服务端对象的属性与 properties ——即其自身形态—— 应完全对客户端对象隐藏。
客户端对象可请求服务端对象执行其外部接口上声明的命令，
但不得深入服务端对象内部、向服务端对象请求某个内部组件，再对该组件执行命令。
若客户端对象需要服务端对象的内部组件所提供的服务，不得为客户端对象开放对这些内部组件的访问权限以发起该行为请求。
服务端对象应仅对外提供外部接口，且在被调用时，由自身将请求委托给相应的内部组件，以完成接口的实现。

  以下是迪米特法则的基本概述：任意对象中的任意指定方法，仅可调用以下对象的方法：（1）自身对象；（2）传入该方法的任意参数对象；（3）该方法实例化的任意对象；（4）可由其直接访问的内置组成对象。

- *告诉而非询问* ：这条准则简单地指出，应当告诉对象该做什么。
“不要询问” 部分适用于客户端如下：客户端对象不应向服务端对象询问其包含的部分，然后根据获取的状态做出决定，再让服务端对象执行某件事。
相反，客户端应通过服务端的公共接口上的命令 “告诉” 服务器该做什么。
这条准则的动机与迪米特法则非常相似，但 “告诉而非询问” 可能更容易广泛应用。

结合上述指导原则，我们来探讨如何将这两项设计原则应用于 Product：

```java
public class Product extends ConcurrencySafeEntity {
    ...
    public void reorderFrom(BacklogItemId anId, int anOrdering) {
        for (ProductBacklogItem pbi : this.backlogItems()) {
          pbi.reorderFrom(anId, anOrdering);
        }
    }

    public Set<ProductBacklogItem> backlogItems() {
        return this.backlogItems;
    }
    ...
}
```

该 Product 对象要求客户端通过调用其 reorderFrom() 方法，来对其内部包含的 backlogItems 执行修改状态的命令。
这是对上述指导原则的良好实践。
然而，backlogItems() 方法同样被设置为公共方法。
那么，将 ProductBacklogItem 实例暴露给客户端，是否违背了我们正试图遵循的设计原则呢？
答案是：该方法确实暴露了这个集合，但客户端仅能使用这些实例来查询其中的信息。
由于 ProductBacklogItem 的公共接口具有严格的局限性，客户端无法通过深度导航来探知 Product 的内部结构。
这就保证了客户端仅获取到 *最少必要的知识* 。
在客户端看来，返回的集合实例可能只是为单次操作专门创建的，并不一定代表 Product 的某个确定状态。
而且，正如 ProductBacklogItem 的实现所规定的那样，客户端绝对不允许对这些实例执行任何会改变其状态的命令。

```java
public class ProductBacklogItem extends ConcurrencySafeEntity {
    ...
    protected void reorderFrom(BacklogItemId anId, int anOrdering) {
        if (this.backlogItemId().equals(anId)) {
            this.setOrdering(anOrdering);
        } else if (this.ordering() >= anOrdering) {
            this.setOrdering(this.ordering() + 1);
        }
    }
    ...
}
```

其唯一的状态修改行为被声明为隐藏的受保护方法，客户端无法查看或调用该方法。
实际使用中，仅有 Product 可访问并执行此方法。
客户端仅能调用 Product 的公共方法 reorderFrom() ，
该方法被调用时，Product 会将操作委托给其内部所有 ProductBacklogItem 实例，由这些实例完成具体的内部状态修改。

通过应用这些简单的设计原则，Product 的实现不仅限制了自身内部信息的对外暴露，还提升了可测试性与可维护性。

你需要权衡迪米特法则与 "告诉而非询问" 原则在使用过程中的制衡关系。
迪米特法则的应用方式无疑具有更强的约束性，它禁止跨越`Aggregate`根对内部的所有组件进行任何导航操作。
而命令而非询问原则虽允许跨越聚合根进行导航，却明确规定聚合状态的修改操作归属于聚合本身，而非客户端。因此你会发现，命令而非询问原则是一种更广泛适用于聚合实现的设计思路。

你需要权衡在使用迪米特法则与 “告诉而非询问” 之间的利弊。
<ins>当然，迪米特法则的方法限制更多，除了根之外，不允许访问`Aggregate`内部。
另一方面，使用 “告诉而非询问” 允许访问根对象之外的部分，但规定`Aggregate`状态的修改应由`Aggregate`本身负责，而不是由客户端操作。
因此，你可能会发现 “告诉而非询问” 对于`Aggregate`实现来说是一种更广泛适用的方法。</ins>

### 乐观并发

接下来，我们需要考虑将乐观并发的 version 属性放置在何处。
当我们仔细考量`Aggregate`的定义时，似乎只对根`Entity`进行版本控制是最安全的方案。
无论`Aggregate`边界内的状态修改发生在哪个层级（无论深度如何），只要执行了改变状态的命令，根的版本号就应进行递增。
以我们正在讨论的示例来说明：Product 对象会包含一个 version 属性，当它的任意一个状态修改命令方法（describeAs()、initiateDiscussion()、rename() 或 reorderFrom()）被执行时，该版本号都会随之递增。
这种设计可以防止其他客户端同时修改同一个 Product 内部任意位置的任何属性或 properties。
不过，具体取决于`Aggregate`的设计方案，这种方式，可能会难以管理，甚至是不必要的。

假设我们正在使用 Hibernate 框架，那么当 Product 的 name 或 description 被修改，或者它的 productDiscussion 被关联附加时，版本号会自动递增。
这是既定行为，因为这些元素都是由根`Entity`直接持有管理的。
然而，当 Product 内部的任意 backlogItems 被重新排序时，我们该如何确保 Product 的 version 也能随之递增呢？
事实上，我们无法实现这一点，至少无法让它自动实现。
Hibernate 不会将对 ProductBacklogItem 子实例的修改，视为对 Product 自身的修改。
要解决这个问题，我们或许可以直接修改 Product 的 reorderFrom() 方法，手动标记某个脏标记（dirty some flag），或者由我们自己来递增 version：

```java
public class Product extends ConcurrencySafeEntity {
    ...
    public void reorderFrom(BacklogItemId anId, int anOrdering) {
        for (ProductBacklogItem pbi : this.backlogItems()) {
            pbi.reorderFrom(anId, anOrdering);
        }
        this.version(this.version() + 1);
    }
    ...
}
```

其中存在一个问题：无论这份重新排序的命令是否实际产生了效果，这段代码都会无条件地将该 Product 标记为脏数据。
此外，这段代码还将基础设施相关的关注点渗透到了领域模型中，如果能够避免这种情况，那么这绝不是一个理想的领域建模选择。
我们还能采取其他什么方案呢？






#### ▶[下一节](9.md)
