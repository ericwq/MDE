## 实现

#### ▶[上一节](7.md)

本文中归纳并重点阐述的这些关键因素，能够提升实现方案的健壮性，相关内容还需结合 [Entities (5)](../ch5/0.md) 、[Value Objects (6)](../ch6/0.md)、[Domain Events (8)](../ch8/0.md)、[Modules (9)](../ch9/0.md)、[Factories (11)](../ch11/0.md) 及 [Repositories (12)](../ch12/0.md) 章节做更深入研究。
可将本部分综合内容作为参考依据。

### 创建具有唯一标识的根`Entity`

将其中一个`Entity`建模为`Aggregate`根。
在之前的建模工作中，根`Entities`实体的示例包括 Product 、 BacklogItem 、 Release 和 Sprint 。
根据是否将 Task 从 BacklogItem 中拆分出来的决策结果，Task也可能成为一个根`Entity`。
经过优化的 Product 模型最终明确了以下根`Entity`的定义：

```java
public class Product extends ConcurrencySafeEntity {
    private Set<ProductBacklogItem> backlogItems;
    private String description;
    private String name;
    private ProductDiscussion productDiscussion;
    private ProductId productId;
    private TenantId tenantId;
    ...
}
```

类 ConcurrencySafeEntity 是一个`Layer Supertype` [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] ，用于管理代理身份和乐观并发版本控制，如实体 [Entities (5)](../ch5/0.md) 中所述。

此前未曾提及的一组 ProductBacklogItem 实例，现已被添加至该根中，这一点或许看似费解，但实则具有特定用途。
这组实例与此前在此处组合的 BacklogItem 集合并非同一概念，其用途是为了维护待办项的独立排序。

每个根都必须设计全局唯一标识。
在 Product 模型中，我们定义了一个名为 ProductId 的`Value`类型，
该类型是领域专用标识，与 ConcurrencySafeEntity 提供的代理标识截然不同。
基于模型的标识应如何设计、分配与维护，相关详细说明见 [Entities (5)](../ch5/0.md) 。
 ProductRepository 的实现中，通过 nextIdentity() 方法生成 UUID 格式的 ProductId ：

```java
public class HibernateProductRepository implements ProductRepository {
    ...
    public ProductId nextIdentity() {
        return new ProductId(java.util.UUID.randomUUID().toString().toUpperCase());
    }
    ...
}
```

通过 nextIdentity() 方法，客户端`Application Service`可以实例化一个带有全局唯一标识的 Product 。

```java
public class ProductService ... {
    ...
    @Transactional
    public String newProduct(
        String aTenantId, aProductName, aProductDescription) {
        Product product =
            new Product(
                new TenantId(aTenantId),
                this.productRepository.nextIdentity(),
                "My Product",
                "This is the description of my product.",
                new ProductDiscussion(
                    new DiscussionDescriptor(
                        DiscussionDescriptor.UNDEFINED_ID),
                    DiscussionAvailability.NOT_REQUESTED));

        this.productRepository.add(product);

        return product.productId().id();
    }
    ...
}
```

`Application Service`通过 ProductRepository 完成两项操作：一是生成标识，二是持久化该新的 Product 实例。
随后，它返回新生成的 ProductId 对应的纯字符串表示形式。

### 优先使用`Value Object`组件

尽可能将包含的`Aggregate`部件建模为`Value Object`，而不是`Entity`。
如果一个包含的部件可以被完全替换，并且其替换不会在模型或基础设施中造成重大开销，那么它就是最佳候选对象。

我们当前的 Product 模型设计有两个简单属性和三个`Value`类型属性。
description 和 name 都是字符串属性，可以完全替换。
productId 和 tenantId `Value`被维护为稳定标识；也就是说，它们在构建后永远不会改变。
它们支持通过标识引用，而不是直接引用对象。
实际上，被引用的 Tenat `Aggregate`甚至不在同一个`Bounded Context`中，因此应该仅通过标识来引用。
productDiscussion 是最终一致的`Value`类型 property。
当 Product 首次实例化时，讨论可能会被请求，但直到稍后才会存在。
它必须在`Collaboration Context`中创建。
一旦在另一个`Bounded Context`中完成创建，标识和状态就会在 Product 上设置。


#### ▶[下一节](9.md)
