## 规则：在一致性边界中建模真实不变量

#### ▶[上一节](1.md)

在某个 [Bounded Context (2)](../ch2/0.md) 中探寻`Aggregates`的设计思路时，我们必须先理解模型背后的真实不变量。
唯有掌握这一核心要点，才能确定哪些对象应归为同一个`Aggregate`。

<ins>不变量（invariant）是指必须始终保持一致的业务规则。</ins>
一致性存在多种类型。
其一为 *事务一致性（transactional consistency）* ，这类一致性具有即时性和原子性的特征；
另一种则是 *最终一致性（eventual consistency）* 。
*在探讨不变量（invariant）时，我们所指的是事务一致性（transactional consistency）* 。
我们可能会遇到这样的不变量（invariant）：

```
c=a+b
```

因此，当 a 为 2、b 为 3 时，c 必须为 5。
根据该规则和条件，若 c 的取值不为 5，就违反了系统不变量（invariant）。
为确保 c 的一致性，我们围绕模型的这些特定属性设定了一致性边界（consistency boundary）：

```java
AggregateType1 {
    int a;
    int b;
    int c;

    operations ...
}
```

一致性边界从逻辑上规定，无论执行何种操作，其内部的所有内容都必须遵循一组特定的业务不变量规则。
该边界之外的所有内容的一致性与`Aggregate`无关。
因此，`Aggregate`等同于 *事务一致性边界* 。
（在这个简单的示例中，AggregateType1 包含三个整数类型的属性，但任意一个`Aggregate`均可包含不同类型的属性。）

在采用常规持久化机制时，我们会通过单个事务 <sup>[2](#2)</sup> 来维护一致性。
事务提交时，同一边界内的所有内容必须保持一致。
*设计合理的`Aggregate`，可按照业务所需进行任意修改，且其不变量能在单个事务内完全保持一致*。
而设计合理的`Bounded Context`，在所有情况下，每个事务仅对一个`Aggregate`实例进行修改。
此外， *若不开展事务分析，我们便无法对`Aggregate`设计做出合理的推导*。

限定每个事务仅修改一个`Aggregate`实例，听起来或许过于严苛。
但这是一条经验法则，且应成为绝大多数场景下的设计目标，这一要求也正是使用`Aggregates`的核心初衷。

---
**白板时间**

- 在白板上列出系统中所有的大型`Aggregates`。

- 在每个`Aggregates`旁标注其成为大型`Aggregate`的原因，以及因规模引发的各类潜在问题。

- 在该列表旁，标注出所有与其他`Aggregates`在同一事务中被修改的`Aggregates`。

- 在每个此类`Aggregates`旁标注，其`Aggregate`边界设计不佳的成因是真实不变量还是虚假不变量。

---

`Aggregates`的设计必须以一致性为核心，这意味着用户界面应将每次执行单个命令的请求限定在唯一的`Aggregate`实例上。
若用户请求试图实现过多操作，应用程序将被迫同时修改多个实例。

因此，`Aggregates`的核心要义在于一致性边界，而非出于设计对象图的需求。
现实业务中的部分不变量会比示例中更为复杂，但即便如此，不变量对建模工作的要求通常并不会过高，这也让设计 *小型`Aggregates`* 成为可能。

#### ▶[下一节](3.md)

---

#### 2

事务可由`Unit of Work` [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] 进行处理。
