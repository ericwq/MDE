## 第 10 章：聚合体 (Aggregates)

#### ▶[上一节](../ch9/7.md)

*<p align="right">
宇宙是由永恒的事物聚合而成的整体，</br>
这些事物通过独立于主体的因果关系相联结，</br>
并存在于客观的时空之中。</br>
——Jean Piaget</p>*

将 [Entities (5)](../ch5/0.md) 与 [Value Objects (6)](../ch6/0.md) 归整为一个带有精心设定的一致性边界的`Aggregates`，乍看之下似乎轻而易举，但在 DDD 的所有战术指导原则中，这一模式却是最难以被透彻理解的模式之一。

---
**<center>本章路线图</center>**

- 结合 SaaSOvation 案例，体会`Aggregates`建模不当引发的负面后果。

- 学习将`Aggregate`设计经验法则（Rules of Thumb）作为一套最佳实践准则进行设计。

- 掌握如何根据实际业务规则，在一致性边界（consistency boundaries）内对真正的不变量（invariants）进行建模。

- 思考设计小型`Aggregates`的优势。

- 理解为何应将`Aggregates`设计为通过标识引用其他`Aggregate`。

- 认识到在`Aggregate`边界外运用最终一致性的重要性。

- 学习`Aggregate`的实现技巧，包括 Tell, Don’t Ask 和 Law of Demeter 。

---

首先，不妨思考一些常见问题。
`Aggregate`是否只是将一组紧密关联的对象 *聚集* 在一个公共根对象下的一种方式？
若是如此，该对象图中允许包含的对象数量是否存在实际限制？
既然一个`Aggregate`实例可以引用其他`Aggregate`实例，那么是否可以对这些关联进行深度导航，并在导航过程中修改各类对象？
而 *不变量（invariants）* 与 *一致性边界（consistency boundary）* 这一概念又究竟指什么？
对最后这个问题的解答，会极大地影响对其他问题的回答。

建模`Aggregate`的错误方式多种多样。
我们可能会陷入为组合便捷性而设计的误区，从而将其设计得过于庞大。
另一个极端则是将所有`Aggregates`过度简化，最终导致无法保护真正的不变量（invariants）。
正如我们将看到的，我们必须避免这两种极端情况，转而关注业务规则。

#### ▶[下一节](1.md)
