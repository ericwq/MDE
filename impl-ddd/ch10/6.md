## 打破规则的缘由

#### ▶[上一节](5.md)

经验丰富的 DDD 实践者有时会决定在单个事务中持久化对多个`Aggregate`实例的修改，但此举必须具备充分的合理性。
可能的缘由有哪些？
本文将阐述四点，实际应用中你或许还会遇到其他情况。

### 缘由一：用户界面操作便捷性

为提升操作便捷性，部分用户界面会允许用户一次性为多个对象定义通用属性，从而批量创建对象。
例如，团队成员常会有批量创建多个待办项的需求。
这类界面会让用户在一个区域填写所有待办项的通用属性 (properties)，再逐一补充每个待办项的少量差异化属性 (properties)，避免重复操作。
所有新待办项随即被一起计划（创建）：

```java
public class ProductBacklogItemService ... {
    ...
    @Transactional
    public void planBatchOfProductBacklogItems(
        String aTenantId, String productId,
        BacklogItemDescription[] aDescriptions) {

        Product product =
            productRepository.productOfId(
                new TenantId(aTenantId),
                new ProductId(productId));

        for (BacklogItemDescription desc : aDescriptions) {
            BacklogItem plannedBacklogItem =
                product.planBacklogItem(
                    desc.summary(),
                    desc.category(),
                    BacklogItemType.valueOf(
                        desc.backlogItemType()),
                    StoryPoints.valueOf(
                        desc.storyPoints()));

            backlogItemRepository.add(plannedBacklogItem);
        }
    }
    ...
}
```

这是否会给不变量的管理带来问题？
本场景下并不会，因为无论逐个创建还是批量创建这些对象，结果并无差异。
被实例化的对象均为完整的`Aggregates`，各自维护自身的不变量。
因此，若从语义上看，一次性批量创建多个`Aggregate`实例与重复逐个创建并无区别，那么这便是一个可毫无顾虑打破该经验法则的合理缘由。

### 缘由二：缺乏相关技术机制

实现最终一致性，需要依托某种带外处理能力，比如消息通信、定时器或后台线程。
倘若你所参与的项目，并未配备任何此类机制，该如何处理？
尽管多数人会认为这种情况不合常理，但我确实遇到过这样的技术限制。
当项目既无消息通信机制、无后台定时器，也无自研的线程处理能力时，我们又能有什么办法？

若稍不留意，这种情况便可能导致我们重新陷入大型`Aggregates`的设计误区。
尽管这样做看似遵循了单事务规则，但正如前文所述，这同样会造成性能下降，还会限制系统的可扩展性。
为避免该问题，我们或许可以彻底重构系统中的`Aggregates`，让领域模型来解决当前面临的难题。
我们此前也考虑过一种情况：项目的需求规格可能被严格限定，使得我们几乎没有空间去探讨那些此前未曾设想过的领域概念。
这并非 DDD 的应有做法，但实际工作中确有此类情况发生。
有时，客观条件不允许我们通过合理调整建模环境来创造有利条件。
在这种情况下，项目的实际情况可能会迫使我们在单个事务中修改两个及以上的`Aggregate`聚合实例。
尽管从表面来看，这样的决定似乎理所应当，但切不可草率做出。

|牛仔逻辑||
|------|---:|
|AJ：“如果你觉得规则就是用来打破的，那你最好认识一位靠谱的维修师傅。”|<img src="../img/cbl.1.png" width="60%" />|

不妨考虑另一项可能进一步支撑偏离该规则的因素：*用户-聚合亲和性 (user-aggregate affinity)* 。
业务工作流是否存在这样的特征，任意时刻都仅有一名用户聚焦于一组`Aggregate`实例？
确保用户-聚合亲和性，能让在单个事务中修改多个`Aggregate`实例的决策更具合理性，因为这一特征有助于防止不变量被破坏和事务冲突的发生。
即便具备用户-聚合亲和性，在极少数情况下，用户仍可能遭遇并发冲突，
但乐观并发控制机制仍能为每个`Aggregate`提供保护。
无论如何，并发冲突在任何系统中都有可能发生，在缺乏用户-聚合亲和性的情况下，冲突发生的频率还会更高。
此外，若并发冲突的出现频率极低，其恢复操作也会十分简单。
因此，当设计工作受客观条件所迫时，有时在单个事务中修改多个`Aggregate`实例也能取得良好的效果。

### 缘由三：全局事务

另一个需要考量的影响因素是遗留技术与企业政策的制约。
其中一种情况便是，系统必须严格遵循全局两阶段提交事务的使用规范。
这种要求往往难以抗拒，至少在短期内是如此。

即便必须使用全局事务，在所属的`Bounded Context`中，你也未必需要一次性修改多个`Aggregate`实例。
若能避免此种操作，至少可以有效减少`Core Domain`中的事务冲突，同时在能力范围内切实遵守`Aggregates`的设计规则。
全局事务的弊端在于，相较于摒弃两阶段提交及附带的即时一致性所能实现的效果，采用全局事务的系统其可扩展性大概率会大打折扣。

### 缘由四：查询性能

在某些场景下，直接持有对其他`Aggregates`的对象引用会是更优选择，
这种方式可用于缓解`Repository`的查询性能问题。
但在做出该选择时，必须结合数据潜在规模及整体性能的取舍影响进行审慎权衡。
本章后续将给出一个打破按标识引用规则的具体实例。

### 恪守规则

在企业实际环境中，你可能会因用户界面的设计要求、技术限制、严苛的制度规定或其他因素，不得不做出一些妥协。
当然，我们绝非刻意为打破`Aggregate`设计的经验法则寻找借口。
从长远来看，恪守这些规则终将为项目带来裨益：
我们能在必要的场景下保障数据一致性，同时为系统实现高性能运行和高可扩展性提供支撑。

#### ▶[下一节](7.md)
