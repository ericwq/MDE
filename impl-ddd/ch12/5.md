## 类型层次结构

#### ▶[上一节](4.md)

在使用面向对象语言开发领域模型时，人们很容易想要利用继承来创建类型层次结构。
我们可能会认为这是一个将默认状态和行为放在基类中，然后通过子类进行扩展的机会。
为什么不呢？这似乎是一种避免重复代码的完美方式。

创建具有共同祖先、但彼此独立且拥有独立`Repository`的`Aggregates`，与创建具有相同祖先、共享单个`Repository`的`Aggregates`，是两种不同的继承用法。
因此，本节不讨论单一领域模型中所有`Aggregate`类型通过扩展`Layer Supertype` [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] 来提供领域级通用状态和/或行为的场景。<sup>[7](#7)</sup>

相反，这里我所指的是创建数量相对较少的`Aggregate`类型，他们都继承自一个通用的、特定于领域的超类。
设计这类`Aggregates`的目的，是形成一个由紧密相关的类型构成的层次结构，这些类型具备可互换的多态特性。
这类层次结构会使用单个`Repository`来存储和检索不同子类型的实例，这是因为客户端应当能够互换地使用这些实例，而且在大多数情况下（甚至几乎所有情况下），客户端都无需知晓自己在特定时刻处理的是哪个具体的子类。
这一点也恰好体现了`Liskov Substitution Principle` (LSP) [[Liskov](../bibli.md#liskov)] 。

下面我来解释一下。
假设你的业务依赖外部企业来提供各类服务，并且你需要对这些关系进行建模。
你决定创建一个通用的抽象基类 ServiceProvider，但出于某些合理原因，你需要将其划分为不同的具体类型，因为它们各自提供的服务既有共性，又存在显著差异。
你可能会有 WarbleServiceProvider 和 WonkleServiceProvider。
你设计这些类型，以便能够以通用的方式来安排服务请求：

```java
// client of domain model
serviceProviderRepository.providerOf(id)
        .scheduleService(date, description);
```

在这一背景下，很明显，创建特定于领域的`Aggregate`类型层次结构，在许多业务领域中的实用价值可能十分有限。
原因如下：
正如前文所演示的，大多数情况下，这个共享的`Repository`会被设计成包含若干查询方法（finder methods），这些方法用于检索任意子类的实例。
这意味着，这些查询方法返回的对象实例，会是通用超类的类型，在本文这个例子中，就是 ServiceProvider ，而非具体子类 WarbleServiceProvider 和 WonkleServiceProvider 的实例。
我们不妨设想一下：如果查询方法被设计为返回具体的子类类型，会出现什么问题？
客户端必须事先知晓，聚合的哪些唯一标识或其他描述性属性，能够对应到特定类型的实例。
否则，要么会出现查询不到匹配结果的情况，要么会在查询返回了类型不匹配的实例时，抛出 ClassCastException。
即便你能设计出一套完善的方案，来精准查询到对应类型的实例，考虑到这些聚合无法完全按照 LSP 进行设计，客户端仍然必须知晓，哪些子类能够执行哪些独特的、有差异的操作。

要解决第一个通过唯一标识区分类型的问题，你或许会认为，将`Aggregates`类型信息作为鉴别符编码到唯一标识的结构中，就能安全地识别实例了。
你确实可以这么做，但这同时也会带来另外两个新问题：一是客户端必须承担起解析唯一标识并将其映射到对应类型的责任；二是会让客户端与按类型划分的特定操作产生耦合。
这最终会导致客户端出现如下这类类型依赖问题：

```java
// client of domain model
if (id.identifiesWarble()) {
    serviceProviderRepository.warbleOf(id)
            .scheduleWarbleService(date, warbleDescription);
} else if (id.identifiesWonkle()) {
    serviceProviderRepository.wonkleOf(id)
            .scheduleWonkleService(date, wonkleDescription);
} ...
```

如果这类交互成为常态而非特例，这就意味着代码存在代码异味。
诚然，如果创建这种层次结构带来的收益十分显著，那么像这样罕见的一次性使用场景，或许是一种值得的权衡。
不过，在这个虚构的示例中，更审慎地设计隐含的 ServiceDescription 类型，同时优化 scheduleService() 方法的内部实现，或许就足以满足需求了。
否则，我们就不得不思考：如果给每个类型分配独立的`Repository`，能否从继承的使用中获得一些收益？
在只需要两个或少数几个此类具体子类的情况下，最佳选择或许是为它们创建独立的`Repository`。
而当具体子类的数量增加到数个甚至更多，且其中大多数都能完全互换使用 (LSP) 时，让它们共享一个通用`Repository`才是值得的。

绝大多数情况下，这类问题完全可以通过将类型描述信息设计为`Aggregate`的一个 property（而非包含在唯一标识中）来避免。
具体可参见 [Value Objects (6)](../ch6/0.md) 中关于标准类型 (Standard Types) 的相关讨论。
通过这种方式，单个`Aggregate`类型就可以在内部基于显式确定的标准类型，实现不同的行为逻辑。
借助显式的标准类型，我们可以只创建一个具体的 ServiceProvider `Aggregate`，并将其 scheduleService() 方法设计为根据自身类型进行分发处理。
为了避免客户端受到基于类型的决策逻辑的影响，我们需要确保这类内部逻辑不会泄露给客户端。
相反，scheduleService() 以及 ServiceProvider 的其他相关方法，会妥善封装这类特定于领域的决策逻辑，具体实现示例如下：

```java
public class ServiceProvider {
    private ServiceType type;
    ...
    public void scheduleService(
            Date aDate,
            ServiceDescription aDescription) {
        if (type.isWarble()) {
            this.scheduleWarbleService(aDate, aDescription);
        } else if (type.isWonkle()) {
            this.scheduleWonkleService(aDate, aDescription);
        } else {
            this.scheduleCommonService(aDate, aDescription);
        }
    }
    ...
}
```

如果内部分发逻辑变得杂乱，我们随时可以设计另一个更精简的层次结构来处理。
事实上，如果你喜欢这种方式，标准类型本身就可以被设计成`State` [[Gamma et al.](../bibli.md#gamma-et-al)] 。
在这种情况下，不同的类型会实现各自的专属行为。
当然，这也意味着我们只需要一个 ServiceProviderRepository ，这既满足了在单个`Repository`中存储不同类型的需求，也支持通过通用行为来使用它们。

这种情况也可以通过使用基于角色的接口来规避。
这里我们可以设计一个 SchedulableService 接口，让多个`Aggregate`类型都去实现它。
具体可参见 [Entities (5)](../ch5/0.md) 中关于角色与职责的相关讨论。
即便使用了继承，`Aggregate`的多态行为通常也可以通过精心设计，避免向客户端暴露任何特殊情况。

#### ▶[下一节](6.md)

---

#### 7
我在 [Entities (5)](../ch5/0.md) 和 [Value Objects (6)](../ch6/0.md) 的设计中讨论了使用`Layer Supertype`的好处。请参见相应章节。
