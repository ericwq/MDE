## 面向集合的`Repositories`

#### ▶[上一节](0.md)

我们可以将面向集合的设计视为一种传统方案，因为它严格遵循了 DDD 模式原始定义中的核心思想。
这类`Repositories`与集合对象极为相似，至少会模拟集合的部分标准接口。
在设计这类`Repository`的接口时，你需要做到完全不透露任何底层持久化机制的痕迹，同时避免出现任何将数据保存或持久化到存储介质的相关概念。

由于这种设计方案对底层持久化机制有一些特定的能力要求，因此它未必能满足你的项目需求。
如果你的持久化机制阻碍或限制了你从集合视角进行仓储设计，可参阅接下来的小节内容。
我会详细阐述在哪些场景下，面向集合的设计能发挥出最佳效果。
而为了讲清楚这一点，我需要先铺垫一些基础背景知识。

我们先思考一下标准集合的工作机制。
在 Java、C# 或绝大多数其他面向对象语言中，对象被添加到集合后，会一直存在于集合中，直到被主动移除为止。
要让集合感知到其内部对象的变更，你无需执行任何特殊操作，只需从集合中获取某个特定对象的引用，然后调用该对象自身的方法来修改它的内部状态即可。
此时，该对象仍然被集合持有，只是其内部状态已经与修改前不同了。

我们通过几个示例来更深入地理解这一点。
下面以 java.util.Collection 为例，展示它的部分标准接口：

```java
package java.util;
public interface Collection ... {
    public boolean add(Object o);
    public boolean addAll(Collection c);
    public boolean remove(Object o);
    public boolean removeAll(Collection c);
    ...
}
```

如果我们想往集合中添加一个对象，调用 add() 方法即可。
如果想移除这个对象，只需将该对象的引用传入 remove() 方法即可。
下面的测试代码基于一个新实例化的、能够存储 Calendar 实例的集合（集合类型不限）：

```java
assertTrue(calendarCollection.add(calendar));

assertEquals(1, calendarCollection.size());

assertTrue(calendarCollection.remove(calendar));

assertEquals(0, calendarCollection.size());
```

操作十分简单。
java.util.Set 这一特殊的集合接口及其实现类 java.util.HashSet ，正是`Repository`所模仿的集合类型。
添加至 Set 的每个对象都必须保证唯一性。
若尝试向 Set 中添加已存在的对象，此次添加会执行失败，因为该对象已被集合包含。
因此，完全无需重复添加同一个对象，即便你以为再次添加能将对象自身的状态修改进行持久化。
以下测试断言可证明，重复添加同一个对象不会产生任何效果，既无任何正面作用，也无任何负面影响。

```java
Set<Calendar> calendarSet = new HashSet<Calendar>();

assertTrue(calendarSet.add(calendar));

assertEquals(1, calendarSet.size());

assertFalse(calendarSet.add(calendar));

assertEquals(1, calendarSet.size());
```

所有这些断言都能成功通过，因为尽管同一个 Calendar 实例被添加了两次，但第二次添加该对象的尝试并不会改变 Set 集合的状态。
这一点同样适用于采用面向集合设计的`Repository`。
如果我们将`Aggregate`实例 calendar 添加到一个面向集合设计的 CalendarRepository 中，重复添加 calendar 也不会产生任何不良影响。
每个`Aggregate`都拥有一个与 [Root Entity (5,10)](../ch10/0.md) 相关联的全局唯一标识。
正是这个唯一标识，使得这种模仿 Set 集合的`Repository`能够防止同一个`Aggregate`实例被重复添加。

理解`Repository`应当模仿的集合类型，即 Set 集合，这一点至关重要。
无论采用何种特定持久化机制作为底层实现，你都绝不能允许同一个对象的实例被重复添加两次。

另一个核心要点是：对于`Repository`中已持有的、经过修改的对象，你无需对其进行 "重新保存"。
我们再来思考一下如何修改一个被集合持有的对象。
实际上，这个过程非常简单。
你只需从集合中获取想要修改的对象的引用，然后通过调用一个命令方法，让该对象执行某种状态转换行为即可。

---
➜**面向集合仓储的核心要点**

`Repository`应当模仿 Set 集合的特性。
无论采用何种特定持久化机制作为底层实现，都不得允许同一个对象的实例被重复添加两次。
此外，当从`Repository`中检索对象并对其进行修改后，无需将这些对象 "重新保存" 到`Repository`中。

---

为了便于说明，假设我们继承（创建子类）标准的 java.util.HashSet ，并在这个新类型中添加一个方法，该方法允许我们通过唯一标识查找特定的对象实例。
我们会给这个子类起一个能表明它`Repository`身份的名称，但本质上它只是一个内存中的 HashSet 而已。

```java
public class CalendarRepository extends HashSet {
    private Set<CalendarId, Calendar> calendars;

    public CalendarRepository() {
        this.calendars = new HashSet<CalendarId, Calendar>();
    }

    public void add(Calendar aCalendar) {
        this.calendars.add(aCalendar.calendarId(), aCalendar);
    }

    public Calendar findCalendar(CalendarId aCalendarId) {
        return this.calendars.get(aCalendarId);
    }
}
```

我们在创建常规`Repository`时，通常不会通过继承 HashSet 来实现。
此处这样做仅仅是为了举例说明。
那么，回到这个示例中来。现在，我们可以向这个专用的 Set 集合中添加一个 Calendar 实例，后续再查找该实例并让它自行完成状态修改。

```java
CalendarId calendarId = new CalendarId(...);
Calendar calendar =
    new Calendar(calendarId, "Project Calendar", ...);
CalendarRepository calendarRepository = new CalendarRepository();
calendarRepository.add(calendar);

// later ...

Calendar calendarToRename =
    calendarRepository.findCalendar(calendarId);

calendarToRename.rename("CollabOvation Project Calendar");

// even later still ...

Calendar calendarThatWasRenamed =
    calendarRepository.findCalendar(calendarId);
assertEquals("CollabOvation Project Calendar",
    calendarThatWasRenamed.name());
```

请注意，由 calendarToRename 引用的 Calendar 实例，是通过调用其自身的重命名方法来完成修改的。
在重命名操作执行完毕后，即便过了很长时间，该实例的名称仍会保持修改后的状态。
这一过程完全无需请求 HashSet 子类 CalendarRepository 保存对 Calendar 实例所做的变更，这么做本身也毫无意义。
CalendarRepository 并没有 save() 方法，因为根本不需要这样一个方法。
我们没有任何理由去保存 calendarToRename 所引用的 Calendar 实例的变更，原因在于该集合仍然持有被修改对象的引用，而所有修改都是直接在该对象上完成的。

那么，核心要点在于：传统的面向集合`Repository`会真正模仿集合的特性，其公共接口不会向客户端暴露任何持久化机制的相关细节。
因此，我们的目标是设计并实现这样一种面向集合`Repository`，它既要具备 HashSet 所展现出的那些特性，又要将底层存储替换为持久化数据存储介质。

可想而知，这对底层持久化机制有一些特定的能力要求。
<ins>该持久化机制必须以某种方式，支持对其管理的每个持久化对象所做的变更进行隐式跟踪</ins>。
这一点可以通过多种方式实现，其中包括以下两种：

1. **隐式读时复制 (Implicit Copy-on-Read)** [[Keith & Stafford](../bibli.md#keith--stafford)] ：持久化机制在从数据存储重新构建每个持久对象时会隐式地复制它，并在提交时将其私有副本与客户端的副本进行比较。
具体来说，当你请求持久化机制从数据存储读取一个对象时，它会执行该操作，并立即复制整个对象（不包括任何延迟加载的部分，这些部分也可能之后被加载和复制）。
当通过持久化机制创建的事务被提交时，持久化机制会通过比较已加载（或重新附加）的对象来检查它们是否被修改。
所有检测到变化的对象都会被刷新到数据存储中。


2. **隐式写时复制 (Implicit Copy-on-Write)** [[Keith & Stafford](../bibli.md#keith--stafford)] ：持久化机制通过代理管理所有加载的持久对象。
当每个对象从数据存储加载时，会创建一个薄代理并交给客户端。
客户端在无意识中调用代理对象的行为，该行为将该行为反映到真实对象上。
当代理首次收到方法调用时，它会复制该受管理对象。
代理会追踪对被管理对象状态的更改，并将其标记为脏状态。
当通过持久化机制创建的事务提交时，会检查脏对象，并将所有此类对象刷新到数据存储。

这两种方案的优势与差异可能各有不同，倘若你的系统会因二选一而承受负面后果，那么你应当谨慎地评估它们。
当然，你也可以选择直接沿用自己偏好的方案，而不做充分的调研准备，但这或许并非最稳妥的决策。

不过，这两种方案的总体优势是一致的：持久化对象的变更会被隐式跟踪，无需客户端明确知晓相关机制，也无需客户端进行额外干预，就能让持久化机制感知到这些变更。
核心要点在于，使用像 Hibernate 这样具备该特性的持久化机制， *能够让你顺利实现传统的、面向集合的`Repository`* 。

话虽如此，即便你拥有使用 Hibernate 这类支持隐式复制变更跟踪的持久化机制的自主权，这种机制也可能并不合心意或并不适用。
如果你的需求要求系统具备极高的性能，且在任何给定时间都有大量对象驻留在内存中，那么这类机制会在内存和执行效率两方面带来不必要的额外开销。
你必须谨慎地考虑并决定这种机制是否适合你的项目。
当然，在很多业务领域中，Hibernate 都是切实有效的。
因此，不要将我的提醒视为试图将其列为禁忌的言论。
使用任何工具都应充分认识到其中的利弊权衡。

|牛仔逻辑||
|:---|---:|
|LB：“当我的狗得了蛔虫时，兽医开了一些栓剂。”|<img src="../img/cbl.3.png" width="50%"/>|

这可能会让你考虑使用一款性能更优、且能够支持面向集合`Repository`的对象关系映射工具。
Oracle 的 TopLink 及其最相近的衍生工具 EclipseLink 就是这样的选择。
TopLink 提供了工作单元（Unit of Work）机制，它与 Hibernate 的 Session 机制并非完全不同。
不过，TopLink 的工作单元并不会执行隐式的读时复制（Copy-on-Read）。
而是采用了显式的写前复制 (Explicit Copy-before-Write) ，出自 [[Keith & Stafford](../bibli.md#keith--stafford)] 。
这里的 *显式（explicit）* 意味着客户端必须先通知工作单元，即将对对象进行变更操作。
这就使得工作单元有机会克隆指定的领域对象，为后续的修改操作做准备（TopLink 中将其称为 *编辑 (edits)* ，本章后续会对此展开讨论）。
核心要点在于，TopLink 仅会在必要时才占用内存资源。

### Hibernate 实现方案

创建任一种面向类型的`Repository`都包含两个核心步骤：一是需要定义一个公共接口，二是至少提供一个实现类。

具体到面向集合的设计场景，第一步你要定义一个模仿集合特性的接口。
第二步则是提供一个实现类，用于适配底层的主存储机制（例如 Hibernate）的使用。
这个接口与集合类似，通常会包含一些通用方法，如下例所示：

```java
package com.saasovation.collaboration.domain.model.calendar;

public interface CalendarEntryRepository  {
    public void add(CalendarEntry aCalendarEntry);
    public void addAll(
            Collection<CalendarEntry> aCalendarEntryCollection);
    public void remove(CalendarEntry aCalendarEntry);
    public void removeAll(
            Collection<CalendarEntry> aCalendarEntryCollection);
    ...
}
```

将接口定义放在与它所存储的`Aggregate`类型相同的 [Module (9)](../ch9/0.md) 中。
在这个例子中，CalendarEntryRepository 接口被放置在与 CalendarEntry 相同的模块（Java 包）中。
而实现类则要放在单独的包中，这一点我们后续会详细讨论。

CalendarEntryRepository 接口拥有与集合（例如标准的 java.util.Collection）提供的方法极为相似的方法。
可以使用 add() 方法向该`Repository`中添加一个新的 CalendarEntry 实例。
使用 addAll() 方法则可以添加多个新实例。
一旦这些实例被添加完成，它们就会被持久化到某种数据存储介质中，并且从此时起，就可以通过唯一标识从该存储介质中检索到这些实例。
与上述添加方法相对应的是 remove() 和 removeAll() 方法，这两个方法允许从该集合中移除一个或多个实例。

我个人并不希望这些方法像完整的集合那样返回布尔值结果。
这是因为在某些情况下，添加类操作返回 true 并不能保证操作一定成功。
即便返回 true，该操作最终是否生效，仍取决于数据存储介质上的事务是否能提交成功。
因此，对于`Repository`而言，void 可能是更准确的返回类型。

在某些场景下，在单个事务中添加和/或移除多个聚合实例可能并不合适。
当你的领域中出现这类情况时，就不要提供 addAll() 和 removeAll() 这两个方法。
不过，这两个方法的存在仅仅是为了方便使用。
客户端完全可以自行遍历集合，通过循环多次调用 add() 或 remove() 方法来实现批量操作。
因此，移除 addAll() 和 removeAll() 方法，仅能作为一种策略的象征性体现，这种策略无法通过设计本身得到有效强制执行，除非你额外添加一种检测机制，用于识别单个事务中是否存在批量添加或移除对象的操作。
而要实现这一点，很可能需要为每一个事务都实例化一个全新的`Repository`实例，这无疑是一种成本可能极高的方案。
关于这一点，我不再做进一步探讨。

部分`Aggregate`类型的实例，在常规应用用例中绝对不应当被删除。
即便这些实例在应用中已经失去使用价值，为了满足引用完整性需求和 / 或历史留存需求，仍可能需要长期保留它们。
从引用完整性的角度而言，删除某些对象实际上可能极为困难，甚至完全无法实现。
从业务视角来看，删除某些对象可能是不明智、不妥当的，甚至是违反相关规定的。
在这些场景下，你可以选择仅将该`Aggregate`实例标记为 *disabled, unusable* ，或者以其他符合特定领域业务规则的方式，对其进行 *逻辑删除* 。
若是采用这种方式，你既可以决定在`Repository`的公共接口中不包含任何删除相关方法，也可以选择实现删除方法，但让该方法仅承担将`Aggregate`实例设置为不可用状态的功能。
除此之外，你还可以通过代码审查来阻止对象被彻底删除，仔细检查客户端代码，确保不存在任何调用删除操作的场景。
这是一个需要深思熟虑的决策，但你或许会发现，完全禁止删除操作会更为简便。
毕竟，公共接口中的任何方法通常都会被视为可调用的接口。
如果在逻辑上不允许删除，却将删除操作公开提供给外部调用，那么你或许应该考虑实现逻辑删除，而非物理删除。

`Repository`接口的另一项重要内容是查询方法（finder methods）的定义。

```java
public interface CalendarEntryRepository  {
    ...
    public CalendarEntry calendarEntryOfId(
            Tenant aTenant,
            CalendarEntryId aCalendarEntryId);

    public Collection<CalendarEntry> calendarEntriesOfCalendar(
            Tenant aTenant,
            CalendarId aCalendarId);

    public Collection<CalendarEntry> overlappingCalendarEntries(
            Tenant aTenant,
            CalendarId aCalendarId,
            TimeSpan aTimeSpan);
}
```

第一个方法定义 calendarEntryOfId()，允许你通过唯一标识检索 CalendarEntry `Aggregate`的特定实例。
该方法使用了一种显式的标识类型，即 CalendarEntryId。
第二个方法定义 calendarEntriesOfCalendar()，允许你通过某个特定 Calendar 的唯一标识，检索该 Calendar 对应的所有 CalendarEntry 实例的集合。
最后，第三个查询方法定义 overlappingCalendarEntries()，会返回某个特定 Calendar 中，落在指定 TimeSpan 内的所有 CalendarEntry 实例的集合。
值得注意的是，该方法专门用于检索在某一段连续的日期和时间范围内已被安排好的事项。

最后，你可能会好奇，CalendarEntry 的全局唯一标识是如何分配的。这一点也可以由`Repository`便捷地提供。

```java
public interface CalendarEntryRepository  {
    public CalendarEntryId nextIdentity();
    ...
}
```

负责实例化新 CalendarEntry 实例的所有代码，都会调用 nextIdentity() 方法来获取一个新的 CalendarEntryId 实例。

```java
CalendarEntry calendarEntry =
    new CalendarEntry(tenant, calendarId,
        calendarEntryRepository.nextIdentity(),
        owner, subject, description, timeSpan, alarm,
        repetition, location, invitees);
```

有关标识创建技术、领域专用标识与代理标识的使用，以及合理把握标识分配时机的重要性，详情请参阅 [Entities (5)](../ch5/0.md) 的详尽论述。

现在，我们来看看这个传统`Repository`的实现类。
关于该类应放置在哪个模块中，有几种可选方案。
有些人喜欢将其放在`Aggregate`与`Repository`模块直接下级的一个模块（Java 包）中。在本例中，这意味着

```java
package com.saasovation.collaboration.domain.model.calendar.impl;

public class HibernateCalendarEntryRepository
    implements CalendarEntryRepository  {
    ...
}
```

将该类放置在此处，能够让你在`Domain Layer`中管理该实现，同时将其归置在一个专门用于存放实现类的包中。
通过这种方式，你可以将领域概念与那些直接处理持久化操作的代码进行清晰的分离。
在 Java 项目中，这种在命名清晰的包中声明接口，并将其实现类放置在该包下一个名为 impl 的子包中的风格被广泛采用。
不过，在本次`Collaboration Context`的实践中，团队选择将所有技术实现类都放置在`Infrastructure Layer`中。

```java
package com.saasovation.collaboration.infrastructure.persistence;
public class HibernateCalendarEntryRepository
        implements CalendarEntryRepository  {
    ...
}
```

这一做法运用了 [Dependency Inversion Principle (4)](../ch4/0.md)，简称 DIP ，对与基础设施相关的关注点进行分层处理。
从逻辑层面而言，`Infrastructure Layer`位于所有其他层级之上，使得依赖引用呈现单向向下的趋势，即仅由`Infrastructure`指向`Domain Layer`。

HibernateCalendarEntryRepository 类是一个已注册的 Spring Bean。
该类拥有一个无参构造函数，并且注入了另一个基础设施 Bean 对象的依赖。

```java
import com.saasovation.collaboration.infrastructure⏎
        .persistence.SpringHibernateSessionProvider;

public class HibernateCalendarEntryRepository
        implements CalendarEntryRepository  {

    public HibernateCalendarEntryRepository() {
        super();
    }
    ...
    private SpringHibernateSessionProvider sessionProvider;

    public void setSessionProvider(
            SpringHibernateSessionProvider aSessionProvider) {
        this.sessionProvider = aSessionProvider;
    }

    private org.hibernate.Session session() {
        return this.sessionProvider.session();
    }
}
```

SpringHibernateSessionProvider 类同样存放于`Infrastructure Layer`的 com.saasovation.collaboration.infrastructure.persistence 模块中，并且会被注入到每个基于 Hibernate 实现的`Repository`中。
所有需要使用 Hibernate Session 对象的方法，都会自行调用 session() 方法来获取该对象。
session() 方法通过依赖注入的 sessionProvider 实例，获取与线程绑定的 Session 实例（本章后续会对此进行介绍）。

add()、addAll()、remove() 和 removeAll() 方法的实现如下：

```java
package com.saasovation.collaboration.infrastructure.persistence;

public class HibernateCalendarEntryRepository
        implements CalendarEntryRepository  {
    ...
    @Override
    public void add(CalendarEntry aCalendarEntry) {
        try {
            this.session().saveOrUpdate(aCalendarEntry);
        } catch (ConstraintViolationException e) {
            throw new IllegalStateException(
                    "CalendarEntry is not unique.", e);
        }
    }

    @Override
    public void addAll(
            Collection<CalendarEntry> aCalendarEntryCollection) {
        try {
            for (CalendarEntry instance : aCalendarEntryCollection) {
                this.session().saveOrUpdate(instance);
            }
        } catch (ConstraintViolationException e) {
            throw new IllegalStateException(
                    "CalendarEntry is not unique.", e);
        }
    }

    @Override
    public void remove(CalendarEntry aCalendarEntry) {
        this.session().delete(aCalendarEntry);
    }

    @Override
    public void removeAll(
            Collection<CalendarEntry> aCalendarEntryCollection) {
        for (CalendarEntry instance : aCalendarEntryCollection) {
            this.session().delete(instance);
        }
    }
    ...
}

```
这些方法的实现相当简洁。
每个方法都会自行调用 session() 方法来获取 Hibernate Session 实例（正如前文所述）。
或许值得注意的是，add() 和 addAll() 方法使用了 Session 的 saveOrUpdate() 方法。
这进一步支持了类似 Set 集合的添加行为。
如果客户端恰好多次添加同一个 CalendarEntry 实例，saveOrUpdate() 方法的行为会让这种重复添加表现为一种无害的空操作。
事实上，从 Hibernate 3 版本开始，任何形式的更新操作在特定场景下都是空操作，正如前文所提及的，对象状态的修改会被 Hibernate 隐式跟踪。
因此，除非这两个方法添加的对象是全新的实例，否则该操作不会产生任何实际效果。

添加操作可能会引发 ConstraintViolationException 异常。
我们不会让 Hibernate 相关异常直接暴露给客户端，而是会捕获这些异常，并将其包装为对客户端更友好的 IllegalStateException 异常抛出。
我们也可以定义领域专用异常并抛出这类异常，这一点由各个项目团队自行决定。
核心要点在于，既然我们已经费心对底层持久化框架的实现细节进行了抽象封装，就希望将客户端与所有此类细节（包括异常在内）隔离开来。

remove() 和 removeAll() 方法相当简洁，它们只需使用 Session 的 delete() 方法，即可完成从底层数据存储中移除对象的操作。
关于移除使用一对一映射的`Aggregate`，还有一个额外的细节需要注意，这在`Identity and Access Context`的某个场景中是适用的。
由于无法在此类关联关系上进行级联变更，你需要显式删除该关联关系两端的所有对象：

```java
package com.saasovation.identityaccess.infrastructure.persistence;
public class HibernateUserRepository implements UserRepository  {
    ...
    @Override
    public void remove(User aUser) {
        this.session().delete(aUser.person());
        this.session().delete(aUser);
    }

    @Override
    public void removeAll(Collection<User> aUserCollection) {
        for (User instance : aUserCollection) {
            this.session().delete(instance.person());
            this.session().delete(instance);
        }
    }
    ...
}
```

必须先删除内部的 Person 对象，然后再删除 User `Aggregate Root`。如果不删除内部的 Person 对象，它将在对应的数据库表中成为孤立记录。
通常来说，这是避免使用一对一关联的一个充分理由，建议改用受约束的单向 (constrained singular) 一对多关联 替代。
不过，我特意选择实现双向一对一关联，目的是为了演示如何处理这类较为复杂的映射关系。

需要注意的是，处理此类场景存在多种被推崇的方法。
有些人可能会选择依赖 ORM 生命周期事件来实现子对象的级联删除。
而我特意避开了这类方法，因为我强烈反对`Aggregate`管理的持久化，同时坚定倡导仅由`Repository`负责的持久化。
关于这两种方式的争论向来激烈且无休无止，令人厌烦。
你应当在充分了解相关信息后再做出选择，但需要明白的是，作为一条经验法则，DDD 专家通常会避免使用`Aggregate`管理的持久化。

现在，我们回到 HibernateCalendarEntryRepository 类，来看它的查询方法实现：

```java
public class HibernateCalendarEntryRepository
        implements CalendarEntryRepository {
    ...
    @Override
    @SuppressWarnings("unchecked")
    public Collection<CalendarEntry> overlappingCalendarEntries(
        Tenant aTenant, CalendarId aCalendarId, TimeSpan aTimeSpan) {
        Query query =
            this.session().createQuery(
                "from CalendarEntry as _obj_ " +
                "where _obj_.tenant = :tenant and " +
                  "_obj_.calendarId = :calendarId and " +
                  "((_obj_.repetition.timeSpan.begins between " +
                      ":tsb and :tse) or " +
                  " (_obj_.repetition.timeSpan.ends between " +
                      ":tsb and :tse))");

        query.setParameter("tenant", aTenant);
        query.setParameter("calendarId", aCalendarId);
        query.setParameter("tsb", aTimeSpan.begins(), Hibernate.DATE);
        query.setParameter("tse", aTimeSpan.ends(), Hibernate.DATE);

        return (Collection<CalendarEntry>) query.list();
    }

    @Override
    public CalendarEntry calendarEntryOfId(
            Tenant aTenant,
            CalendarEntryId aCalendarEntryId) {
        Query query =
            this.session().createQuery(
               "from CalendarEntry as _obj_ " +
               "where _obj_.tenant = ? and _obj_.calendarEntryId = ?");

        query.setParameter(0, aTenant);
        query.setParameter(1, aCalendarEntryId);

        return (CalendarEntry) query.uniqueResult();
    }

    @Override
    @SuppressWarnings("unchecked")
    public Collection<CalendarEntry> calendarEntriesOfCalendar(
        Tenant aTenant, CalendarId aCalendarId) {
        Query query =
            this.session().createQuery(
                "from CalendarEntry as _obj_ " +
                "where _obj_.tenant = ? and _obj_.calendarId = ?");

        query.setParameter(0, aTenant);
        query.setParameter(1, aCalendarId);

        return (Collection<CalendarEntry>) query.list();
    }
    ...
}
```

这三个查询方法各自都会通过 Session 创建一个 Query 对象。
与常见的 Hibernate 查询用法一致，团队使用 HQL 来描述查询条件，随后填充对应的参数对象。
接着执行该查询，获取单个唯一结果或对象列表集合。
其中，逻辑相对复杂的查询是 overlappingCalendarEntries()，在这个方法中，我们必须找出所有与指定日期时间范围（即 `TimeSpan`）存在重叠的 CalendarEntry 实例。

最后，我们来看 nextIdentity() 方法的实现：

```java
public class HibernateCalendarEntryRepository
        implements CalendarEntryRepository  {
    ...
    public CalendarEntryId nextIdentity() {
        return new CalendarEntryId(
                UUID.randomUUID().toString().toUpperCase());
    }
    ...
}
```

该具体实现并未使用持久化机制或数据存储来生成唯一标识，而是采用了速度相对较快且可靠性极高的 UUID 生成器。

### TopLink 实现的相关考量

TopLink 同时提供了 Session 和 Unit of Work（工作单元）两种组件。
这一点与 Hibernate 存在一定差异，在 Hibernate 中，Session 本身也兼具工作单元的功能 <sup>[1](#1)</sup>。
我们先来探讨将 `Unit of Work` 与 Session 分离使用的思路，再逐步过渡到如何在`Repository`实现中运用这两者。

如果不借助`Repository`模式进行抽象封装，你会以如下方式使用 TopLink：

```java
Calendar calendar = session.readObject(...);

UnitOfWork unitOfWork = session.acquireUnitOfWork();

Calendar calendarToRename = unitOfWork.registerObject(calendar);

calendarToRename.rename("CollabOvation Project Calendar");

unitOfWork.commit();
```

UnitOfWork 能极大地提升内存和处理能力的使用效率，因为你必须明确告知 UnitOfWork 你打算修改某个对象。
只有在这个时候，框架才会为你的`Aggregate`创建一个克隆对象（或称编辑副本）。
正如前文所示，registerObject() 方法会返回原始 Calendar 实例的一个克隆对象。
而这个被 calendarToRename 引用的克隆对象，才是你需要进行编辑/修改的对象。
当你对该对象进行修改时，TopLink 能够跟踪所有发生的变更。
当调用 UnitOfWork 的 commit() 方法时，所有被修改的对象都会被提交到数据库中 <sup>[2](#2)</sup>。

在 TopLink `Repository`中添加新对象的实现过程相当简便：

```java
    ...
    public void add(Calendar aCalendar) {
        this.unitOfWork().registerNewObject(aCalendar);
    }
    ...
```

调用 registerNewObject() 方法意味着 aCalendar 是一个全新的实例。
如果调用 add() 方法时传入的 aCalendar 实际上是已存在的对象，该方法会强制触发执行失败。
我们也可以在此处使用普通的 registerObject() 方法，这与前文讨论的使用 Hibernate 的 `saveOrUpdate()` 方法效果类似。
无论采用哪种方式，都能满足一个可用的、面向集合的接口的需求。

但当我们需要修改一个已存在的聚合时，仍然需要一种方式来获取它的克隆对象。
关键在于找到一种便捷的方式，将这样的`Aggregate`实例注册到 UnitOfWork 中。
到目前为止，我们的讨论还没有提供一个能实现该功能的`Repository`接口，因为我们一直试图模仿 Set 集合的行为，避免在接口中引入任何与持久化相关的暗示。
尽管如此，我们还是可以通过一种不会让人联想到持久化的方式来实现这一需求。
可以考虑采用以下两种方式之一：

```java
public Calendar editingCopy(Calendar aCalendar);

// or

public void useEditingMode();
```

采用第一种方式时，editingCopy() 方法会获取一个 UnitOfWork，注册传入的 Calendar 实例，获取该实例的克隆对象并将其返回：

```java
    ...
    public Calendar editingCopy(Calendar aCalendar) {
        return (Calendar) this.unitOfWork().registerObject(aCalendar);
    }
    ...
```


这反映了底层 registerObject() 的处理方式。
可以理解，这可能并不理想，但它是一种干净的方法，并不体现持久化的思维方式。

第二种方法是使用 useEditingMode() 将 `Repository` 置于编辑模式。
完成此操作后，所有后续的 finder 方法将自动将它们查询到的所有对象注册到后台的 UnitOfWork，并返回这些对象的克隆副本。
它在某种程度上确实将 `Repository` 锁定用于`Aggregate`的修改。
然而，这也是 `Repositories` 的常用方式，要么只读，要么为修改读取。
它还体现了将 `Repository` 用于具有良好边界的`Aggregate`，这些边界反映了对事务成功的偏向。

对于 TopLink，可以有其他方法来设计面向集合的 `Repository`，但这提供了一些值得考虑的选项。

#### ▶[下一节](2.md)

---

#### 1
我并非以 Hibernate 为参照来评判 TopLink 的价值。
事实上，TopLink 拥有十分悠久的成功历史，早在甲骨文公司因 WebGain 公司经营失败、后续进行 “清仓式收购” 而将该产品收入囊中之前，TopLink 就已经奠定了其市场地位。
Top 是 “The Object People”（对象技术团队）的首字母缩写，这家原始公司打造的这款工具，至今已拥有近二十年经实践验证的成功经验。
在此，我仅仅是在对比这两款工具的工作方式而已。

#### 2
这是基于工作单元未嵌套在父工作单元中的前提而言。
如果该工作单元嵌套在一个父工作单元内部，那么已提交的这个工作单元中的变更，会与它的父工作单元进行合并。
最终，只有最外层的工作单元会被提交至数据库。
