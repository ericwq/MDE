## 额外行为

#### ▶[上一节](2.md)

有时候，在`Repository`接口上提供一些额外行为会非常有用，这超出了前几节介绍的那些典型操作的范畴。
其中一个实用的行为就是返回`Aggregates`集合中所有实例的总数。

你可能会觉得这个方法命名为 count 就可以了。
不过，由于`Repository`应该尽可能地模仿集合的行为，你或许可以考虑使用下面这个方法（来实现该功能）：

```java
public interface CalendarEntryRepository {
    ...
    public int size();
}
```

size() 方法正是标准 java.util.Collection 接口所提供的方法。
当使用 Hibernate 实现这个方法时，代码会是这样的：

```java
public class HibernateCalendarEntryRepository
        implements CalendarEntryRepository  {
    ...
    public int size() {
        Query query =
            this.session().createQuery(
                "select count(*) from CalendarEntry");

        int size = ((Integer) query.uniqueResult()).intValue();

        return size;
    }
}
```

为了满足一些严格的非功能性要求，可能需要在数据存储（包括数据库或网格）中执行其他计算。
如果将数据从存储位置移动到执行业务逻辑的位置太慢，就可能出现这种情况。
相反，你可能需要将代码移动到数据所在的位置。
这可以通过数据库存储过程或数据网格条目处理器 (entry processors) 来实现，比如在 Coherence 中可用的处理器。
然而，这种实现通常最好由 [Domain Services (7)](../ch7/0.md) 来控制，因为它们用于承载无状态的、特定领域的操作。

有时，不直接访问`Aggregate Root`，而是从`Repository`中查询`Aggregate`内部的组成部分，会是一种更优的选择。
这种场景通常出现在：某个`Aggregate`持有大量某类`Entity`的集合，而你只需要获取其中满足特定条件的实例。
当然，这种做法只有在`Aggregate`本身允许通过根导航访问这些内部组成部分时，才具有合理性。
你不应该设计一个`Repository`，去提供那些无法通过根导航访问的`Aggregate`内部部分的查询接口。
这么做会违反`Aggregate`的契约。
我还建议，不要仅仅为了方便客户端使用、作为一种快捷方式，就设计这类`Repository`查询接口。
<ins>我认为，这种方式主要应该用于解决性能问题，也就是当通过根导航访问内部组成部分时，会造成无法接受的性能瓶颈的场景。</ins>
这类用于优化访问的方法，其基本特征和本章前面介绍的其他查询方法（finder）是一致的，不同之处仅在于，它们返回的是`Aggregate`中包含的内部组成部分实例，而非`Aggregate`根`Entity`。
再次强调：使用这种方式时，务必谨慎。

另一个可能影响你设计特殊查找方法的原因是，你系统的某些使用场景在呈现领域数据视图时，可能不会完全遵循单一`Aggregate`类型的轮廓。
它们可能会跨类型，可能只组成一个或多个`Aggregates`的某些部分。
在这种情况下，你可能会选择不在单个事务中查找各种类型的完整`Aggregate`实例，然后再通过编程将它们组合到一个单一的容器，并将该负载容器提供给客户端。
你可能会改为使用所谓的 *用例最优查询* 。
在这种方式下，你对持久化机制指定一个复杂查询，并将结果动态地放入专门设计用于满足该用例需求的值对象 [Value Object (6)](../ch6/0.md) 中。

对于一个`Repository`在某些情况下返回`Value Object`而不是`Aggregate`实例来说，这不应该显得奇怪。
一个提供 size() 方法的`Repository`，会以整数形式回答一个非常简单的值，即它所持有的聚合实例的总数。
一个面向用例的最优查询只是稍微扩展了这个概念，以提供一个稍微复杂一些的`Value`，用以满足更复杂的客户端需求。

如果你发现必须创建许多查找方法来支持在多个`Repositories`上的用例最优查询，这很可能是一种代码异味。
首先，这种情况可能表明你误判了`Aggregate`边界，并且忽略了设计一种或多种不同类型`Aggregates`的机会。
这里的代码异味可能被称为 *`Repository`掩盖了`Aggregate`设计不当* 。

然而，如果你遇到这种情况，并且你的分析表明你的`Aggregate`边界设计合理呢？这可能意味着需要考虑使用 [CQRS (4)](../ch4/0.md) 的必要性。

#### ▶[下一节](4.md)
