## 面向持久化的`Repositories`

#### ▶[上一节](1.md)

当面向集合的`Repositories`风格无法满足需求时，你就需要采用一种面向持久化、基于保存操作的`Repositories`。
当你的持久化机制无法隐式或显式地检测并跟踪对象变更时，就会出现这种情况。
使用内存 [Data Fabric (4)](../ch4/0.md) （也可称为 NoSQL 键值对数据存储，无论其具体名称为何）时，就恰好属于这种场景。
每当你创建一个新的`Aggregate`实例，或者修改一个已存在的`Aggregate`实例时，都必须通过调用 save() 方法或类似的`Repositories`保存方法，将该`Aggregate`存入数据存储中。

即使你使用的对象关系映射工具支持面向集合的风格，在选择面向持久化的方案时，还有另一个需要考量的因素。
试想一下，如果你先设计了面向集合的`Repositories`，之后却决定将关系型数据库替换为键值对存储，会发生什么？
这会在`Application Layer`层引发大量的连锁修改，所有涉及`Aggregate`更新的地方，都必须修改为使用 save() 方法。
同时，你还需要从`Repositories`中移除 add() 和 addAll() 方法，因为这些方法在新的存储方案中已经不再适用。
如果未来更换持久化机制的可能性很大，那么最好在设计之初就考虑采用更灵活的接口。
这种方案的弊端在于，当前的对象关系映射工具可能会让你忽略一些必要的 save() 方法调用，而这些遗漏，只有在后续不再有底层工作单元支撑时，才会暴露出来 <sup>[3](#3)</sup> 。
不过它的优势也十分显著：`Repository`模式能够让你彻底替换底层的持久化机制，且对应用程序本身的影响可能微乎其微。

---
➜**面向持久化`Repositories`的核心要点**

我们必须显式地使用 put() 方法，将新创建的对象和修改后的对象都存入数据存储中，这实际上会替换掉此前与指定键关联的任何值。
使用这类数据存储能够极大地简化`Aggregates`的基本读写操作，正因如此，它们有时也被称为`Aggregate Stores`或`Aggregate-Oriented Database`。

---

当使用 GemFire 或 Oracle Coherence 这类内存数据架构时，其存储底层是一个模仿 java.util.HashMap 实现的内存 Map，其中每个映射元素都被视为一条 *条目 (entry)* 。
类似地，当使用 MongoDB 或 Riak 这类 NoSQL 存储时，对象持久化给人的直观感受是操作一种集合结构，而非关系型数据库中的表、行和列。
这类 NoSQL 存储用于存储键值对，本质上也是一种类似 Map 的存储系统，只不过它将磁盘而非内存作为主要的持久化介质。

尽管这两种持久化机制在很大程度上都模仿了 Map 集合的形式，但遗憾的是，我们必须显式地调用 put() 方法，将新创建的对象和修改后的对象都存入存储中，这实际上会替换掉此前与指定键关联的值。
即便被修改的对象在逻辑上与已存储的对象是同一个，情况也是如此。这是因为这类存储通常不提供工作单元（Unit of Work）来跟踪对象变更，也不支持通过事务界定来控制原子性写入。
相反，每一次 `put()` 和 `putAll()` 调用都代表一个独立的逻辑事务。

使用这两类数据存储能够极大地简化`Aggregates`的基本读写操作。
例如，我们可以看看将这个 Product（`Agile Project Management Context`）添加到 Coherence 数据网格，然后再将其读取回来的过程有多简洁：

```java
cache.put(product.productId(), product);
// later ...
product = cache.get(productId);
```

在这里，Product 实例会通过标准 Java 序列化自动序列化到 Map 中。
不过，这种简洁的接口可能具有一定的迷惑性。
如果你想要实现真正高性能的领域系统，还需要做更多工作。
在未注册自定义序列化提供程序时，Coherence 支持标准 Java 序列化。
但使用标准 Java 序列化通常并非最佳选择，它需要占用更多字节来表示每个对象，且执行性能相对较差 <sup>[4](#4)</sup>。
你肯定不希望购买了高性能的数据网格 (Data Fabric)，却因为低效的序列化方式，减少它能缓存的对象数量，降低整体吞吐量，从而限制其性能。
因此要记住，当使用数据网格 (Data Fabric) 时，系统会引入分布式特性。
这通常会给领域模型设计带来新的考量，即自定义或至少是专用的序列化。
这至少会让你在实现层面做出不同的设计决策。

因此，当你使用 GemFire 或 Coherence 缓存、MongoDB 或 Riak 键值对存储，或是其他类型的 NoSQL 持久化方案时，你很可能需要采用一种快速且紧凑的方式，将`Aggregates`转换为它们的序列化/文档格式，之后再将其转换回对象格式。
诚然，应对这些挑战并非难事。
例如，为要通过 GemFire 或 Coherence 进行持久化的`Aggregate`创建最优序列化方案，其难度并不比为对象关系映射工具创建映射描述更大。
但这并不像直接在 Map 上调用 put() 和 get() 方法那样简单。

接下来，我将演示如何为 Coherence 创建一个面向持久化的`Repository`，之后还会重点介绍一些为 MongoDB 实现同类`Repository`的相关技巧。

### Coherence 实现

与实现面向集合的`Repository`时的做法一致，我们首先定义一个接口，然后再实现该接口。
以下是一个面向持久化的接口，它定义了一系列基于保存操作的方法，用于操作 Oracle Coherence 数据网格：

```java
package com.saasovation.agilepm.domain.model.product;

import java.util.Collection;
import com.saasovation.agilepm.domain.model.tenant.Tenant;

public interface ProductRepository  {
    public ProductId nextIdentity();
    public Collection<Product> allProductsOfTenant(Tenant aTenant);
    public Product productOfId(Tenant aTenant, ProductId aProductId);
    public void remove(Product aProduct);
    public void removeAll(Collection<Product> aProductCollection);
    public void save(Product aProduct);
    public void saveAll(Collection<Product> aProductCollection);
}
```

这个 ProductRepository 与上一节中的 CalendarEntryRepository 并非完全不同，二者的区别仅在于将`Aggregates`实例纳入模拟集合的方式上。
在这个接口中，我们使用的是 save() 和 saveAll() 方法，而非 add() 和 addAll() 方法。
这两种方法在逻辑上实现的功能类似，
主要区别在于客户端对它们的使用方式。
<ins>需要再次强调的是：采用面向集合的风格时，`Aggregate`实例仅在创建时需要被添加到`Repository`仓储中；
而采用面向持久化的风格时，`Aggregate`实例无论是在创建时还是修改后，都必须被保存到`Repository`中。</ins>

```java
Product product = new Product(...);

productRepository.save(product);
   
 // later ...

Product product =
    productRepository.productOfId(tenantId, productId);

product.reprioritizeFrom(backlogItemId, orderOfPriority);

productRepository.save(product);
```

除此之外，具体细节都体现在实现当中。
接下来我们就直接深入探讨实现部分。
首先，我们来看一下要对接数据网格缓存，所需的 Coherence 基础设施：

```java
package com.saasovation.agilepm.infrastructure.persistence;

import com.tangosol.net.CacheFactory;
import com.tangosol.net.NamedCache;

public class CoherenceProductRepository
        implements ProductRepository {
    private Map<Tenant,NamedCache> caches;

    public CoherenceProductRepository() {
        super();
        this.caches = new HashMap<Tenant,NamedCache>();
    }
    ...
    private synchronized NamedCache cache(TenantId aTenantId) {
        NamedCache cache = this.caches.get(aTenantId);

        if (cache == null) {
            cache = CacheFactory.getCache(
                    "agilepm.Product." + aTenantId.id(),
                    Product.class.getClassLoader());
            this.caches.put(aTenantId, cache);
        }

        return cache;
    }
    ...
}
```

在`Agile Project Management Context`中，团队选择将`Repository`的技术实现放置在`Infrastructure Layer`中。

除了一个简单的无参构造函数外，这里还有 Coherence 的核心组件，NamedCache。
在众多导入项中，需要注意那些专门用于创建、连接和使用缓存的类，即 CacheFactory 和 NamedCache。
这两个类都位于 com.tangosol.net 包中。

私有方法 cache() 是获取 NamedCache 实例的途径。
该方法采用延迟加载的方式，在`Repository`首次尝试使用缓存时才获取它。
这样设计主要是因为每个缓存都以特定的 Tenant 命名，而`Repository`必须等待某个公有方法被调用后，才能获取到 TenantId。
我们可以设计多种 Coherence 命名缓存的策略。
在这个场景中，团队选择使用以下命名空间来构建缓存名称：

1. 第一级：`Bounded Context`的简称：agilepm
2. 第二级：`Aggregate`的简单类名：Product
3. 第三级：每个租户的唯一标识：TenantId

这种命名策略有几个显著的好处。首先，由 Coherence 管理的每个`Bounded Context`、`Aggregate`和租户对应的模型，都可以被单独调优和扩展。
其次，每个租户之间实现了完全的隔离，这样一来，针对某个租户的查询就绝不会意外包含其他租户的对象。
这与在 MySQL 持久化方案中，为每个实体表添加租户标识来实现分表隔离的设计思路是一致的，但在这个场景下实现得更为简洁优雅。
此外，当查询方法需要返回某个给定租户的所有`Aggregate`实例时，实际上根本不需要执行复杂查询，该查询方法只需向 Coherence 请求该缓存中的所有条目即可。
后续在 allProductsOfTenant() 方法的实现中，你会看到这项优化的具体应用。

每当一个 NamedCache 被创建或连接时，它都会被存入与实例变量 caches 相关联的 Map 中。
这样一来，在首次获取缓存之后，后续所有使用场景都可以通过 TenantId 快速查找对应的缓存。

关于 Coherence 的配置和调优，有太多需要考量的因素，这里无法一一展开。
这本身就是一个独立的完整议题，相关文献中也已有详尽的阐述。
我会把这个主题留给 Aleks Seović 来讲解 [[Seović](../bibli.md#seoviec)] 。现在，我们继续推进实现部分的内容。

```java
public class CoherenceProductRepository
        implements ProductRepository {
    ...
    @Override
    public ProductId nextIdentity() {
        return new ProductId(
                java.util.UUID.randomUUID()
                    .toString()
                    .toUpperCase());
    }
    ...
}
```

ProductRepository 中的 nextIdentity() 方法，其实现方式与 CalendarEntryRepository 中的对应方法完全一致。
该方法会生成一个 UUID，并用这个 UUID 实例化一个 ProductId，最后将这个 ProductId 返回。

```java
public class CoherenceProductRepository
        implements ProductRepository {
    ...
    @Override
    public void save(Product aProduct) {
        this.cache(aProduct.tenantId())
                .put(this.idOf(aProduct), aProduct);
    }
 
    @Override
    public void saveAll(Collection<Product> aProductCollection) {
        if (!aProductCollection.isEmpty()) {
            TenantId tenantId = null;

            Map<String,Product> productsMap =
                new HashMap<String,Product>(aProductCollection.size());

            for (Product product : aProductCollection) {
                if (tenantId == null) {
                    tenantId = product.tenantId();
                }
                productsMap.put(this.idOf(product), product);
            }

            this.cache(tenantId).putAll(productsMap);
        }
    }
    ...
    private String idOf(Product aProduct) {
        return this.idOf(aProduct.productId());
    }

    private String idOf(ProductId aProductId) {
        return aProductId.id();
    }
}
```

要将单个新创建或已修改的 Product 实例持久化到数据网格中，可调用 save() 方法。
save() 方法会通过 cache() 方法获取与该 Product 对应的 TenantId 所关联的 NamedCache 实例，随后将这个 Product 实例存入该 NamedCache 中。
需要注意 idOf() 方法的使用，该方法有两个重载版本，一个接收 Product 类型参数，另一个接收 ProductId 类型参数。
无论调用哪个版本，它们最终都会返回该 Product 唯一标识（即 ProductId）的字符串形式。
因此，对于实现了 java.util.Map 接口的 NamedCache 而言，其 put() 方法接收的参数是：一个基于字符串的键（由 idOf() 生成），以及作为值的 Product 实例。

saveAll() 方法的实现可能比你预想的要复杂一些。
为什么不直接遍历 aProductCollection 集合，对其中的每个元素调用 save() 方法呢？
我们其实可以这么做，但问题在于，根据所使用的 Coherence 缓存的具体类型，每一次 put() 方法的调用都需要发起一次网络请求。
因此，最佳实践是：先将所有需要持久化的 Product 实例批量放入一个简单的本地 HashMap 中，然后调用 putAll() 方法一次性提交这些数据。
这种方式通过单次网络请求完成所有数据的持久化，能将网络延迟降到最低，是性能最优的实现方案。

```java
public class CoherenceProductRepository
        implements ProductRepository {
    ...
    @Override
    public void remove(Product aProduct) {
        this.cache(aProduct.tenant()).remove(this.idOf(aProduct));
    }

    @Override
    public void removeAll(Collection<Product> aProductCollection) {
        for (Product product : aProductCollection) {
            this.remove(product);
        }
    }
    ...
}
```

remove() 方法的实现完全符合预期。
不过，结合 saveAll() 的实现来看，removeAll() 的实现可能会和你预想的一样令人意外。
毕竟，难道没有一种批量删除条目的方式吗？
答案是没有，标准的 java.util.Map 接口并未提供批量删除的方法，因此 Coherence 也没有实现该功能。
所以在这个场景下，我们只能遍历 aProductCollection 集合，对其中的每个元素调用 remove() 方法来完成批量删除。
考虑到如果 Coherence 发生故障，可能会导致只有部分集合元素被成功删除，这种实现方式看起来似乎存在风险。
当然，你需要权衡是否要提供 removeAll() 方法的利弊，但请记住，GemFire 和 Coherence 这类数据网格的一大核心优势就是冗余备份和高可用性（能够有效降低这种部分删除的风险）。

最后，我们来看看接口中用于查找 Product 实例的几个方法的实现：

```java
public class CoherenceProductRepository
        implements ProductRepository {
    ...
    @SuppressWarnings("unchecked")
    @Override
    public Collection<Product> allProductsOfTenant(Tenant aTenant) {
        Set<Map.Entry<String, Product>> entries =
            this.cache(aTenant).entrySet();

        Collection<Product> products =
            new HashSet<Product>(entries.size());

        for (Map.Entry<String, Product> entry : entries) {
            products.add(entry.getValue());
        }

        return products;
    }

    @Override
    public Product productOfId(Tenant aTenant, ProductId aProductId) {
       return (Product) this.cache(aTenant).get(this.idOf(aProductId));
    }
    ...
}
```

productOfId() 方法只需在 NamedCache 上执行一个基础的 get() 操作即可，传入的参数就是要查询的 Product 实例的唯一标识。

allProductsOfTenant() 方法就是我之前提到过的那个优化方法。
它无需使用更复杂的 Coherence 条目过滤处理机制，只需要向数据网格请求获取特定 NamedCache 中的所有 Product 实例即可。
因为每个缓存都已经按照单个租户进行了隔离，所以该缓存中的每一个`Aggregate`实例都符合本次查询的要求（即都属于目标租户）。

这就完成了 CoherenceProductRepository 类的全部实现。
该实现展示了如何以 Coherence 作为客户端，实现一个抽象接口，完成数据在网格缓存中的持久化以及后续的查询操作。
需要说明的是，这份实现并未涵盖 Coherence 配置与调优的全部内容，也没有涉及为每个缓存创建索引、为每个领域对象设计紧凑且高性能的序列化器等工作。
这些都不属于`Repository`的职责范围。
关于这些主题的详细内容，可参考 [[Seović](../bibli.md#seoviec)] 的相关著作。

### MongoDB 实现

与其他`Repository`实现一样，MongoDB 版本的`Repository`也有一些基础的实现考量。
实际上，它的实现与 Coherence 版本颇为相似。
以下是我们需要完成的核心工作的高层概述：

1. 一种将`Aggregate`实例序列化为 MongoDB 数据格式的方式，同时也需要能从该格式反序列化并重构出`Aggregate`实例。
MongoDB 使用一种特殊的 JSON 格式，名为 BSON（即二进制 JSON 格式）。

2. 由 MongoDB 生成并分配给`Aggregate`的唯一标识。

3. 一个指向 MongoDB 节点/集群的引用。

4. 一个用于存储每种`Aggregate`类型的唯一集合。
每种`Aggregate`类型的所有实例，都必须以序列化文档（键值对）集合的形式，存储在其专属的集合中。

我们一步步来分析这份`Repository`实现。
由于我们会再次使用 ProductRepository 接口，你可以将这份 MongoDB 实现与上一节的 Coherence 实现进行对比参考。

```java
public class MongoProductRepository
        extends MongoRepository<Product> implements ProductRepository {

    public MongoProductRepository() {
        super();

        this.serializer(new BSONSerializer<Product>(Product.class));
    }
    ...
}
```

这份实现中持有一个 BSONSerializer 实例（该实例实际上由父类 MongoRepository 持有），它被用于所有 Product 实例的序列化与反序列化操作。
我不会深入讲解 BSONSerializer 的细节。
这是一个自定义开发的工具，作用是将 Product 实例（以及其他所有`Aggregate`类型的实例）转换为 MongoDB 的 DBObject 实例，同时也能将 DBObject 实例还原为 Product 实例。
这个类会和其他示例代码一起提供。

BSONSerializer 有几个值得注意的实用功能：基础的序列化与反序列化操作是通过直接字段访问来完成的。
这使得你的领域对象无需实现 JavaBean 风格的 getter 和 setter 方法，而这种做法有助于避免你陷入`Anemic Domain Model`的设计陷阱 [[Fowler, Anemic](../bibli.md#fowler-anemic)] 。
不过，由于你没有使用方法来访问字段，当`Aggregate`类型需要从一个版本迁移到另一个版本时，就需要对应的处理方案。
为此，你可以在反序列化时，为每个字段指定覆盖映射（override mappings），以此来实现`Aggregate`版本的平滑迁移。

```java
public class MongoProductRepository
                  extends MongoRepository<Product>
                  implements ProductRepository {
   
    public MongoProductRepository() {
        super();

        this.serializer(new BSONSerializer<Product>(Product.class));

        Map<String, String> overrides = new HashMap<String, String>();
        overrides.put("description", "summary");
        this.serializer().registerOverrideMappings(overrides);
    }
    ...
}
```

在这个示例中，我们假设 Product 类的早期版本中有一个名为 description 的字段，而在后续版本中，这个字段被重命名为了 summary。
要解决这个字段名称迁移的问题，我们本可以编写一个迁移脚本，遍历所有租户用于存储 Product 实例的 MongoDB 集合，统一修改字段名称。
但这种做法不仅难度较大，而且执行起来耗时极长，实际上并不可行。
作为替代方案，我们只需让 BSONSerializer 在反序列化时，将 Product 对应的 BSON 中名为 description 的字段，映射到领域对象中名为 summary 的字段即可。
这样一来，当被迁移后的 Product 实例被重新序列化为 DBObject 并保存到 MongoDB 集合时，新的序列化文档中将会包含 summary 字段，而非原来的 description 字段。
当然，这也意味着，那些从未被读取和重新保存回存储中的 Product 实例，其文档中仍会保留已过时的 description 字段。你需要权衡这种延迟迁移（lazy migration）方案的利弊。

接下来，我们需要一种让 MongoDB 为每个`Aggregate`实例生成唯一标识的方式：

```java
public class MongoProductRepository
        extends MongoRepository<Product>
        implements ProductRepository {
    ...
    public ProductId nextIdentity() {
        return new ProductId(new ObjectId().toString());
    }
    ...
}
```

我们仍然会使用 nextIdentity() 方法，但在这份 MongoDB 实现中，我们会用一个新 ObjectId 的字符串值来初始化 ProductId。
这么做的主要原因是，我们希望 MongoDB 所使用的唯一标识，与我们在`Aggregate`实例本身中持有的唯一标识保持一致。
因此，当我们序列化一个 Product 实例时（或其他`Repository`实现中的其他类型），就可以让 BSONSerializer 将这个唯一标识，映射到 MongoDB 中那个特殊的 _id 键上（_id 是 MongoDB 中文档的默认主键，用于唯一标识集合中的每一条文档）。

```java
public class BSONSerializer<T> {
    ...
    public DBObject serialize(T anObject) {
        DBObject serialization = this.toDBObject(anObject);

        return serialization;
    }

    public DBObject serialize(String aKey, T anObject) {
        DBObject serialization = this.serialize(anObject);

        serialization.put("_id", new ObjectId(aKey));

        return serialization;
    }
    ...
}
```

第一个 serialize() 方法不支持这种 _id 映射功能，这让客户端可以自主选择是否保留标识一致性。
接下来，我们看看 save() 方法是如何实现的：

```java
public class MongoProductRepository
        extends MongoRepository<Product>
        implements ProductRepository {
    ...
    @Override
    public void save(Product aProduct) {
        this.databaseCollection(
                this.collectionName(aProduct.tenantId()))
            .save(this.serialize(aProduct));
    }
    ...
}
```

与该`Repository`接口的 Coherence 实现类似，我们会先获取一个租户专属的集合，用于存储对应 TenantId 的 Product 实例。
最终从 MongoDB 的 DB 对象中得到一个 DBCollection。
要获取这个 DBCollection 对象，我们在抽象基类 MongoRepository 中编写了如下相关实现：

```java
public abstract class MongoRepository<T> {
    ...
    protected DBCollection databaseCollection(
            String aDatabaseName,
            String aCollectionName) {
        return MongoDatabaseProvider
                .database(aDatabaseName)
                .getCollection(aCollectionName);
    }
    ...
}
```

我们通过 MongoDatabaseProvider 来获取与数据库实例的连接，该提供者会返回一个 DB 对象。
从这个返回的 DB 对象中，我们可以获取到对应的 DBCollection 集合对象。
正如在具体的`Repository`实现中所看到的，这个集合的名称是由文本 product 和租户的完整标识组合而成的。
和 Coherence 实现中对缓存的命名方式类似，`Agile PM Context `使用了一个名为 agilepm 的专用数据库。

```java
public class MongoProductRepository
        extends MongoRepository<Product>
        implements ProductRepository {
    ...
    protected String collectionName(TenantId aTenantId) {
        return "product" + aTenantId.id();
    }

    protected String databaseName() {
        return "agilepm";
    }
    ...
}
```

与之前介绍的 SpringHibernateSessionProvider 类似，MongoDatabaseProvider 是获取整个应用范围内共享的 DB 实例的工具。

同一个 DBCollection 既被用于 save() 方法，也被用于查找 Product 实例（查询操作）。

```java
public class MongoProductRepository
        extends MongoRepository<Product>
        implements ProductRepository {
    ...
    @Override
    public Collection<Product> allProductsOfTenant(
            TenantId aTenantId) {
        Collection<Product> products = new ArrayList<Product>();

        DBCursor cursor =
            this.databaseCollection(
                    this.databaseName(),
                    this.collectionName(aTenantId)).find();

        while (cursor.hasNext()) {
            DBObject dbObject = cursor.next();

            Product product = this.deserialize(dbObject);

            products.add(product);
        }

        return products;
    }

    @Override
    public Product productOfId(
            TenantId aTenantId, ProductId aProductId) {
        Product product = null;

        BasicDBObject query = new BasicDBObject();

        query.put("productId",
                new BasicDBObject("id", aProductId.id()));

        DBCursor cursor =
            this.databaseCollection(
                    this.databaseName(),
                    this.collectionName(aTenantId)).find(query);

        if (cursor.hasNext()) {
            product = this.deserialize(cursor.next());

        return product;
    }
    ...
}
```

allProductsOfTenant() 方法的实现同样与 Coherence 版本极为相似。
我们只需让这个租户专属的 DBCollection 执行 find() 方法，获取该集合中的所有实例即可。
而对于 productOfId() 方法，这一次我们会向 DBCollection 的 find() 方法传入一个 DBObject，这个 DBObject 描述了要检索的特定 Product 实例。
在这两个查询方法中，我们都会使用返回的 DBCursor，获取所有实例，和对应的第一个实例。

#### ▶[下一节](3.md)

---

#### 3
你可以编写 [Application Service (14)](../ch14/0.md) 测试，来确保所有必要的更新操作都已完成对应的保存。我们可以设计一个内存`Repository`实现（详见本章后文正文内容），利用它来检查保存操作的完整性。

#### 4
此外，这种方式还会将你的 Coherence 客户端限制为仅支持 Java 语言；而如果你采用可移植对象格式（Portable Object Format, POF）序列化，.NET 和 C++ 客户端也同样可以使用该网格数据。

