## 第 12 章：存储库 (Repositories)

#### ▶[上一节](../ch11/4.md)

*<p align="right">
你眼睛的颜色，和我的储物间一个样。 </br>
——在红脖子酒吧无意间听到的话</p>*

仓储通常指一处存储场所，一般被视作妥善存放、保全其内物品的地方。
将物品存入仓储后，若后续返回取用，你会期望它仍保持存入时的状态。
在某些情况下，你也可能选择将存放的物品从仓储中取出。

这些基本准则同样适用于 DDD 中的`Repository`。
将一个 [Aggregate (10)](../ch10/0.md) 实例存入其对应的`Repository`中，后续再通过该`Repository`检索这个相同的实例时，你将获得完整且符合预期的对象。
如果你修改了一个从`Repository`中检索到的已存在`Aggregate`实例，其变更内容将会被持久化保存。
而一旦你将该实例从`Repository`中移除，此后便无法再从该`Repository`中检索到它了。

- 对于每种需要全局访问的对象类型，创建一个可以提供该类型所有对象的内存集合幻觉的对象。
通过一个众所周知的全局接口设置访问。
提供添加和移除对象的方法。。。
提供根据某些条件选择对象并返回完整实例化对象或属性值符合条件的对象集合的方法。。。
仅为聚合体提供存储库。。。 [[Evans, p. 151](../bibli.md#evans)]

这些类似集合的对象都是关于持久性的。
每个持久化的`Aggregate`类型都会有一个`Repository`存储库。
一般来说，`Aggregate`类型和`Repository`之间是一对一的关系。
然而，有时当两个或多个`Aggregate`类型共享一个对象层次结构时，这些类型可能会共享一个`Repository`。本章讨论了这两种方法。

---
**<center>本章路线图</center>**

- 了解两种不同类型的`Repositories`及其适用场景

- 掌握为 Hibernate、TopLink、Coherence 和 MongoDB 实现`Repositories`的方法

- 理解为何需在`Repository`接口中添加额外行为，并思考事务在`Repositories`使用中的作用

- 熟悉为类型层级设计`Repositories`时面临的难点

- 认识`Repositories`与`Data Access Objects` [[Crupi et al.](../bibli.md#crupi-et-al)] 的核心差异

- 探讨`Repositories`的测试方法及基于`Repositories`的测试思路

---

严格来说，只有`Aggregate`才拥有`Repository`。
如果在某个特定的 [Bounded Context (2)](../ch2/0.md) 中你没有使用`Aggregates`，那么`Repository`模式的价值可能会大打折扣。
如果你不是精心构建`Aggregate`的事务边界，而是以一种临时随性的方式直接检索和使用 [Entity (5)](../ch5/0.md)，那么或许应该避免使用`Repositories`。
不过，对于那些不太关注 DDD 核心原则、仅从技术层面借鉴其部分模式的开发者而言，他们可能更倾向于使用`Repositories`而非`Data Access Object`。
还有一部分开发者则认为，直接使用持久化机制的`Session`或`Unit of Work`，出自 [Fowler, P of EAA](../bibli.md#fowler-p-of-eaa) 会更为合理。
需要说明的是，这并非是在建议你避免使用`Aggregates`
事实上，恰恰相反，`Aggregate`是极具价值的。
尽管如此，不使用`Aggregate`仍会是部分开发者选择的一种方案。

在我看来，`Repository`设计主要分为两种类型， *面向集合的* 设计与 *面向持久化的* 设计。
这两种设计各有其适用场景：在某些情况下，面向集合的设计能够很好地满足你的需求；而在另一些场景下，采用面向持久化的设计则是更优的选择。
我会先讲解面向集合`Repository`的适用场景与实现方法，随后再深入探讨面向持久化的设计。

#### ▶[下一节](1.md)
