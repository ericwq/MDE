## 测试`Repositories`

#### ▶[上一节](6.md)

关于`Repositories`的测试，有两种视角需要考虑。
一方面，你必须对`Repositories`本身进行测试，以证明其能够正常工作；
另一方面，你还必须测试那些使用`Repositories`的代码，这些代码借助`Repositories`存储它们创建的`Aggregates`，以及查询已存在的`Aggregates`。
对于第一种测试，你必须使用完整的、生产级质量的实现版本。
否则，你将无法确认生产环境中的代码是否能够正常运行。
对于第二种测试，你既可以使用生产环境的实现版本，也可以改用内存中的实现版本。
我现在先讲解生产环境实现版本的测试，内存版本的测试将在稍后展开。

下面，我们来看一下前文提到的 ProductRepository 的 Coherence 实现版本对应的测试用例：

```java
public class CoherenceProductRepositoryTest extends DomainTest {
    private ProductRepository productRepository;
    private TenantId tenantId;

    public CoherenceProductRepositoryTest() {
        super();
    }
    ...
    @Override
    protected void setUp() throws Exception {
        this.setProductRepository(new CoherenceProductRepository());
        this.tenantId = new TenantId("01234567");
        super.setUp();
    }

    @Override
    protected void tearDown() throws Exception {
        Collection<Product> products =
            this.productRepository()
                    .allProductsOfTenant(tenantId);

        this.productRepository().removeAll(products);
    }

    protected ProductRepository productRepository() {
        return this.productRepository;
    }

    protected void setProductRepository(
            ProductRepository aProductRepository) {
        this.productRepository = aProductRepository;
    }
}
```

有一些通用的初始化（setup）和清理（tear-down）操作，用于为每个测试用例做准备并在测试完成后进行环境清理。
在初始化阶段，我们会创建一个 CoherenceProductRepository 类的实例，然后再创建一个 TenantId 的模拟实例。

在清理阶段，我们会移除所有可能被各个测试用例添加到底层缓存中的 Product 实例。
对于 Coherence 而言，这是一步至关重要的清理操作。
如果不移除所有缓存实例，它们会在后续的测试中残留下来，这可能导致某些断言（比如持久化实例的数量断言）执行失败。

接下来，我们开始测试`Repository`的行为逻辑：

```java
public class CoherenceProductRepositoryTest extends DomainTest {
    ...
    public void testSaveAndFindOneProduct() throws Exception {

        Product product =
            new Product(
                    tenantId,
                    this.productRepository().nextIdentity(),
                    "My Product",
                    "This is the description of my product.");

        this.productRepository().save(product);

        Product readProduct =
            this.productRepository()
                .productOfId(tenantId, product.productId());

        assertNotNull(readProduct);
        assertEquals(readProduct.tenantId(), tenantId);
        assertEquals(readProduct.productId(), product.productId());
        assertEquals(readProduct.name(), product.name());
        assertEquals(readProduct.description(), product.description());
    }
    ...
}
```

正如这个测试方法的名称所示，这里我们要保存单个 Product 实例，并尝试查询它。
第一步是实例化一个 Product，然后将其保存到`Repository`中。
如果底层基础设施没有抛出任何异常，我们或许会认为这个 Product 已经被正确保存了。
但要确切知晓保存是否成功，只有一种方法。
我们必须查询到这个实例，并将其与原始实例进行对比。
查询该实例时，我们需要将它的全局唯一标识传入 productOfId() 方法。
如果成功查询到了该实例，我们就可以顺利执行断言：验证该实例不为空，且它的 tenantId、productId、name 以及 description，都与被存储的原始实例完全一致。

接下来，我们将测试多个实例的保存与查询功能：

```java
public class CoherenceProductRepositoryTest extends DomainTest {
    ...
    public void testSaveAndFindMultipleProducts() throws Exception {

        Product product1 =
            new Product(
                    tenantId,
                    this.productRepository().nextIdentity(),
                    "My Product 1",
                    "This is the description of my first product.");

        Product product2 =
            new Product(
                    tenantId,
                    this.productRepository().nextIdentity(),
                    "My Product 2",
                    "This is the description of my second product.");

        Product product3 =
            new Product(
                    tenantId,
                    this.productRepository().nextIdentity(),
                    "My Product 3",
                    "This is the description of my third product.");

        this.productRepository()
            .saveAll(Arrays.asList(product1, product2, product3));

        assertNotNull(this.productRepository()
            .productOfId(tenant, product1.productId()));
        assertNotNull(this.productRepository()
            .productOfId(tenant, product2.productId()));
        assertNotNull(this.productRepository()
            .productOfId(tenant, product3.productId()));

        Collection<Product> allProducts =
            this.productRepository().allProductsOfTenant(tenant);

        assertEquals(allProducts.size(), 3);
    }
    ...
}
```

首先，我们实例化三个 Product 实例，然后使用 saveAll() 方法一次性保存它们。
接下来，我们再次使用 productOfId() 方法来查找单个实例。
如果这三个实例都不为空，我们就可以确信所有三个实例都已正确持久化。

|牛仔逻辑||
|:---|---:|
|AJ：“我姐姐告诉我，她丈夫让她在他死后把他储物间里的所有东西都卖掉。我姐姐问他为什么。他说，他不想在她再婚的时候，让某个混蛋得到他的东西。我姐姐让他别担心，因为她不打算再嫁给另一个混蛋。”|<img src="../img/cbl.2.png" width="90%"/>|

还有一个仓储方法 allProductsOfTenant() 尚未进行测试。
鉴于测试开始时仓储缓存处于完全空的状态，我们应当能够从中成功读取到三个 Product 实例。
因此，我们尝试查询出所有的 Product 实例。
返回的集合绝对不应该为 null，即便没有找到你预期的内容也是如此。
所以，这个测试的最后一步，是断言查询结果中确实包含了预期数量的 Product 实例，也就是三个。

现在，我们已经有了一个既能演示客户端如何使用`Repository`、又能证明其正确性的测试用例。
接下来，我们可以探讨如何以更优的方式测试那些使用`Repositories`的客户端代码。

### 基于内存实现的测试

如果为了测试而搭建`Repository`的完整持久化实现难度极大，或者使用该实现进行测试的速度过慢，你可以采用另一种方案。
在领域建模的早期阶段，你也可能会遇到一些棘手的情况，比如包括数据库 schema 在内的持久化机制尚未就绪。
当你面临上述任何一种情况时，最佳做法是实现一个`Repositories`的内存版本。

创建仓储的内存版本通常会相当简单，但这也可能带来一些挑战。
其中简单的部分在于，你可以创建一个 HashMap 来作为接口的底层支撑。
向这个 Map 中 put() 条目和从中 remove() 条目都非常直观：
我们只需将每个`Aggregate`实例的全局唯一标识作为 key ，`Aggregate`实例本身则作为 value 。
对应的 add() 或 save() 方法，以及 remove() 方法的实现都会十分简易。
事实上，以 ProductRepository 为例，它的完整内存实现就相当简洁：

```java
package com.saasovation.agilepm.domain.model.product.impl;

public class InMemoryProductRepository implements ProductRepository {

    private Map<ProductId,Product> store;

    public InMemoryProductRepository() {
        super();
        this.store = new HashMap<ProductId,Product>();
    }

    @Override
    public Collection<Product> allProductsOfTenant(Tenant aTenant) {
        Set<Product> entries = new HashSet<Product>();

        for (Product product : this.store.values()) {
            if (product.tenant().equals(aTenant)) {
                entries.add(product);
            }
        }
    }

    @Override
    public ProductId nextIdentity() {
        return new ProductId(java.util.UUID.randomUUID()
                .toString().toUpperCase());
    }

    @Override
    public Product productOfId(Tenant aTenant, ProductId aProductId) {
        Product product = this.store.get(aProductId);
        if (product != null) {
            if (!product.tenant().equals(aTenant)) {
                product = null;
            }
        }
        return product;
    }

    @Override
    public void remove(Product aProduct) {
        this.store.remove(aProduct.productId());
    }

    @Override
    public void removeAll(Collection<Product> aProductCollection) {
        for (Product product : aProductCollection) {
            this.remove(product);
        }
    }

    @Override
    public void save(Product aProduct) {
        this.store.put(aProduct.productId(), aProduct);
    }

    @Override
    public void saveAll(Collection<Product> aProductCollection) {
        for (Product product : aProductCollection) {
            this.save(product);
        }
    }
}
```

实际上，productOfId() 方法只有一个特殊情况需要处理。
要正确实现这个查询方法，在通过给定的 ProductId 获取到匹配的 Product 实例后，我们还必须检查该 Product 实例的 TenantId 是否与传入的 Tenant 参数一致。
如果不一致，我们就将这个 Product 实例设为 null。

我们实际上可以复制一份与 CoherenceProductRepositoryTest 几乎完全相同的测试用例，并将其命名为 InMemoryProductRepositoryTest，以此来测试这个内存实现版本。
唯一需要修改的地方就在 setUp()（初始化）方法中：

```java
public class InMemoryProductRepositoryTest extends TestCase {
    ...
    @Override
    protected void setUp() throws Exception {
        this.setProductRepository(new InMemoryProductRepository());
        this.tenantId = new TenantId("01234567");
        super.setUp();
    }
    ...
}
```

只需实例化 InMemoryProductRepository ，而非 Coherence 实现版本即可。
除此之外，测试方法本身完全保持不变。

可能出现的棘手挑战通常与实现更复杂的查询方法有关，这类方法的参数条件解析逻辑往往较为繁琐。
如果条件和解析逻辑变得过于复杂，你可能需要找到一种方法来应对这种情况。
这或许意味着，在`Repository`中预先填充一些能够满足查询条件的实例，同时让查询方法本身只返回这些预先填充的实例（单个或多个）。
你可以借助测试的 setUp() 方法来完成预先填充的操作。

实现`Repositories`的内存版本还有另一项优势，当你需要测试基于持久化导向接口的 save() 方法是否被正确使用时，这种方式会非常实用。
你可以在实现 save() 方法时，对其调用次数进行计数。
每次测试运行完毕后，你都可以通过断言来验证该方法的调用次数，是否与这个特定`Repository`的客户端所需的调用次数一致。
通常，在测试那些必须显式调用 save() 方法来保存`Aggregate`变更的应用服务时，你都可以采用这种方法。

<center><img src="../img/ownit.png" align="center" width="30%" /></center>

#### ▶[下一节](8.md)

