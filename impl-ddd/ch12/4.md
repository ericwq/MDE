## 管理事务

#### ▶[上一节](3.md)

领域模型及其所包含的`Domain Layer`从来都不是管理事务的正确位置。<sup>[5](#5)</sup>
与模型相关的操作通常过于细粒度，无法自行管理事务，也不应该意识到事务在它们的生命周期中起作用。
如果你想避免将事务相关的关注点放在模型中，那么它们到底应该放在哪里呢？

一种常见的架构方法是为了处理领域模型持久性方面的事务，在 [Application Layer (14)](../ch14/0.md) 中进行管理。<sup>[6](#6)</sup>
通常，我们会为应用程序/系统所涉及的每个主要用例组创建一个`Facade` [[Gamma et al.](../bibli.md#gamma-et-al)] 。
这个`Facade`通常设计有粗粒度的业务方法，通常每个用例流程对应一个业务方法（对于某些用例可能仅限一个）。
每个这样的业务方法都按照用例要求协调执行相应任务。
当 [User Interface Layer (14)](../ch14/0.md) 调用`Facade`的业务方法时，无论是代表人类用户还是其他系统，该业务方法会启动一个事务，然后作为领域模型的客户端进行操作。
在与领域模型的所有必要交互成功完成后，`Facade`的业务方法会提交它启动的事务。
如果发生错误/异常导致用例任务无法完成，同一个管理业务方法将回滚该事务。

事务既可以通过声明式方式进行管理，也可以由开发者通过显式编码的方式来管理。
无论你采用声明式事务还是开发者手动管理事务，我在此描述的事务管理逻辑在本质上都是按照以下方式运作的：

```java
public class SomeApplicationServiceFacade {
    ...
    public void doSomeUseCaseTask()  {
        Transaction transaction = null;
        try {
            transaction = this.session().beginTransaction();

            // use the domain model ...

            transaction.commit();

        } catch (Exception e) {
            if (transaction != null) {
                transaction.rollback();
            }
        }
    }
}
```

要将领域模型的变更纳入事务管理范围，你需要确保`Repository`实现能够访问到`Application Layer`开启的同一个 Session 或工作单元（Unit of Work）。
通过这种方式，`Domain Layer`中所做的所有修改，才能在事务提交时被正确持久化到底层数据库，或者在事务回滚时被全部撤销。

实现这一目标的方式多种多样，无法一一穷尽。
但需要说明的是，企业级 Java 容器以及控制反转（IoC）容器（比如 Spring），都提供了对应的实现手段来达成上述需求，而且这方面的用法已经被广泛熟知和应用。
这里的核心原则是：选择适合你当前技术环境的实现方式即可。
举个例子，下面是使用 Spring 实现该需求的大致方式：

```xml
<tx:annotation-driven transaction-manager="transactionManager"/>
<bean
    id="sessionFactory"
    class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
    <property name="configLocation">
        <value>classpath:hibernate.cfg.xml</value>
    </property>
</bean>
<bean
    id="sessionProvider"
    class="com.saasovation.identityaccess.infrastructure
           .persistence.SpringHibernateSessionProvider"
    autowire="byName">
</bean>
<bean
    id="transactionManager"
    class="org.springframework.orm.hibernate3
           .HibernateTransactionManager">
    <property name="sessionFactory">
        <ref bean="sessionFactory"/>
    </property>
</bean>
<bean
    id="abstractTransactionalServiceProxy"
    abstract="true"
    class="org.springframework.transaction.interceptor
           .TransactionProxyFactoryBean">
    <property name="transactionManager">
        <ref bean="transactionManager"/>
    </property>
    <property name="transactionAttributes">
        <props>
            <prop key="*">PROPAGATION_REQUIRED</prop>
        </props>
    </property>
</bean>
```

配置好的 sessionFactory Bean 提供了获取 Hibernate Session 的途径。
名为 sessionProvider 的 Bean 则用于将从 sessionFactory 获取到的 Session，与当前执行的线程进行绑定。
当基于 Hibernate 实现的`Repositories`需要获取其运行线程对应的 Session 实例时，就可以使用这个 sessionProvider Bean。
transactionManager 会借助 sessionFactory 来获取并管理 Hibernate 事务。
最后一个 Bean abstractTransactionalServiceProxy，可作为可选代理，用于通过 Spring 配置来声明支持事务的 Bean。
而最顶层的配置，允许通过 Java 注解来声明事务，这种方式通常比使用 XML 配置更加便捷。

```xml
<tx:annotation-driven transaction-manager="transactionManager"/>
```

完成这样的配置后，你现在只需要使用一个简单的注解，就可以将某个`Facade`业务方法声明为支持事务的方法了：

```java
public class SomeApplicationServiceFacade {
    ...
    @Transactional
    public void doSomeUseCaseTask()  {

        // use the domain model ...
    }
}
```

与之前手动管理事务的示例相比，这种方式无疑大大减少了业务方法中的冗余代码，让你能够专注于任务本身的协调工作。
通过这个注解，当业务方法被调用时，Spring 会自动开启一个事务；当方法执行完成时，Spring 会根据执行结果，自动完成事务的提交或回滚（正常完成则提交，发生异常则回滚）。

下面我们来看一下 sessionProvider Bean 的源代码实现，它是针对`Identity and Access Context`编写的：

```java
package com.saasovation.identityaccess.infrastructure.persistence;

import org.hibernate.Session;
import org.hibernate.SessionFactory;

public class SpringHibernateSessionProvider {

    private static final ThreadLocal<Session> sessionHolder =
            new ThreadLocal<Session>();

    private SessionFactory sessionFactory;

    public SpringHibernateSessionProvider() {
        super();
    }

    public Session session() {
        Session threadBoundsession = sessionHolder.get();
        if (threadBoundsession == null) {
            threadBoundsession = sessionFactory.openSession();
            sessionHolder.set(threadBoundsession);
        }
        return threadBoundsession;
    }

    public void setSessionFactory(SessionFactory aSessionFactory) {
        this.sessionFactory = aSessionFactory;
    }
}

```
由于 sessionProvider 是一个声明了 autowire="byName"（按名称自动装配）的 Spring Bean，当它以单例模式被实例化时，Spring 会调用它的 setSessionFactory() 方法，将 sessionFactory Bean 实例注入其中。
为了避免你回头翻阅本章内容查找：基于 Hibernate 的`Repository`是如何使用它的，这里做一个简要提醒：

```java
package com.saasovation.identityaccess.infrastructure.persistence;
public class HibernateUserRepository
        implements UserRepository  {

    @Override
    public void add(User aUser) {
        try {
            this.session().saveOrUpdate(aUser);
        } catch (ConstraintViolationException e) {
            throw new IllegalStateException("User is not unique.", e);
        }
    }
    ...
    private SpringHibernateSessionProvider sessionProvider;

    public void setSessionProvider(
            SpringHibernateSessionProvider aSessionProvider) {
        this.sessionProvider = aSessionProvider;
    }
  
    private org.hibernate.Session session() {
        return this.sessionProvider.session();
    }
}
```

这段代码片段来自`Identity and Access Context`中的 HibernateUserRepository 类。
这个类同样是一个按名称自动装配的 Spring Bean，这意味着在它被创建时，Spring 会自动调用它的 setSessionProvider() 方法，为它注入 sessionProvider Bean 的引用，该 Bean 是 SpringHibernateSessionProvider 的实例。
当 add() 方法（或其他任何负责持久化操作的方法）被调用时，它会通过自身的 session() 方法获取一个 Session。而 session() 方法又会借助注入的 sessionProvider，获取到与当前线程绑定的 Session 实例。

虽然我只演示了使用 Hibernate 时的事务管理方式，但这些原则完全适用于 TopLink、JPA 以及其他持久化机制。
无论使用哪种持久化机制，你都必须找到一种方式，让相关组件能够访问到`Application Layer`正在管理的同一个 Session、工作单元（Unit of Work）和事务。
如果当前技术环境支持依赖注入（Dependency Injection），那么它会是实现这一目标的绝佳方式。
如果不支持依赖注入，也可以采用其他灵活的方式来完成这种必要的组件关联，甚至可以直接将这些对象手动绑定到当前线程上。

### 一则警告

我觉得有必要在最后给出一则警告，提醒你警惕在领域模型中过度使用事务的问题。
`Aggregates`的设计必须严谨细致，这样才能确保它具备正确的一致性边界。
需要注意的是，不要仅仅因为在单元测试环境中能够正常运行，就滥用在单个事务中提交多个`Aggregates`的修改这一能力。
如果你掉以轻心，那些在开发和测试环境中表现良好的代码，到了生产环境中，很可能会因为并发问题而出现严重故障。
如果有必要，你可以重新回顾 [Aggregates (10)](../ch10/0.md) 相关章节，其中关于精准定义一致性边界、保障事务执行成功的重要提醒，对你会有很大帮助。

#### ▶[下一节](5.md)

---

#### 5
请注意，对于某些持久化机制，事务管理要么不存在，要么与关系数据库中常见的 ACID 事务工作方式不同。
Coherence 和许多 NoSQL 存储就存在这种差异，因此这些内容通常不适用于这些数据存储机制。

#### 6
`Application Layer`还负责管理其他一些关注点（比如安全相关事宜），不过本文在此不展开讨论这些内容。
