## `Repository`与数据访问对象

#### ▶[上一节](5.md)

有时，`Repository`的概念被认为与数据访问对象（Data Access Object，简称 DAO）是同义词。
两者都对持久化机制提供了一层抽象。
这一点是事实。
然而，对象关系映射工具同样也对持久化机制提供了抽象，但它既不是`Repository`，也不是数据访问对象。
因此，我们不能将任何持久化抽象都称为 DAO。
我们必须先判断其是否实现了 DAO 模式。

我认为`Repository`和 DAO 之间通常存在一些差异。
从本质上来说，DAO 是围绕数据库表来设计的，它为数据库表提供 CRUD 接口。
Martin Fowler在其著作 [Fowler, P of EAA](../bibli.md#fowler-p-of-eaa) 中，将类似 DAO 的工具的使用场景，与那些用于领域模型的工具场景区分开来。
他指出，Table Module、Table Data Gateway 和 Active Record 这些模式，通常会在采用 Transaction Script 的应用中使用。
<ins>这是因为 DAO 以及相关模式，其本质往往是作为数据库表的包装器存在的。
而另一方面，`Repository`和 Data Mapper 具有对象亲和性，它们才是通常与领域模型配合使用的模式。</ins>

由于使用 DAO 及相关模式，能够对那些本应被视为`Aggregate`组成部分的数据执行细粒度的 CRUD 操作，因此在领域模型的设计中，应当避免使用这种模式。
在正常情况下，你应当让`Aggregate`自身来管理其业务逻辑和其他内部细节，并阻止外部对象对这些内容进行干预。

我之前确实提到过，有时存储过程或数据网格条目处理器 (entry processor) 对于满足某些严苛的非功能性需求是必不可少的。
根据你的业务领域，这种情况可能是常态而非例外。
然而，如果没有系统的非功能性需求作为驱动，我建议你避免使用它们。
在数据存储中承载和执行业务逻辑，在很多情况下与 DDD 是相悖的。
<ins>我认为，使用数据网格函数/条目处理器并不会真正破坏领域建模的目标。
例如，函数/条目处理器的实现可以用 Java 编写，并且会遵循 [Ubiquitous Language](../ch1/0.md) 和领域目标。
它与核心模型的唯一区别在于执行位置，而这并不会造成破坏。
另一方面，大量使用存储过程则可能对 DDD 造成极大的破坏，因为建模团队通常不熟悉其编程语言，且实现通常被安全地隐藏在他们的视野之外。
如果是这样，这就与 DDD 想要达成的目标完全背道而驰。</ins>

你可以在广义上将`Repository`视为一种 DAO 。
需要牢记的核心原则是，应尽可能以集合导向而非数据访问导向来设计`Repository`。
这能帮助你将关注点聚焦在作为模型的领域上，而非数据本身，以及那些在幕后用于管理持久化的 CRUD 操作。

#### ▶[下一节](7.md)
