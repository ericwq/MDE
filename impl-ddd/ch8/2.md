## 建模事件

#### ▶[上一节](1.md)

我们以`Agile Project Management Context`的一项需求为例。领域专家通过如下表述指明了对事件的需求（斜体部分为强调内容）：

| ||
|---|---|
|允许将每个待办项提交至某个冲刺阶段。待办项仅可在已被排期至某次发布后提交。若该待办项已提交至其他冲刺阶段，则必须先取消其原有提交状态。 *当待办项完成提交操作时，需通知对应的冲刺阶段及其他相关方* 。|![](../img/ovation.1.png)|

在对事件进行建模时，需依据事件所属`Bounded Context`中的`Ubiquitous Language`来为事件及其属性命名。若某一事件是对`Aggregate`执行命令操作后的结果，那么该事件的名称通常衍生自所执行的命令。命令是事件产生的原因，因此事件名称理应以命令已执行完成的过去式形式来表述。
结合上述示例场景，当我们将待办项提交至某个冲刺阶段时，需发布一个能明确建模领域中所发生事实的事件：

- 命令操作：BacklogItem#commitTo(Sprint aSprint)

- 事件结果：BacklogItemCommitted

事件名称需以过去式明确说明`Aggregate`在请求操作成功后所发生的事实：“待办项已完成提交”。团队本可以将该名称建模得更详尽一些，例如命名为 BacklogItemCommittedToSprint，这种命名方式也完全可行。
但在 Scrum 的`Ubiquitous Language`体系中，待办项除了提交至冲刺阶段外，不会提交至任何其他对象。换言之，待办项是被排期至某次发布，而非 “提交” 至发布。因此，毫无疑问该事件是执行 commitTo() 操作后发布的。由此可见，当前这个名称已足够清晰，且更简洁的命名形式也更易阅读。不过，若你的团队在特定场景下倾向于使用更详尽的名称，那么直接采用即可。

从`Aggregates`发布事件时，至关重要的一点是事件名称需体现该事件是已发生的事实。它并非正在发生，而是此前已经发生。因此，最恰当的命名应当能反映这一既定事实。

确定合适的名称后，事件应具备哪些属性？首先，我们需要一个时间戳来标明事件发生的具体时间。在 Java 中，可将其表示为`java.util.Date`类型：

```java
package com.saasovation.agilepm.domain.model.product;

public class BacklogItemCommitted implements DomainEvent {
    private Date occurredOn;
    ...
}
```

所有事件均需实现的`DomainEvent`最小接口，可确保对 occurredOn() 访问方法的支持。该接口为所有事件设定了一项基本约定：

```java
package com.saasovation.agilepm.domain.model;

import java.util.Date;

public interface DomainEvent {
    public Date occurredOn();
}
```

除此之外，团队需确定还需哪些其他 properties，才能完整表征这一具备业务意义的已发生事实。需考虑纳入所有能让该事件被重新触发的必要信息。这通常包括事件所发生的`Aggregate`实例的标识，或是所有涉及的`Aggregate`实例标识。
遵循这一指导原则，若经讨论确认相关参数具备业务价值，我们可将触发该事件的所有参数都设定为事件 properties。此外，`Aggregate`状态转换后的部分结果值，也可能对事件订阅方起到辅助作用，同样可纳入考量。

---
以下是对 BacklogItemCommitted 事件分析后确定的内容：

```java
package com.saasovation.agilepm.domain.model.product;

public class BacklogItemCommitted implements DomainEvent {
    private Date occurredOn;
    private BacklogItemId backlogItemId;
    private SprintId committedToSprintId;
    private TenantId tenantId;
    ...
}
```

| ||
|---|---|
| 团队认定 BacklogItem 的标识与 Sprint 的标识是核心：该事件发生在 BacklogItem 上，且与 Sprint 相关联。但这一决策背后还有更深层的考量。催生该事件需求的业务规则明确要求，必须通知对应的 Sprint：某一 BacklogItem 已提交至该冲刺阶段。因此，同一`Bounded Context`中的事件订阅方若要完成这一通知操作，必须依赖 BacklogItemCommitted 事件中包含的 SprintId 。|![](../img/ovation.3.png)|

此外，在多租户环境下，即便 TenantId 未作为命令参数传入，记录该字段也始终是必要的，且本地与外部`Bounded Contexts`均需使用该标识。在本地场景中，团队需通过 TenantId 从对应的 [Repositories (12)](../ch12/0.md) 中查询 BacklogItem 和 Sprint；同理，任何监听该事件广播的外部远程系统，也需要知晓该事件对应的 TenantId。

---

我们该如何为事件所提供的行为操作建模？这类操作通常设计得极为简洁，因为事件一般被设定为不可变的。首先且最重要的一点是，事件接口的核心作用就是传递能体现其触发原因的各项 properties。绝大多数事件会配备一个仅支持完整状态初始化的构造函数，同时为每个 properties 提供对应的只读访问方法。

---
基于上述考量，ProjectOvation 团队做出了如下实现：

```java
package com.saasovation.agilepm.domain.model.product;

public class BacklogItemCommitted implements DomainEvent {
    ...
    public BacklogItemCommitted(
            TenantId aTenantId,
            BacklogItemId aBacklogItemId,
            SprintId aCommittedToSprintId) {
        super();
        this.setOccurredOn(new Date());
        this.setBacklogItemId(aBacklogItemId);
        this.setCommittedToSprintId(aCommittedToSprintId);
        this.setTenantId(aTenantId);
    }

    @Override
    public Date occurredOn() {
        return this.occurredOn;
    }

    public BacklogItemId backlogItemId() {
        return this.backlogItemId;
    }

    public SprintId committedToSprintId() {
        return this.committedToSprintId;
    }

    public TenantId tenantId() {
        return this.tenant;
    }
    ...
}
```

发布该事件后，本地`Bounded Context`中的订阅方可借助此事件通知 Sprint ：某一 BacklogItem 已于近期提交至该冲刺阶段：

```java
MessageConsumer.instance(messageSource, false)
    .receiveOnly(
            new String[] { "BacklogItemCommitted" },
            new MessageListener(Type.TEXT) {
        @Override
        public void handleMessage(
            String aType,
            String aMessageId,
            Date aTimestamp,
            String aTextMessage,
            long aDeliveryTag,
            boolean isRedelivery)
        throws Exception {
            // first de-duplicate message by aMessageId
            ...
            // get tenantId, sprintId, and backlogItemId from JSON
            ...
            Sprint sprint =
                    sprintRepository.sprintOfId(tenantId, sprintId);
            BacklogItem backlogItem =
                    backlogItemRepository.backlogItemOfId(
                         tenantId,
                         backlogItemId);
            sprint.commit(backlogItem);
        }
    });
```

---

根据系统需求，在处理完特定的 BacklogItemCommitted 消息后， Sprint 需与近期提交至其名下的 BacklogItem 保持状态一致。至于订阅方接收该事件的具体方式，将在本章后续内容中探讨。

---
<img src="../img/tips.2.png" width="60%"></br>
团队意识到此处可能存在一点问题：Sprint 的更新事务该如何管理？
我们本可以让消息 handler 来负责这项工作，但无论采用哪种方式，处理器中的代码都需要进行一些重构。最佳做法是让 handler 将这项工作委托给 [Application Service (14)](../ch14/0.md) ，以契合 [Hexagonal Architecture (4)](../ch4/0.md) 的设计理念。这样一来，`Application Service`便可负责事务管理，这原本就是应用层需要关注的核心职责之一。在这种设计下，handler 的代码将会调整为如下形式：

```java
MessageConsumer.instance(messageSource, false)
    .receiveOnly(
            new String[] { "BacklogItemCommitted" },
            new MessageListener(Type.TEXT) {
        @Override
        public void handleMessage(
            String aType,
            String aMessageId,
            Date aTimestamp,
            String aTextMessage,
            long aDeliveryTag,
            boolean isRedelivery)
        throws Exception {
            // get tenantId, sprintId, and backlogItemId from JSON
            String tenantId = ...
            String sprintId = ...
            String  backlogItemId = ...

            ApplicationServiceRegistry
            .sprintService()
            .commitBacklogItem(
                    tenantId, sprintId, backlogItemId);
        }
    });
```

---

在本示例中，无需对事件进行重复数据消除处理，因为将 BacklogItem 提交至 Sprint 是一项幂等操作。若该 BacklogItem 已提交至对应 Sprint，再次提交的请求会直接被忽略。

若订阅方需要的信息不仅限于事件的触发原因，那么就可能需要为事件补充额外的状态和行为。这些信息可通过增强状态（更多 properties）或提供能派生更多状态的操作来传递。这样一来，订阅方便无需回查发布该事件的`Aggregate`，避免了可能产生的不必要的操作难度或性能开销。在采用`Event Sourcing`时，事件增强的做法会更为常见，因为用于持久化的事件在跨`Bounded Context`发布时，往往需要包含更多状态信息。有关事件增强的示例可参见 [附录 A](../appendix/0.md) 。

---
➜**白板时间**

- 列出你所负责的领域中已经发生、但尚未被捕获的各类事件。
- 记录将这些事件明确纳入模型后，会从哪些方面优化你的设计。

识别那些依赖其他`Aggregates`状态（且需保证最终一致性）的`Aggregates`，或许是最便捷的切入点。

---

若要通过操作来派生更丰富的状态，需确保事件的所有附加行为均`Side-Effect Free`，这一点与 [Value Objects (6)](../ch6/0.md) 的设计原则一致，以此保障事件对象的不可变性。

### 结合`Aggregate`特征

有时事件会被设计为由客户端直接请求创建。这种设计通常用于应对如下场景：某一事件的发生，并非模型中`Aggregate`实例执行特定行为后的直接结果。例如系统用户发起的某一操作本身就被认定为一个独立事件。在此类场景下，该事件可被建模为一个`Aggregate`，并存储在专属的`Repository`中。由于事件表征的是已发生的事实，其对应的`Repository`不应允许对该事件进行删除操作。

当事件以这种方式建模时，它们会如同`Aggregates`一般，成为模型结构的一部分。因此，事件不仅是对过往发生事实的记录（尽管这也是其核心作用之一），还具备了更丰富的模型层面的意义。

这类事件仍需遵循不可变的设计原则，但可为其分配一个自动生成的唯一标识。不过，事件的唯一标识也可由其多个 properties 共同支撑。即便通过一组 properties 就能确定唯一标识，参考 [Entities (5)](../ch5/0.md) 的设计思路，为事件分配自动生成的唯一标识仍是更佳选择。这能确保事件在后续经历各类设计变更时，其在所有事件中的唯一性不会受到影响。

当事件以这种方式建模时，它可在被添加至其`Repository`的同时，通过消息传递基础设施完成发布。客户端可调用 [Domain Service (7)](../ch7/0.md) 来创建该事件、将其存入`Repository`，随后通过消息传递基础设施发布该事件。
采用这种方案时，需满足以下任一条件以确保操作的一致性：
`Repository`与消息传递基础设施必须基于同一个持久化实例（数据源）；
若使用不同数据源，则需借助全局事务（也称为 XA 事务或两阶段提交）来保证两者均能成功提交。

当消息传递基础设施成功将新的事件消息保存至其持久化存储后，便会以异步方式将该消息发送至所有队列监听器、主题/交换器订阅者；若采用 Actor 模型，则会发送至对应的参与者 <sup>[1](#1)</sup>。
若消息传递基础设施使用的持久化存储与领域模型所用的存储相互独立，且该基础设施不支持全局事务，那么`Domain Service`必须确保事件首先被保存至`Event Store`，在这种情况下，`Event Store`同时还会充当异步发布的消息队列。`Store`中的每一个事件都会由转发组件处理，并通过消息传递基础设施向外发送。本章后续将详细探讨这一技术方案。

### 标识

我们先来明确为事件分配唯一标识的原因。尽管有时可能需要区分不同的事件，但这种需求其实很少见。在事件被触发、创建并发布的`Bounded Context`中，往往几乎没有（即便有也极少）需要将一个事件与另一个事件进行比较的场景。但如果出于某些原因，必须对事件进行比较呢？此外，若事件被建模为`Aggregate`，又该如何处理？

如同`Value Objects`的设计逻辑，仅通过事件自身的 properties 来表征其标识或许就已足够。事件的名称/类型、触发该事件所涉及的`Aggregate(s)`（一个或多个）的标识，以及事件发生时的时间戳，这些信息结合起来通常足以将该事件与其他事件区分开来。

在事件被建模为`Aggregate`的场景下，或是在其他需要对事件进行比较、但事件的 properties 组合无法唯一区分它们的情况下，我们可以为事件分配一个正式的唯一标识。不过，为事件分配唯一标识也可能源于其他考量。

当事件被发布至其产生的本地`Bounded Context`之外、由消息传递基础设施进行转发时，唯一标识就可能成为必需的。在某些情况下，单条消息可能会被多次投递。如果消息发送方在消息传递基础设施确认消息已发送前发生崩溃，就会出现这种情况。

无论导致消息重复投递的原因是什么，解决方案都是让远程订阅方检测出重复的消息投递，并忽略已接收过的消息。为便于实现这一点，部分消息传递基础设施会在消息体的头部/信封中附带唯一的消息标识，这样领域模型就无需自行生成该标识。即便消息系统本身不会自动为所有消息分配唯一标识，发布方也可将唯一标识分配给事件本身或消息载体。无论采用哪种方式，远程订阅方都能利用该唯一标识，在消息被多次投递时完成重复消息的去重处理。

是否需要实现 equals() 和 hashCode() 方法？通常情况下，只有当本地`Bounded Context`需要用到这两个方法时，才有实现的必要。通过消息传递基础设施发送的事件，在被订阅方接收时，有时并不会被重构为其原生的类型化对象，而是以 XML、JSON 或键值对 maps 等形式被消费。但另一方面，若事件被建模为`Aggregate`并存储至专属的`Repository`中，那么该事件类型就应当提供这两个标准方法。

#### ▶[下一节](3.md)

---
#### 1
可参考 Erlang 和 Scala 中基于 Actor 模型实现的并发机制。值得一提的是，若你使用 Scala 或 Java 开发，Akka 框架是极具参考价值的选择。
