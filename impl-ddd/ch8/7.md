## 实现

#### ▶[上一节](6.md)

在确定了用于发布事件的架构风格后，SaaSOvation 团队如今正专注于相关组件的实现工作，以达成这一目标……

---

| ||
|---|---|
| 通知发布行为的核心被封装在一个`Application Service`，NotificationService 。这使得团队能够管理其自有数据源中变更的事务范围，同时也凸显了一点：尽管作为通知发布的事件源于领域模型，但通知本身是一个应用层关注点，而非领域层关注点。 |<img src="../img/ovation.4.png" width="50%"/>|

NotificationService 并不需要设计为`Separated Interface`[[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] 。目前该`Application Service`仅需一个实现版本，因此团队选择保持设计简洁。即便如此，每个简单类都具备公共接口，以下是该服务的方法桩 (stubbed-out) 实现：

```java
package com.saasovation.identityaccess.application;
...
public class NotificationService {
    ...
    @Transactional(readOnly=true)
    public NotificationLog currentNotificationLog() {
        ...
    }

    @Transactional(readOnly=true)
    public NotificationLog notificationLog(String aNotificationLogId) {
        ...
    }

    @Transactional
    public void publishNotifications() {
        ...
    }
    ...
}
```

前两个方法将用于查询 NotificationLog 实例（这些实例会以 RESTful 资源的形式提供给客户端），第三个方法则用于通过消息传递机制发布单个 Notification 实例。团队会先着手实现用于获取 NotificationLog 实例的查询方法，之后再将注意力转向与消息中间件进行交互的那个方法。

---

接下来，将会有一些颇具亮点的实现工作展开。

### 发布 NotificationLog

回顾一下，通知日志分为两种类型：当前日志（current log）和归档日志（archived log）。因此，NotificationService 接口为这两种日志分别提供了对应的查询方法：

```java
public class NotificationService {
    @Transactional(readOnly=true)
    public NotificationLog currentNotificationLog() {
        EventStore eventStore = EventStore.instance();
        return this.findNotificationLog(
                this.calculateCurrentNotificationLogId(eventStore),
                eventStore);
    }

    @Transactional(readOnly=true)
    public NotificationLog notificationLog(String aNotificationLogId) {
        EventStore eventStore = EventStore.instance();
        return this.findNotificationLog(
                new NotificationLogId(aNotificationLogId),
                eventStore);
    }
    ...
}
```

最终，这两个方法都必须 “查找” 一个 `NotificationLog` 实例。而这一操作的本质，是从`Event Store`中找到一段已序列化的 `DomainEvent` 实例，每个实例用 `Notification` 封装，再将所有这些 `Notification` 收集起来，构建成一个 `NotificationLog` 实例。一旦 `NotificationLog` 实例创建完成，它就可以被转化为 RESTful 资源，提供给发起请求的客户端。

由于当前日志（current log）的内容可能处于持续变化之中，因此它的标识必须在每次被请求时重新计算。以下是具体的计算逻辑：

```java
public class NotificationService {
    ...
    protected NotificationLogId calculateCurrentNotificationLogId(
            EventStore anEventStore) {
        long count = anEventStore.countStoredEvents();
        long remainder = count % LOG_NOTIFICATION_COUNT;
        if (remainder == 0) {
            remainder = LOG_NOTIFICATION_COUNT;
        }
        long low = count - remainder + 1;
        // ensures a minted id value even though there may
        // not be a full set of notifications at present
        long high = low + LOG_NOTIFICATION_COUNT - 1;
        return new NotificationLogId(low, high);
    }
    ...
}
```

而对于归档日志（archived log），所需的仅仅是一个 `NotificationLogId`，它用于封装标识的上下限范围。要记住，这个标识是以文本形式编码的数值范围来表示的，例如 `21–40`。
因此，用于编码该标识的构造函数如下所示：

```java
public class NotificationLogId {
    ...
    public NotificationLogId(String aNotificationLogId) {
        super();
        String[] textIds = aNotificationLogId.split(",");
        this.setLow(Long.parseLong(textIds[0]));
        this.setHigh(Long.parseLong(textIds[1]));
    }
    ...
}
```

无论查询的是当前日志还是归档日志，我们此时都已拥有一个 `NotificationLogId`，它明确了 `findNotificationLog()` 方法需要查询的内容：

```java
public class NotificationService {
    ...
    protected NotificationLog findNotificationLog(
            NotificationLogId aNotificationLogId,
            EventStore anEventStore) {

        List<StoredEvent> storedEvents =
            anEventStore.allStoredEventsBetween(
                    aNotificationLogId.low(),
                    aNotificationLogId.high());

        long count = anEventStore.countStoredEvents();

        boolean archivedIndicator = aNotificationLogId.high() < count;

        NotificationLog notificationLog =
            new NotificationLog(
                    aNotificationLogId.encoded(),
                    NotificationLogId.encoded(
                            aNotificationLogId.next(
                                    LOG_NOTIFICATION_COUNT)),
                    NotificationLogId.encoded(
                            aNotificationLogId.previous(
                                    LOG_NOTIFICATION_COUNT)),
                    this.notificationsFrom(storedEvents),
                    archivedIndicator);

        return notificationLog;
    }
    ...
    protected List<Notification> notificationsFrom(
            List<StoredEvent> aStoredEvents) {
        List<Notification> notifications =
            new ArrayList<Notification>(aStoredEvents.size());

        for (StoredEvent storedEvent : aStoredEvents) {
            DomainEvent domainEvent =
                    EventStore.toDomainEvent(storedEvent);

            Notification notification =
                new Notification(
                        domainEvent.getClass().getSimpleName(),
                        storedEvent.eventId(),
                        domainEvent.occurredOn(),
                        domainEvent);

            notifications.add(notification);
        }
        return notifications;
    }
    ...
}

```
颇具趣味的是，我们并不需要实际持久化任何 `Notification` 实例或完整的日志。每当需要这些对象时，我们直接动态生成即可。显然，正因为这一点，在请求节点对 `NotificationLog` 资源进行缓存，将极大地提升系统性能和可扩展性。

`findNotificationLog()` 方法会借助 `EventStore` 组件，查询某份指定日志所需的 `StoredEvent` 实例。`EventStore` 的查询逻辑如下：

```java
package com.saasovation.identityaccess.application.eventStore;
...
public class EventStore ... {
    ...
    public List<StoredEvent> allStoredEventsBetween(
            long aLowStoredEventId,
            long aHighStoredEventId) {

        Query query =
            this.session().createQuery(
                "from StoredEvent as _obj_ "
                + "where _obj_.eventId between ? and ? "
                + "order by _obj_.eventId");

        query.setParameter(0, aLowStoredEventId);
        query.setParameter(1, aHighStoredEventId);

        List<StoredEvent> storedEvents = query.list();

        return storedEvents;
    }
    ...
}
```

最后，在 Web 层中，我们对外发布当前日志和归档日志：

```java
 @Path("/notifications")
public class NotificationResource {
    ...
    @GET
    @Produces({ OvationsMediaType.NAME })
    public Response getCurrentNotificationLog(
            @Context UriInfo aUriInfo) {
    
         NotificationLog currentNotificationLog =
            this.notificationService()
                .currentNotificationLog();

        if (currentNotificationLog == null) {
            throw new WebApplicationException(
                    Response.Status.NOT_FOUND);
        }

        Response response =
            this.currentNotificationLogResponse(
                    currentNotificationLog,
                    aUriInfo);

        return response;
    }

    @GET
    @Path("{notificationId}")
    @Produces({ OvationsMediaType.ID_OVATION_NAME })
    public Response getNotificationLog(
            @PathParam("notificationId") String aNotificationId,
            @Context UriInfo aUriInfo) {

        NotificationLog notificationLog =
            this.notificationService()
                .notificationLog(aNotificationId);

        if (notificationLog == null) {
            throw new WebApplicationException(
                    Response.Status.NOT_FOUND);
        }

        Response response =
            this.notificationLogResponse(
                    notificationLog,
                    aUriInfo);

        return response;
    }
    ...
}
```

团队本可以使用 `MessageBodyWriter` 来生成响应，但响应构建方法中需要处理一些必要的细微复杂逻辑，因此最终没有采用这种方式。

以上内容涵盖了向 RESTful 客户端发布当前日志和归档日志的核心实现要点。

### 发布基于消息的通知

`NotificationService` 提供了一个单独的方法，用于通过消息中间件发布 `DomainEvent` 实例。该服务方法如下所示：

```java
public class NotificationService {
    ...
    @Transactional
    public void publishNotifications() {

        PublishedMessageTracker publishedMessageTracker =
            this.publishedMessageTracker();

        List<Notification> notifications =
            this.listUnpublishedNotifications(
                publishedMessageTracker
                    .mostRecentPublishedMessageId());

        MessageProducer messageProducer = this.messageProducer();

        try {
            for (Notification notification : notifications) {
                this.publish(notification, messageProducer);
            }

            this.trackMostRecentPublishedMessage(
                    publishedMessageTracker,
                    notifications);
        } finally {
            messageProducer.close();
        }
    }
    ...
}
```

`publishNotifications()` 方法首先会获取它的 `PublishedMessageTracker` 实例。这个对象的作用是持久化记录哪些事件已经被成功发布过：

```java
package com.saasovation.identityaccess.application.notifications;
...
public class PublishedMessageTracker {
    private long mostRecentPublishedMessageId;
    private long trackerId;
    private String type;
    ...
}
```

请注意，该类并非领域模型的一部分，而是属于应用层。
`trackerId` 仅是该对象的唯一标识（本质上是一个`Entity`）。`type` 属性存储了事件发布所用主题/通道类型的字符串描述。`mostRecentPublishedMessageId` 属性对应着那些已被序列化并持久化为 `StoredEvent` 的单个 `DomainEvent` 的唯一标识。因此，该属性存储的是最近一次发布的 `StoredEvent` 实例的 `eventId` 值。当所有新的 `Notification` 消息发送完毕后，该服务方法会确保 `PublishedMessageTracker` 被保存，且其中记录的最近发布事件标识更新为本次发布的最新事件标识。

事件标识与 `type` 属性相结合， *使我们能够在不同时间将相同的通知发布到任意数量的主题/通道* 。我们只需创建一个新的 `PublishedMessageTracker` 实例，将主题/通道的名称作为其 `type` 属性值，然后从第一条 `StoredEvent` 开始重新进行发布即可。事实上，`publishedMessageTracker()` 方法就是这样实现的：

```java
public class NotificationService {
    private static final String EXCHANGE_NAME =
            "saasovation.identity_access";
    ...
    private PublishedMessageTracker publishedMessageTracker() {
        Query query =
            this.session().createQuery(
                    "from PublishedMessageTracker as _obj_ "
                    + "where _obj_.type = ?");

        query.setParameter(0, EXCHANGE_NAME);

        PublishedMessageTracker publishedMessageTracker =
            (PublishedMessageTracker) query.uniqueResult();

        if (publishedMessageTracker == null) {
            publishedMessageTracker =
                new PublishedMessageTracker(EXCHANGE_NAME);
        }

        return publishedMessageTracker;
    }
    ...
}
```

目前尚未支持多通道发布，但只需进行少量重构，就能轻松添加这一功能。

接下来，`listUnpublishedNotifications()` 方法负责查询所有未发布 `Notification` 实例的排序列表：

```java
public class NotificationService {
    ...
    protected List<Notification> listUnpublishedNotifications(
            long aMostRecentPublishedMessageId) {
        EventStore eventStore = EventStore.instance();

        List<StoredEvent> storedEvents =
                eventStore.allStoredEventsSince(
                        aMostRecentPublishedMessageId);

        List<Notification> notifications =
            this.notificationsFrom(storedEvents);

        return notifications;
    }
    ...
}
```

实际上，该方法会向 `EventStore` 发起查询，获取所有 `eventId` 大于参数 `aMostRecentPublishedMessageId` 所存储值的 `StoredEvent` 实例。从 `EventStore` 返回的这些实例，会被用于创建一个全新的 `Notification` 实例集合。

现在，我们回到核心服务方法 `publishNotifications()`。拿到封装了 `DomainEvent` 的 `Notification` 实例集合后，该方法会遍历这个集合，并调用 `publish()` 方法进行消息分发：

```java
...
for (Notification notification : notifications) {
    this.publish(notification, messageProducer);
}
```

该方法负责发布单个 `Notification` 实例，它通过 RabbitMQ 完成消息发布，同时借助一个非常简洁的对象库，使其接口更具面向对象的风格：

```java
public class NotificationService {
    ...
    protected void publish(
            Notification aNotification,
            MessageProducer aMessageProducer) {

        MessageParameters messageParameters =
            MessageParameters.durableTextParameters(
                    aNotification.type(),
                    Long.toString(aNotification.notificationId()),
                    aNotification.occurredOn());
    
         String notification =
            NotificationService
                .objectSerializer()
                .serialize(aNotification);

        aMessageProducer.send(notification, messageParameters);
    }
    ...
}
```

这个 `publish()` 方法会先创建 `MessageParameters` 实例，然后通过 `MessageProducer` 将序列化后的 `DomainEvent` 发送出去 <sup>[3](#3)</sup> 。
`MessageParameters` 中包含了一些需要随消息体一同发送的特定 properties。在这些特殊参数中，包括事件 `type` 字符串、用作唯一消息 ID 的通知标识，以及事件的 `occurredOn` 。这些参数使得订阅者无需解析作为序列化事件的 JSON 消息体，就能获取每条消息的关键信息。而作为唯一消息 ID 的通知标识，还支持消息去重功能（这一点后续会详细说明）。

我们再来看一个用于完整实现消息发布功能的方法：

```java
public class NotificationService {
    ...
    private MessageProducer messageProducer() {

        // create my exchange if nonexistent
        Exchange exchange =
            Exchange.fanOutInstance(
                    ConnectionSettings.instance(),
                    EXCHANGE_NAME,
                    true);

        // create a message producer used to forward Events
        MessageProducer messageProducer =
            MessageProducer.instance(exchange);

        return messageProducer;
    }
    ...
}
```

`publishNotifications()` 方法通过 `messageProducer()` 方法确保交换机（exchange）已存在，随后获取用于消息发布的 `MessageProducer` 实例。RabbitMQ 支持交换机的幂等性，因此首次请求创建交换机时，该交换机会被创建；后续所有相同请求都会直接返回已存在的该交换机。
我们不会保留 `MessageProducer` 的持久连接实例，以防底层消息代理通道出现意外故障。每次执行发布操作时重新建立连接，有助于避免发布者完全无法工作的情况发生。如果频繁重连成为性能瓶颈，我们可能需要关注潜在的性能问题。但目前，我们会依靠配置的发布操作间隔时间，来减轻重连带来的额外开销。

说到发布操作之间的间隔，前面的代码都没有说明如何定期、重复地将事件发布到交换机。这可以通过多种不同方式实现，具体可能取决于你的运行环境。例如，可以使用 JMX `TimerMBean` 来管理重复的时间间隔。

在介绍下面的定时器解决方案之前，有一个重要的背景需要说明：Java MBean 标准中也使用了 *notification*这个术语，但它和我们本次发布流程中所使用的并不是同一个概念。在这个场景下，监听器接收的是定时器每次触发时的 “通知”。你只需在脑海中区分清楚这两个概念即可。

无论为指定定时器确定并配置了何种合适的时间间隔，都会注册一个 `NotificationListener`，以便当每次达到设定间隔时，`MBeanServer` 能够发出相应通知：

```java
mbeanServer.addNotificationListener(
        timer.getObjectName(),
        new NotificationListener() {
            public void handleNotification(
                    Notification aTimerNotification,
                    Object aHandback) {
                ApplicationServiceRegistry
                        .notificationService()
                        .publishNotifications();
            }
        },
        null,
        null);
```

在这个示例中，当定时器触发并调用 `handleNotification()` 方法时，该方法会请求 `NotificationService` 执行其 `publishNotifications()` 操作。这就是实现该功能所需的全部步骤。只要 `TimerMBean` 持续按设定的固定间隔触发，`Domain Events`就会持续通过交换机发布，并被企业内的各类订阅者消费。

使用应用服务器管理的定时器有一个额外优势：你无需创建专门的组件来监控发布流程的生命周期。例如，若 `publishNotifications()` 方法在某次执行中因某种原因出现问题并抛出异常终止，`TimerMBean` 仍会继续运行，并在后续的时间间隔点正常触发。管理员可能需要解决一些基础设施层面的错误（比如与 RabbitMQ 相关的问题），但一旦这些问题得到解决，消息发布就会恢复正常。话虽如此，还有其他可用的定时器工具，比如 [[Quartz](../bibli.md#quartz)] 。

不过，关于消息去重，我们仍有一些问题需要解答。什么是消息去重？为什么消息订阅者需要支持消息去重功能？

### 事件去重

在消息系统中，一条已发布的消息有可能被多次投递到订阅者手中，因此在这类环境中，去重是一项必不可少的功能。消息重复的产生原因有多种，其中一种场景如下：

1.  RabbitMQ 将新发送的消息投递至一个或多个订阅者。
2.  订阅者对这些消息进行处理。
3.  订阅者尚未确认消息已被接收并处理完成，就发生了故障。
4.  RabbitMQ 会将这些未被确认的消息再次进行投递。

当从`Event Store`发布消息时，如果消息系统不共享`Event Store`的持久化机制，且没有全局 XA 事务来控制`Event Store`和消息系统持久化变更的原子提交，那么消息重复的可能性也会存在。正如之前在 [通过消息中间件发布通知](6.md#通过消息中间件发布通知) 一节中所讨论的，这正是我们当前面临的情况。我们来看一个能凸显消息可能被多次发送的场景：

1.  `NotificationService` 查询并发布了三条未发布的 `Notification` 实例，同时通过 `PublishedMessageTracker` 更新了此次发布的记录。
2.  RabbitMQ 消息代理接收了这三条消息，并准备将它们发送给所有订阅者。
3.  然而，由于应用服务器出现某种异常情况，`NotificationService` 发生故障，对 `PublishedMessageTracker` 的修改未能提交。
4.  RabbitMQ 将这些新接收的消息投递至订阅者。
5.  应用服务器的异常问题被修复后，消息发布流程重新启动，`NotificationService` 成功发送所有未发布事件对应的消息。这包括重新发送所有之前已发布但 `PublishedMessageTracker` 未知的事件的消息。
6.  RabbitMQ 将这些新发送的消息再次投递至订阅者，其中至少有三条消息属于重复投递。

在这个场景中，我随意选取了三条事件作为示例，实际上选取一条、两条、四条或者更多条都可以。事件的数量并不重要，重要的是这类问题确实可能导致消息被重新投递。当你面临这种情况以及其他引发消息重复的原因时，去重功能就必不可少了。关于更详尽的阐述，可参考`Idempotent Receiver` [[Hohpe & Woolf](../bibli.md#hohpe--woolf)] 。

---
➜**幂等操作**

幂等操作 (idempotent operation) 是指一种可以连续执行两次或更多次，且执行结果与仅执行一次该操作完全相同的操作。

---

应对消息重复投递问题的一种方式，是让订阅者侧的模型操作具备幂等性。订阅者对所有消息的响应，都可以是针对其自身领域模型执行的幂等操作。但问题在于，设计一个具备幂等性的领域对象（或者就此而言，任何对象），可能会非常困难、不切实际，甚至完全无法实现。此外，如果我们试图让事件本身携带能够体现待执行幂等操作的信息，这也会带来诸多麻烦。一方面，发送者必须充分了解所有接收者当前的业务状况，以及这些接收者针对即将发送的事件状态会做出的反应；另一方面，由于延迟、重试等因素导致事件接收顺序错乱，也可能引发错误。

当领域对象的幂等性不是一个可行方案时，你可以转而将订阅者/接收者本身设计为具备幂等性。接收者可以被设计为拒绝响应重复消息而执行相关操作。首先，你应当检查所使用的消息产品是否支持该功能。如果不支持，你的接收者就需要跟踪哪些消息已经被处理过。
实现该跟踪的一种方式是在订阅者的持久化机制中分配一块区域，保存主题/交换机的名称，以及所有已处理消息的唯一消息 ID —— 没错，这与`PublishedMessageTracker`的机制类似。之后，你可以在处理每条消息之前查询是否存在重复。如果查询发现某条消息已经被处理过，订阅者只需直接忽略该消息即可。
已处理消息的跟踪逻辑不属于领域模型的一部分，它仅应被视作针对常见消息系统特性问题的一种技术变通方案。

当使用一款典型的消息中间件产品时，仅保存最近一条已处理消息的记录是远远不够的，因为消息有可能会乱序接收。因此，若去重查询仅校验消息 ID 是否小于最新处理的消息 ID，将会导致你忽略一些因乱序而接收的有效消息。此外，还需要考虑的是，有时你需要丢弃所有已失效的已处理消息跟踪记录，这类似于数据库的垃圾回收机制。

当使用基于 REST 的通知方案时，消息去重实际上并不构成需要重点考虑的因素。客户端接收者只需保存最近一次已应用的通知标识即可，因为它们只会应用那些标识晚于该值的事件通知。每份通知日志都会始终按照通知标识以逆时间顺序（降序）排列。

在这两种场景下——无论是消息中间件的订阅者，还是基于 REST 的通知客户端 —— 一个关键点是：已处理消息标识的跟踪记录，必须与本地领域模型状态的所有变更一同提交。否则，你将无法在响应事件所做的修改与跟踪记录之间维持一致性。

<center><img src="../img/ownit.png" align="center" width="30%" /></center>

#### ▶[下一节](8.md)

---

#### 3

`Exchange`、`ConnectionSettings`、`MessageProducer`、`MessageParameters` 及其他相关类均属于一个作为 RabbitMQ 抽象层的类库。我已将这个让 RabbitMQ 的使用更加面向对象友好的类库，与本书的其他示例代码一同提供。
