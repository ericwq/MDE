## 将事件通知传递至远程`Bounded Contexts`

#### ▶[上一节](3.md)

远程`Bounded Contexts`要知晓你所在`Bounded Context`中发生的事件，有多种可行方式。核心思路是需要进行某种形式的消息传递，且离不开企业级消息传递机制。需要明确的是，这里所说的机制，已经远超我们刚刚讨论的简单、轻量级`Publish-Subscribe`组件。这里我们讨论的是轻量级机制无法覆盖的部分所需要的机制。

这类消息传递组件种类繁多，它们通常被归类为中间件。从开源的 ActiveMQ、RabbitMQ、Akka、NServiceBus 和 MassTransit，到各类商业授权产品，可供选择的方案十分丰富。我们也可以基于 REST 资源构建一套自定义的消息传递机制，让自治系统作为相关方主动对接发布系统，请求获取所有其尚未消费过的事件通知。所有这些方案都属于`Publish-Subscribe`模式（详见 [[Gamma et al.](../bibli.md#gamma-et-al)] ）的范畴，只是各有优劣。具体选择在很大程度上取决于相关团队的预算、偏好、功能需求以及所追求的非功能特性。

在`Bounded Contexts`之间使用任何此类消息传递机制，都要求我们接受最终一致性原则，这是无法规避的。在某个模型中发生的修改、会影响一个或多个其他模型发生变更，在一段时期内都无法实现完全一致。此外，根据各个系统的访问流量及其对其他系统造成的影响，整个系统集群甚至可能在任何一个时间点都无法实现完全一致。

### 消息传递基础设施的一致性

在大量讨论最终一致性的背景下，你可能会感到惊讶：<ins>消息传递解决方案中至少有两种机制必须始终保持一致：即领域模型所使用的持久化存储，以及为转发那些模型发布的事件而搭建的消息传递基础设施所依赖的持久化存储。这一要求是为了确保：当模型的变更被持久化后，事件的传递也能得到保障；同时，若一个事件通过消息传递被送达，这意味着该事件反映了发布它的模型所处的真实状态。如果这两者中的任意一个与另一个不同步，将会导致一个或多个相互依赖的模型陷入错误状态。</ins>

如何实现模型与事件持久化的一致性呢？有三种基本方法：

1. 你的领域模型与消息传递基础设施共享同一个持久化存储（例如，同一个数据源）。这使得模型的变更与新消息的插入能够在同一个本地事务中提交。这种方法的优势是性能相对出色，而潜在劣势在于，消息系统的存储区域（如数据库表）必须与你的模型存储位于同一个数据库（或 schema ）中，这可能是一个取决于个人偏好的问题。当然，如果你的模型存储与所选消息传递机制的存储无法共享，那么这种方案就不具备可行性。

2. 领域模型的持久化存储与消息传递持久化存储在一个全局 XA 事务（两阶段提交）的管控下。这种方法的优势是可以将模型存储与消息传递存储相互分离。劣势则在于，全局事务需要特殊的支持，而并非所有持久化存储或消息传递系统都具备该支持能力。此外，全局事务通常开销较大、性能表现不佳，而且模型存储、消息传递机制存储，或是两者都有可能不兼容 XA 规范。

3. 在用于存储领域模型的同一个持久化存储中，为事件创建一个专门的存储区域（例如，一张数据库表）。这就是本章后续将讨论的`Event Store`。这种方式与方案 1 类似，但不同的是，该存储区域并非由消息传递机制拥有和管控，而是归属于你的`Bounded Context`。你需要创建一个外部组件，该组件利用`Event Store`，通过消息传递机制发布所有已存储但尚未发布的事件。
这种方法的优势在于，能够在单个本地事务中保证模型与事件的一致性。此外，它还具备`Event Store`所特有的诸多优势，包括能够生成基于 REST 的通知馈送。这种方案允许使用消息存储完全私有化的消息传递基础设施。
不过，由于`Event Store`完成后才会调用中间件消息传递机制，该方法也存在一些劣势：事件转发器必须进行自定义开发，才能通过消息传递机制发送事件；同时，客户端也必须设计为能够对传入消息进行去重处理（详见 [事件存储](#TODO) 一节）。 *TODO fix links*

我在示例中采用的正是第三种方案。尽管该方案存在一些劣势，但它也具备若干优势，这些优势会在 [事件存储](#TODO) 一节中详细阐明。我选择这一方案，绝不意味着其他权衡取舍方案就没有价值。你和你的团队必须从中自行做出选择。 *TODO fix links*

### 自治服务与系统

使用`Domain Events`可以让企业中的任何数量系统被设计为 *自治服务和系统* 。我使用 *自治服务* 这一术语来指代任何粗粒度的业务服务（它也可能被视为一个系统或应用程序），这类服务在很大程度上独立于企业内其他同类 “服务” 运行。一个自治服务可能拥有多个服务接口端点，也就是说，它可以向远程客户端提供众多潜在的技术服务接口。通过避免同步远程过程调用（RPC），可以实现与其他系统的高度解耦：在同步远程过程调用中，只有成功完成对远程系统的 API 请求，才能满足用户的当前请求。

因为远程系统有时可能完全不可用，或是处于高负载状态，RPC 可能会影响到依赖它的系统的运行成功率。随着某个系统所依赖的、提供 RPC API 的系统数量不断增加，这种风险也会随之倍增。因此，避免同步 RPC 能够极大地减轻系统间的依赖，同时也能大幅减少因远程系统不可用或吞吐量低下而导致的系统完全故障，以及/或者性能无法接受等相关问题。

不必调用其他系统，而是通过异步消息传递实现系统间更高程度的独立性——即自治性。当接收到企业内各个`Bounded Contexts`发出的、承载`Domain Events`的消息时，在你的模型上执行相应行为，以体现这些事件在你所属`Bounded Context`中的含义。这并不意味着你只需简单地复制数据，或将其他业务服务的对象完整拷贝到你的业务服务中。诚然，系统之间可能会存在部分数据的复制，至少复制的数据中会包含外部`Aggregates`的某些唯一标识。但一个系统中的对象，几乎不会与周边其他系统的对象完全一致。如果存在这种可能的建模错误，可参阅 [Bounded Contexts (2)](../ch2/0.md) 和 [Context Maps (3)](../ch3/0.md) ，了解其问题所在以及规避方法。事实上，若`Domain Events`设计得当，其状态中几乎不会携带完整的对象。

事件会包含少量有限的命令参数和/或`Aggregate`状态，这些内容足以传递清晰的含义，让订阅该事件的`Bounded Contexts`能够做出正确响应。当然，如果某个事件未能为某个订阅者提供足够的信息，就必须修改该事件的跨领域约定 (contract)，以补充所需内容。这很可能意味着需要明确设计一个新版本的事件，或是设计一个全新的事件。

诚然，在某些情况下，RPC 的使用难以轻易避免。部分遗留系统可能仅能提供 RPC 方式的调用。此外，当将外部`Bounded Context`中的某个概念或一组概念转换为你本地`Bounded Context`的概念时，若操作难度极高，那么从多个事件中推导出足够的语义信息，往往会增加系统的复杂度。如果你的模型必须近乎复刻外部模型中的概念、对象及其关联关系，那么你或许需要考虑继续采用 RPC。此类情况必须根据具体场景逐一评估，我建议不要轻易妥协选择 RPC。若实在无法避免，要么接受使用 RPC，要么尝试影响负责外部模型的团队，寻找简化其设计的途径。诚然，后者即便并非完全不可能，实现起来也往往极为困难。

### 延迟容忍度

消息接收前可能存在的较长延迟（即最终一致性所代表的超过数毫秒的延迟）难道不会引发问题吗？考虑到不同步的数据可能导致错误乃至破坏性的操作，这一点无疑需要仔细斟酌。我们必须明确，状态达到一致的间隔时长多久是可接受的，多久的延迟又属于过长。领域专家通常能够精准把握可接受与不可接受延迟的界定标准。开发者可能会惊讶地发现，在大多数情况下，状态一致性间隔数秒、数分钟、数小时甚至数天都是完全可以容忍的。这并非意味着所有场景皆是如此，但我们绝不能想当然地认为，在任何领域中，都必须要求近乎实时的一致性。

有时，通过提出以下问题，能够得到富有参考价值的答案：在计算机出现之前，业务是如何运作的？或者如今在没有计算机的情况下，业务又该如何开展？即便是最简单的纸质化系统，也几乎无法做到即时一致性。如此看来，自动化的计算机系统同样能够容忍，甚至能够在最终一致性的模式下良好运行。<ins>我们或许可以得出这样的结论：最终一致性在商业层面具备更合理的意义。</ins>

设想一个用于规划团队未来活动的`Subdomain`。当任意一项独立活动获得审批通过时，便会发布一个反映该审批结果的`Domain Event`：TeamActivityApproved 。在此之前，已经发布过若干其他事件，记录了所有当前已通过活动的创建与定义过程。另一个`Bounded Context`会对该审批事件做出响应，结合其他所有已通过的活动，将最新就绪的活动安排在合适的时间启动。

我们知道，任何一项活动在开始前至少数周就会完成定义和审批。既然如此，即便用于将已审批活动纳入排期的相关事件，在审批完成后数分钟、数小时，甚至可能是数天才被接收，这会产生影响吗？或许数天的延迟无法接受。但如果是系统故障导致事件延迟了数小时——尽管这种情况不太可能发生——活动在数小时内未被排入日程表，是否属于完全无法容忍的延迟？答案是否定的，因为这类罕见的系统故障可以通过其他方式解决，而且活动本身毕竟还有数周才会开始。既然如此，在完全正常的情况下，同一事件即便出现最多数秒的典型延迟，也不仅是可以容忍的，更是完全可接受的。事实上，这类实际延迟甚至可能根本无法被察觉。

|牛仔逻辑||
|---|---|
| AJ：“这是肯塔基州式的‘马上’吗？”</br> LB：“这可能是纽约式的‘一分钟’吧。” |<img src="../img/cbl.1.png" width="50%"/>|

正如这个例子所印证的，其他业务服务也会要求更高的吞吐量。应当充分明确最大延迟容忍度，并且系统应具备相应的架构特性来满足这些要求，甚至实现优于要求的表现。必须在自治服务及其配套的消息传递基础设施中，设计高可用性与可扩展性，从而切实满足企业严格的非功能性需求。

#### ▶[下一节](5.md)
