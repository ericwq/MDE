## 在领域中建模`Service`

#### ▶[上一节](2.md)

根据`Domain Service`的目的，建模过程可能相当简单。你需要决定你的`Service`是否应该有一个`Separated Interface` [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] 。如果是，这可能就是接口的定义： ...

```java
package com.saasovation.identityaccess.domain.model.identity;

public interface AuthenticationService {
    public UserDescriptor authenticate(
            TenantId aTenantId,
            String aUsername,
            String aPassword);
}
```

该接口声明在同一 [Module (9)](../ch0/0.md) 中，与身份相关`Aggregates`（如 Tenant、User 和 Group ）在同一个`Module`。之所以这样做，是因为 AuthenticationService 是一个身份概念，我们目前将所有与身份相关的概念都放在 identity `Module`中。接口定义本身相当简单。只需一个操作，authenticate（），即可。

我们可以选择将实现类放在哪里。如果你使用 [Dependency Inversion Principle (4)](../ch4/0.md) 或 [Hexagonal (4)](../ch4/0.md) ，你可能会决定将这个略带技术性的实现类放在领域模型之外的位置。例如，技术实现可以放在`Infrastructure Layer`的一个`Module`中。

下面是这个类：

```java
package com.saasovation.identityaccess.infrastructure.services;

import com.saasovation.identityaccess.domain.model.DomainRegistry;
import com.saasovation.identityaccess.domain.model.identity.AuthenticationService;
import com.saasovation.identityaccess.domain.model.identity.Tenant;
import com.saasovation.identityaccess.domain.model.identity.TenantId;
import com.saasovation.identityaccess.domain.model.identity.User;
import com.saasovation.identityaccess.domain.model.identity.UserDescriptor;

public class DefaultEncryptionAuthenticationService
        implements AuthenticationService  {

    public DefaultEncryptionAuthenticationService() {
        super();
    }

    @Override
    public UserDescriptor authenticate(
            TenantId aTenantId,
            String aUsername,
            String aPassword) {
        if (aTenantId == null) {
            throw new IllegalArgumentException(
                    "TenantId must not be null.");
        }
        if (aUsername == null) {
            throw new IllegalArgumentException(
                    "Username must not be null.");
        }
        if (aPassword == null) {
            throw new IllegalArgumentException(
                    "Password must not be null.");
        }

        UserDescriptor userDescriptor = null;

        Tenant tenant =
            DomainRegistry
                .tenantRepository()
                .tenantOfId(aTenantId);
        if (tenant != null && tenant.isActive()) {
            String encryptedPassword =
                DomainRegistry
                    .encryptionService()
                    .encryptedValue(aPassword);
            User user =
                DomainRegistry
                    .userRepository()
                    .userFromAuthenticCredentials(
                            aTenantId,
                            aUsername,
                            encryptedPassword);
            if (user != null && user.isEnabled()) {
                userDescriptor = user.userDescriptor();
            }
        }
        return userDescriptor;
    }
}
```

该方法可以防止 null 参数。否则，如果在正常情况下身份验证过程失败，返回的 UserDescriptor 将为 null。

身份验证的执行流程为：首先通过 Tenant 标识从其`Repository`中尝试获取 Tenant 信息。若该 Tenant 存在且处于激活状态，则下一步对明文密码进行加密处理。此时执行加密操作，是因为后续将通过加密后的密码获取 User 信息。我们并非仅通过 TenantId 标识和匹配的 username 查询 User，还会将加密后的密码纳入匹配条件（两个相同的明文密码，其加密结果始终一致）。该`Repository`的设计逻辑为，基于上述三项条件进行联合筛选。

若人工用户提交了正确的租户标识、用户名和明文密码，系统将会检索到匹配的 User 实例。但这并不足以完全验证用户的身份合法性，还有一项最终验证要求尚未处理：

- 仅当用户处于启用状态时，方可对其进行身份验证。

即便`Repository`检索到了符合筛选条件的 User 实例，该实例也有可能已被禁用。提供 User 禁用功能，能让租户在另一层级对用户身份验证进行管控。因此，作为最后一步校验，User 实例必须同时满足非空且处于启用状态这两个条件，满足后系统会基于该 User 实例生成对应的 UserDescriptor。

### 分离接口是否为必要设计？

由于这个 AuthenticationService 没有技术实现，真的有必要创建一个`Separated Interface`和实现类，并将它们放在不同的层和`Modules`中吗？不，其实并非绝对必要。我们完全可以仅用一个实现类来创建这个特定的`Service`，并将其命名为该`Service`的名称：

```java
package com.saasovation.identityaccess.domain.model.identity;

public class AuthenticationService {
    public AuthenticationService() {
        super();
    }

    public UserDescriptor authenticate(
            TenantId aTenantId,
    }
}
```

这么做本身并无不妥。甚至你可以认为这是一种更贴合的做法，因为这款特定的`Service`或许永远都无需设置多个实现类。但考虑到不同租户最终可能会有定制化安全标准的需求，未来也存在设置多个实现类的可能性。不过就目前而言，团队已决定不再使用`Separated Interface`，而是采用下文所示的这个类来实现。

---
**实现类的命名规范**

在 Java 开发体系中，将实现类命名为接口名加 Impl 后缀的方式已十分常见。以本文的示例来说，按这种方式命名会得到 AuthenticationServiceImpl 这个类名。此外，接口与对应的实现类通常会放在同一个包中。这种做法是否可取？

事实上，如果你的实现类采用这种命名方式，这很可能就充分说明你要么并不需要`Separated Interface`，要么就需要更审慎地思考实现类的命名。因此，AuthenticationServiceImpl 这个名称其实并不算合适。但另一方面，DefaultEncryptionAuthenticationService 这个名称也并非特别实用。正因如此，SaaSOvation 团队决定暂时舍弃`Separated Interface`的设计，转而将 AuthenticationService 作为一个简单的普通类来实现。

若你的实现类因需要提供多个特定实现而具备明确的解耦目标，便应根据其专属特性为该类命名。为每个特定实现精心命名的必要性，恰恰印证了你的领域中存在各类专属业务特性。

有人认为，将接口与实现类采用相似的命名方式，会让包含大量这类接口/实现类对的包更便于查阅和导航。但也有人认为，从`Modules`设计的目标来看，这类包含大量类的包属于设计欠佳的情况。此外，秉持模块化聚焦设计目标的开发人员，还会倾向于将接口与各类实现类分置于不同的包中，这也是我们遵循 [Dependency Inversion Principle (4)](../ch4/0.md) 的做法。例如，EncryptionService 置于领域模型中，而 MD5EncryptionService 则放在基础设施层中。

为非技术性`Domain Services`舍弃`Separated Interface`的设计，并不会降低其可测试性，因为该`Service`所依赖的所有接口，均可通过测试配置的`Service Factory`实现注入或解析，也可根据需要将入站和出站依赖的实例作为参数传入。同时也需注意，这类非技术性、特定领域的`Services`（如各类计算服务），必须对其正确性开展测试验证。

这一话题存在争议实属情理之中，我也了解到有大批开发人员向来习惯以 Impl 后缀为接口实现类命名。但你也需知晓，业内同样存在另一派见解成熟的观点，他们有充分且合理的理由摒弃这种命名方式。一如既往，最终的选择仍由你自己决定。

---

若`Service`始终为特定领域服务，且永远不会有技术实现或多种实现形式，那么使用`Separated Interface`或许更多只是一种风格选择。正如 Fowler 在 [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] 中所言，若存在特定的解耦目标，`Separated Interface`便能发挥作用：“依赖于该接口的客户端可以完全无需知晓实现细节。” 但倘若你采用了`Dependency Injection`，或是`Service Factory` [[Gamma et al.](../bibli.md#gamma-et-al)] 模式，即便将`Service`的接口与实现类合并，依然能够避免客户端知晓具体实现。换言之，像下文这样将 DomainRegistry 用作`Service Factory`，就能实现客户端与实现层的解耦：

```java
// the registry decouples client from implementation knowledge
UserDescriptor userDescriptor =
    DomainRegistry
        .authenticationService()
        .authenticate(aTenantId, aUsername, aPassword);
```

而若采用`Dependency Injection`，你也能获得类似的效果。

```java
public class SomeApplicationService ... {
    @Autowired
    private AuthenticationService authenticationService;
    ...
}
```

控制反转容器（如 Spring）会注入该`Service`实例。由于客户端从未实例化过此`Service`，因此它并不会知晓接口与实现类是合并的还是分离的。

<ins>显然，部分开发人员对`Service Factory`和`Dependency Injection`这两种方式完全持排斥态度，他们更倾向于通过构造函数配置入站依赖，或是将依赖项作为方法参数传入。归根结底，这是实现依赖装配并保证代码可测试性的最直观方式，甚至可以说，这种方式比`Dependency Injection`更易上手</ins>。也有开发人员会根据实际场景，结合使用上述三种方式，只是整体上更偏爱基于构造函数的依赖配置方式。为便于理解，本章的多个示例均使用了 DomainRegistry ， *这一做法并非一定代表偏好* 。本书配套的线上开源源码，其大部分实现实际上更倾向于通过构造函数配置依赖，或是将依赖项直接作为参数传入方法。

#### ▶[下一节](4.md)
