## 在领域中建模`Service`

#### ▶[上一节](2.md)

根据`Domain Service`的目的，建模过程可能相当简单。你需要决定你的`Service`是否应该有一个`Separated Interface` [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] 。如果是，这可能就是接口的定义： ...

```java
package com.saasovation.identityaccess.domain.model.identity;

public interface AuthenticationService {
    public UserDescriptor authenticate(
            TenantId aTenantId,
            String aUsername,
            String aPassword);
}
```

该接口声明在同一 [Module (9)](../ch0/0.md) 中，与身份相关`Aggregates`（如 Tenant、User 和 Group ）在同一个`Module`。之所以这样做，是因为 AuthenticationService 是一个身份概念，我们目前将所有与身份相关的概念都放在 identity `Module`中。接口定义本身相当简单。只需一个操作，authenticate（），即可。

我们可以选择将实现类放在哪里。如果你使用 [Dependency Inversion Principle (4)](../ch4/0.md) 或 [Hexagonal (4)](../ch4/0.md) ，你可能会决定将这个略带技术性的实现类放在领域模型之外的位置。例如，技术实现可以放在`Infrastructure Layer`的一个`Module`中。

下面是这个类：

```java
package com.saasovation.identityaccess.infrastructure.services;

import com.saasovation.identityaccess.domain.model.DomainRegistry;
import com.saasovation.identityaccess.domain.model.identity.AuthenticationService;
import com.saasovation.identityaccess.domain.model.identity.Tenant;
import com.saasovation.identityaccess.domain.model.identity.TenantId;
import com.saasovation.identityaccess.domain.model.identity.User;
import com.saasovation.identityaccess.domain.model.identity.UserDescriptor;

public class DefaultEncryptionAuthenticationService
        implements AuthenticationService  {

    public DefaultEncryptionAuthenticationService() {
        super();
    }

    @Override
    public UserDescriptor authenticate(
            TenantId aTenantId,
            String aUsername,
            String aPassword) {
        if (aTenantId == null) {
            throw new IllegalArgumentException(
                    "TenantId must not be null.");
        }
        if (aUsername == null) {
            throw new IllegalArgumentException(
                    "Username must not be null.");
        }
        if (aPassword == null) {
            throw new IllegalArgumentException(
                    "Password must not be null.");
        }

        UserDescriptor userDescriptor = null;

        Tenant tenant =
            DomainRegistry
                .tenantRepository()
                .tenantOfId(aTenantId);
        if (tenant != null && tenant.isActive()) {
            String encryptedPassword =
                DomainRegistry
                    .encryptionService()
                    .encryptedValue(aPassword);
            User user =
                DomainRegistry
                    .userRepository()
                    .userFromAuthenticCredentials(
                            aTenantId,
                            aUsername,
                            encryptedPassword);
            if (user != null && user.isEnabled()) {
                userDescriptor = user.userDescriptor();
            }
        }
        return userDescriptor;
    }
}
```

该方法可以防止 null 参数。否则，如果在正常情况下身份验证过程失败，返回的 UserDescriptor 将为 null。

身份验证的执行流程为：首先通过 Tenant 标识从其`Repository`中尝试获取 Tenant 信息。若该 Tenant 存在且处于激活状态，则下一步对明文密码进行加密处理。此时执行加密操作，是因为后续将通过加密后的密码获取 User 信息。我们并非仅通过 TenantId 标识和匹配的 username 查询 User，还会将加密后的密码纳入匹配条件（两个相同的明文密码，其加密结果始终一致）。该`Repository`的设计逻辑为，基于上述三项条件进行联合筛选。

若人工用户提交了正确的租户标识、用户名和明文密码，系统将会检索到匹配的 User 实例。但这并不足以完全验证用户的身份合法性，还有一项最终验证要求尚未处理：

- 仅当用户处于启用状态时，方可对其进行身份验证。

即便`Repository`检索到了符合筛选条件的 User 实例，该实例也有可能已被禁用。提供 User 禁用功能，能让租户在另一层级对用户身份验证进行管控。因此，作为最后一步校验，User 实例必须同时满足非空且处于启用状态这两个条件，满足后系统会基于该 User 实例生成对应的 UserDescriptor。

### `Separated Interface`是否为必要设计？

由于这个 AuthenticationService 没有技术实现，真的有必要创建一个`Separated Interface`和实现类，并将它们放在不同的层和`Modules`中吗？不，其实并非绝对必要。我们完全可以仅用一个实现类来创建这个特定的`Service`，并将其命名为该`Service`的名称：

```java
package com.saasovation.identityaccess.domain.model.identity;

public class AuthenticationService {
    public AuthenticationService() {
        super();
    }

    public UserDescriptor authenticate(
            TenantId aTenantId,
    }
}
```

这么做本身并无不妥。甚至你可以认为这是一种更贴合的做法，因为这款特定的`Service`或许永远都无需设置多个实现类。但考虑到不同租户最终可能会有定制化安全标准的需求，未来也存在设置多个实现类的可能性。不过就目前而言，团队已决定不再使用`Separated Interface`，而是采用下文所示的这个类来实现。

---
**实现类的命名规范**

在 Java 开发体系中，将实现类命名为接口名加 Impl 后缀的方式已十分常见。以本文的示例来说，按这种方式命名会得到 AuthenticationServiceImpl 这个类名。此外，接口与对应的实现类通常会放在同一个包中。这种做法是否可取？

事实上，如果你的实现类采用这种命名方式，这很可能就充分说明你要么并不需要`Separated Interface`，要么就需要更审慎地思考实现类的命名。因此，AuthenticationServiceImpl 这个名称其实并不算合适。但另一方面，DefaultEncryptionAuthenticationService 这个名称也并非特别实用。正因如此，SaaSOvation 团队决定暂时舍弃`Separated Interface`的设计，转而将 AuthenticationService 作为一个简单的普通类来实现。

若你的实现类因需要提供多个特定实现而具备明确的解耦目标，便应根据其专属特性为该类命名。为每个特定实现精心命名的必要性，恰恰印证了你的领域中存在各类专属业务特性。

有人认为，将接口与实现类采用相似的命名方式，会让包含大量这类接口/实现类对的包更便于查阅和导航。但也有人认为，从`Modules`设计的目标来看，这类包含大量类的包属于设计欠佳的情况。此外，秉持模块化聚焦设计目标的开发人员，还会倾向于将接口与各类实现类分置于不同的包中，这也是我们遵循 [Dependency Inversion Principle (4)](../ch4/0.md) 的做法。例如，EncryptionService 置于领域模型中，而 MD5EncryptionService 则放在基础设施层中。

为非技术性`Domain Services`舍弃`Separated Interface`的设计，并不会降低其可测试性，因为该`Service`所依赖的所有接口，均可通过测试配置的`Service Factory`实现注入或解析，也可根据需要将入站和出站依赖的实例作为参数传入。同时也需注意，这类非技术性、特定领域的`Services`（如各类计算服务），必须对其正确性开展测试验证。

这一话题存在争议实属情理之中，我也了解到有大批开发人员向来习惯以 Impl 后缀为接口实现类命名。但你也需知晓，业内同样存在另一派见解成熟的观点，他们有充分且合理的理由摒弃这种命名方式。一如既往，最终的选择仍由你自己决定。

---

若`Service`始终为特定领域服务，且永远不会有技术实现或多种实现形式，那么使用`Separated Interface`或许更多只是一种风格选择。正如 Fowler 在 [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] 中所言，若存在特定的解耦目标，`Separated Interface`便能发挥作用：“依赖于该接口的客户端可以完全无需知晓实现细节。” 但倘若你采用了`Dependency Injection`，或是`Service Factory` [[Gamma et al.](../bibli.md#gamma-et-al)] 模式，即便将`Service`的接口与实现类合并，依然能够避免客户端知晓具体实现。换言之，像下文这样将 DomainRegistry 用作`Service Factory`，就能实现客户端与实现层的解耦：

```java
// the registry decouples client from implementation knowledge
UserDescriptor userDescriptor =
    DomainRegistry
        .authenticationService()
        .authenticate(aTenantId, aUsername, aPassword);
```

而若采用`Dependency Injection`，你也能获得类似的效果。

```java
public class SomeApplicationService ... {
    @Autowired
    private AuthenticationService authenticationService;
    ...
}
```

控制反转容器（如 Spring）会注入该`Service`实例。由于客户端从未实例化过此`Service`，因此它并不会知晓接口与实现类是合并的还是分离的。

<ins>显然，部分开发人员对`Service Factory`和`Dependency Injection`这两种方式完全持排斥态度，他们更倾向于通过构造函数配置入站依赖，或是将依赖项作为方法参数传入。归根结底，这是实现依赖装配并保证代码可测试性的最直观方式，甚至可以说，这种方式比`Dependency Injection`更易上手</ins>。也有开发人员会根据实际场景，结合使用上述三种方式，只是整体上更偏爱基于构造函数的依赖配置方式。为便于理解，本章的多个示例均使用了 DomainRegistry ， *这一做法并非一定代表偏好* 。本书配套的线上开源源码，其大部分实现实际上更倾向于通过构造函数配置依赖，或是将依赖项直接作为参数传入方法。

### 计算流程

此处再举一例，本例源自当前 [Core Domain (2)](../ch2/0.md)，`Agile Project Management Context`。该`Service`会依据特定类型的任意数量`Aggregates`实例上的`Values`，计算得出一个结果。我认为目前没有充分的理由使用`Separated Interface`，至少现阶段如此。这些计算的执行方式始终保持一致，除非该情况发生改变，否则我们无需费心将接口与其实现分离开来。

|牛仔逻辑||
|---|---|
|LB：“我的种马每次配种能赚五千美元，而且母马都已经排好队等着了。”</br> AJ：“这下这匹马可算是在自己的地盘上大显身手了。”|<img src="../img/cbl.1.png" width="50%"/>|

回想一下，SaaSOvation 的开发人员最初在 Product 类上创建了细粒度的静态方法，以执行所需的计算。接下来发生的情况如下……

---
| ||
|---|---|
|团队的导师还指出，使用`Domain Service`而非静态方法会更为合适。该`Service`的设计思路与当前方案极为相似，都是用于计算并返回一个BusinessPriorityTotals `Value`实例。但这项`Service`需要完成更多的工作，其中包括查找指定 Scrum 产品的所有 *未处理* 待办事项，然后对每一项的独立 BusinessPriority `Values`进行汇总计算。以下是具体实现代码：|![](../img/ovation.3.png)|

```java
package com.saasovation.agilepm.domain.model.product;

import com.saasovation.agilepm.domain.model.DomainRegistry;
import com.saasovation.agilepm.domain.model.tenant.Tenant;

public class BusinessPriorityCalculator {
    public BusinessPriorityCalculator() {
        super();
    }

    public BusinessPriorityTotals businessPriorityTotals(
            Tenant aTenant,
            ProductId aProductId) {
        int totalBenefit = 0;
        int totalPenalty = 0;
        int totalCost = 0;
        int totalRisk = 0;

        java.util.Collection<BacklogItem> outstandingBacklogItems =
            DomainRegistry
                .backlogItemRepository()
                .allOutstandingProductBacklogItems(
                     aTenant,
                     aProductId);

        for (BacklogItem backlogItem : outstandingBacklogItems) {
            if (backlogItem.hasBusinessPriority()) {
                BusinessPriorityRatings ratings =
                    backlogItem.businessPriority().ratings();
                totalBenefit += ratings.benefit();
                totalPenalty += ratings.penalty();
                totalCost += ratings.cost();
                totalRisk += ratings.risk();
            }
        }

        BusinessPriorityTotals businessPriorityTotals =
            new BusinessPriorityTotals(
                    totalBenefit,
                    totalPenalty,
                    totalBenefit + totalPenalty,
                    totalCost,
                    totalRisk);

        return businessPriorityTotals;
    }
}
```
---

BacklogItemRepository 被用于获取所有未处理的 BacklogItem 实例。所谓未处理的 BacklogItem，是指状态类型为 Planned 、Scheduled 或 Committed 的待办事项，而非 Done 或 Removed 状态的。领域中的`Service`可以根据需要灵活使用`Repositories`，但不建议从`Aggregates`实例访问`Repositories`。

在获取到指定产品的所有未处理待办事项后，我们会遍历这些事项，对每一项的 BusinessPriority 评分进行汇总计算。通过迭代计算得到的汇总结果，会被用于实例化一个新的 BusinessPriorityTotals 对象，最终返回给客户端。`Service`的计算流程并非必须设计得复杂，当然在某些场景下复杂的实现也是必要的。而本例中的计算流程恰好相当简洁。

从这个例子中需要注意的是，你绝对不应该将这类逻辑放置在`Application Service`中。即便你认为 for 循环中的求和计算看似微不足道，它本质上仍然属于业务逻辑。除此之外，还有另一个原因：

```java
        BusinessPriorityTotals businessPriorityTotals =
            new BusinessPriorityTotals(
                    totalBenefit,
                    totalPenalty,
                    totalBenefit + totalPenalty,
                    totalCost,
                    totalRisk);
```

在实例化 BusinessPriorityTotals 对象时，它的 totalValue 属性是通过对 totalBenefit 和 totalPenalty 进行求和推导得出的。该逻辑是领域专属的，绝对不能泄露到`Application Layer`中。我们可以认为，BusinessPriorityTotals 的构造函数本身就应该负责根据传入的这两个参数，自动推导并生成 totalValue 属性。虽然这或许是一种优化领域模型的可行方式，但即便这么做，也不能成为将剩余计算逻辑移至`Application Service`中的正当理由。

尽管我们并未将这项业务逻辑放置在`Application Service`中，但`Application Service`确实扮演着`Domain Service`的调用客户端角色。

```java
public class ProductService ... {
    ...
    private BusinessPriorityTotals productBusinessPriority(
            String aTenantId,
            String aProductId) {
        BusinessPriorityTotals productBusinessPriority =
                DomainRegistry
                    .businessPriorityCalculator()
                    .businessPriorityTotals(
                            new TenantId(aTenantId),
                            new ProductId(aProductId));
        return productBusinessPriority;
    }
}
```

在本例中，`Application Service`中的一个私有方法负责请求获取该产品的业务优先级汇总数据。该方法所提供的内容，或许只是最终返回给 ProductService 客户端（例如用户界面）的响应数据体中的其中一部分而已。

### 转换服务

那些技术性更强、且明确应置于`Infrastructure`层中的`Domain Service`实现，往往是用于系统集成的服务。正因如此，我将这类示例放在了 [Integrating Bounded Contexts (13)](../ch13/0.md) 中进行讲解。在该章节中，你会看到相关的`Service`接口、实现类，以及实现所使用的 `Adapter` [[Gamma et al.](../bibli.md#gamma-et-al)] 以及转换器 (translators)。

### 使用`Domain Services`迷你层

有时，你或许会希望在领域模型的其他`Entities`和`Value Objects`之上，创建一个`Domain Service` “迷你层” 。正如我之前所指出的，这种做法往往会让你走上贫血领域模型（Anemic Domain Model）的危险道路，而贫血领域模型被认为是一种反模式。

不过，在某些系统中，设计`Domain Service`迷你层会比其他场景更具合理性，而且并不会导致贫血领域模型的问题。这取决于领域模型的自身特性，而就`Identity and Access Context`而言，这种设计方式实际上相当有帮助。

如果你将来在这类领域中开展开发工作，并且决定构建一个`Domain Service`迷你层，需要记住：这类`Domain Service`迷你层与`Application Layer`中的`Application Service`始终存在本质区别。应将事务处理和安全相关的需求作为`Application Service`关注点进行处理，而非在`Domain Service`中实现。

#### ▶[下一节](4.md)
