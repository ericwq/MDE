## 第 7 章：服务 (Services)

#### ▶[上一节](../ch6/7.md)

*<p aligh="right" >有些行为，本就不属于任何实体。</br> —Eric Evans</p>*

领域中的`Service`是完成特定领域任务的无状态操作。判断是否需要在领域模型中创建`Service`，<ins>最直观的依据是：当你需要执行的操作，若作为 [Aggregate (10)](../ch10/0.md) 或 [Value Object (6)](../ch6/0.md) 的方法，会显得格格不入时，就该考虑创建`Service`</ins>。为了规避这种违和感，我们的本能做法可能是在`Aggregate Root`的类中创建静态方法。但在 DDD 的实践中，这种做法属于代码坏味道，这一信号往往意味着你需要用`Service`来替代。

---
**<center>本章路线图</center>**

- 了解领域模型的优化如何让我们意识到`Service`的必要性
- 掌握领域中`Service`的定义与本质特征
- 思考创建`Service`时需要注意的关键考量点
- 通过 SaaSOvation 项目中的两个实例，学习如何在领域中对`Service`进行建模

---

代码坏味道？SaaSOvation 的开发人员在重构某个`Aggregate`时，恰好就遇到了这样的问题。我们来看看他们是如何进行战术性修正的。事情的经过是这样的……

---
| ||
|---|---|
|在项目初期，团队将 BacklogItem 实例集合建模为 Product `Aggregate`的一个组合部分。这种建模方式允许将所有产品待办事项的总业务优先级值计算为 Product 类的一个简单实例方法：|![](../img/ovation.2.png)|

```java
public class Product extends ConcurrencySafeEntity {
    ...
    private Set<BacklogItem> backlogItems;
    ...
    public BusinessPriorityTotals businessPriorityTotals() {
    ...
    }
    ...
}
```

彼时这样的设计逻辑十分严谨，因为businessPriorityTotals() 方法只需遍历组合的 BacklogItem 实例，就能计算出所查询的业务优先级总计值。该设计通过`Value Object`（即 BusinessPriorityTotals ）对查询请求做出了规范的响应。

但这样的设计并非一成不变。正如 [Aggregates (10)](../ch10/0.md) 中的分析所示，规模较大的 Product 需要被拆分，而 BacklogItem 将被重新设计为独立作为一个`Aggregate`。因此，以前使用实例方法的设计不再适用。

由于 Product 不再包含 BacklogItem 集合，团队的第一反应是重构现有的实例方法，通过新的 BacklogItemRepository 获取该计算所需的全部 BacklogItem 实例。这样做合理吗？

事实上，团队的资深技术指导劝大家不要这么做。根据经验准则，我们应尽可能避免在`Aggregates`内部使用 [Repositories (12)](../ch12/0.md) 。那不如将该方法改造为 Product 类的静态方法，再将这个静态方法计算所需的 BacklogItem 实例集合传入？如此一来，除了新增一个参数外，该方法的代码几乎可以保持原样

```java
public class Product extends ConcurrencySafeEntity {
    ...
    public static BusinessPriorityTotals businessPriorityTotals(
            Set<BacklogItem> aBacklogItems) {
        ...
    }
    ...
}
```

Product 类真的是编写这个静态方法的最佳位置吗？我们似乎很难确定它真正的归属。既然这个操作实际上只用到了每个 BacklogItem 的业务优先级数值，那或许把这个静态方法放在 BacklogItem 类中才合适。但问题是，我们要获取的业务优先级，终归是产品维度的，而非单个待办项的。这就陷入了两难。

就在这时，负责技术指导的资深开发人员开口了。他指出，团队此番所有的困惑，只需借助一个建模工具 —— `Domain Service`，便能迎刃而解。具体该如何实现呢？

---

我们先来梳理相关背景，再回头探讨这一建模场景，看看团队最终做出了怎样的决策。

#### ▶[下一节](1.md)

