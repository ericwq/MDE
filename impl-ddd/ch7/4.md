## 测试服务

#### ▶[上一节](3.md)

<ins>我们希望对`Service`进行测试，确保从客户端视角验证领域模型的设计是否合理。我们希望这些以领域为核心的测试，能够反映出模型应有的使用方式</ins>，而在当前阶段，可以暂时忽略一些对软件细节正确性的严苛校验。

---
➜**现在测试会不会有点晚了？**

正常情况下，我都会在实现功能之前先编写测试用例。早些时候在分析`Service`的需求时，我也展示过一些测试先行（test-first）的代码片段。只是在本章中，我觉得先稍微深入讨论一下实现细节会更符合大家的理解节奏，仅此而已。不过，这也能说明一点：测试先行并非绝对必要，尽管它可能会更有助于聚焦合理的领域模型设计。

---

这些测试用例演示了如何正确使用 AuthenticationService ，并且我们首先针对认证成功的场景进行了测试。

```java
public class AuthenticationServiceTest
        extends IdentityTest {

    public void testAuthenticationSuccess() throws Exception {

        User user = this.getUserFixture();

        DomainRegistry
            .userRepository()
            .add(user);

        UserDescriptor userDescriptor =
            DomainRegistry
                .authenticationService()
                .authenticate(
                        user.tenantId(),
                        user.username(),
                        FIXTURE_PASSWORD);

        assertNotNull(userDescriptor);
        assertEquals(user.tenantId(), userDescriptor.tenantId());
        assertEquals(user.username(), userDescriptor.username());
        assertEquals(user.person().emailAddress(),
                     userDescriptor.emailAddress());
}
...
```

这个示例展示了`Appplication Service`客户端应当如何使用 AuthenticationService 。这是一条正常流程（happy path）在该场景下，客户端通过传入符合预期的参数，能够成功完成用户认证。

需要注意的是，测试中使用的`Repository`既可以是完整实现版本、也可以是内存版，还可以是模拟版（mock）。如果完整实现版本执行速度足够快，直接用它进行测试完全可行，只要在测试结束时回滚事务，避免在多次测试中积累无关的领域对象实例即可。测试时选用哪种`Repository`实现，可根据自身需求决定。

接下来，我们演示一种认证失败的场景：

```java
    public void testAuthenticationTenantFailure() throws Exception {

        User user = this.getUserFixture();

        DomainRegistry
            .userRepository()
            .add(user);

        TenantId bogusTenantId =
            DomainRegistry.tenantRepository().nextIdentity();

        UserDescriptor userDescriptor =
            DomainRegistry
                .authenticationService()
                .authenticate(
                        bogusTenantId, // bogus
                        user.username(),
                        FIXTURE_PASSWORD);

        assertNull(userDescriptor);
    }
```

本次认证测试失败的原因是，我们故意传入了一个与创建用户时所用租户 ID 不一致的 TenantId 。接下来，我们将演示用户名无效的场景：

```java
    public void testAuthenticationUsernameFailure() throws Exception {

        User user = this.getUserFixture();

        DomainRegistry
            .userRepository()
            .add(user);

        UserDescriptor userDescriptor =
            DomainRegistry
                .authenticationService()
                .authenticate(
                        user.tenantId(),
                        "bogususername",
                        user.password());

        assertNull(userDescriptor);
    }
```

本次认证测试场景之所以失败，是因为我们传入了一个错误的用户名。在这些测试用例中，还将演示最后一种失败场景：

```java
    public void testAuthenticationPasswordFailure() throws Exception {

        User user = this.getUserFixture();

        DomainRegistry
            .userRepository()
            .add(user);

        UserDescriptor userDescriptor =
            DomainRegistry
                .authenticationService()
                .authenticate(
                        user.tenantId(),
                        user.username(),
                        "passw0rd");

        assertNull(userDescriptor);
    }
}
```

本次测试传入了错误的密码，导致认证失败。在所有演示的失败场景中，返回的 UserDescriptor 均为 null。这是一个调用客户端需要注意的细节，它明确了用户认证失败时，客户端应当预期得到什么样的返回结果。这同时也表明，认证失败并非一种异常错误，而只是该领域中一种正常的可能性结果。否则，如果我们将认证失败视为异常情况，就会让该服务抛出 AuthenticationFailedException 。

实际上还有几项测试尚未完成。我将把这些测试任务留给你完成：你需要测试包含 非活跃租户 Tenant 和禁用用户 User 的领域场景。完成这些之后，你还可以为 BusinessPriorityCalculator 编写对应的测试用例。

<center><img src="../img/ownit.png" align="center" width="30%" /></center>

#### ▶[下一节](5.md)
