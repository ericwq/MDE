## 什么是领域服务（但首先，不是什么）

#### ▶[上一节](0.md)

在软件语境中听到 *服务 (service)* 一词时，我们很自然会联想到一种粗粒度组件，这类组件能让远程客户端与复杂的业务系统进行交互。这一描述基本契合 [Service-Oriented Architecture (4)](../ch4/0.md) 中的服务概念。开发 SOA 的服务有多种技术和方法可循，归根结底，这类服务强调系统级的 *远程过程调用* ，或是 *基于消息的中间件* ；借助这类服务，跨越数据中心内乃跨越至全球的其他系统，都能与服务交互并完成业务交易。

而以上这些，都并非`Domain Service`。

此外，切勿将`Domain Service`与`Application Service`混为一谈。我们不希望在`Application Service`中封装业务逻辑，但`Domain Service`务恰恰是承载业务逻辑的载体。若你对二者的区别存有疑惑，可参考 [Application (14)](../ch14/0.md) 的内容。简而言之，二者的核心区别在于，作为领域模型天然调用方的`Application Service`，通常也是`Domain Service`的调用方。这一点会在本章后续内容中具体举例说明。

不能仅仅因为`Domain Service`的名称中带有 *service* ，就认定它必须是一个粗粒度、支持远程调用、重量级的事务型操作。<sup>[1](#1)</sup>

|牛仔逻辑||
|---|---|
|LB：“吃任何东西前，一定要仔细打量一番。知道它现在是什么样子倒在其次，关键是要弄清它原本是什么。”|<img src="../img/cbl.1.png" width="50%"/>|

专属于业务领域的服务，在需求与其适用场景相契合时，是一种极为理想的建模工具。既然我们已经厘清了`Domain Service`不是什么，接下来就来探讨它究竟是什么。

- 有些时候，他就不是个事物…… 当领域中某项重要的流程或转换操作，并非某个`ENTITY`或`VALUE OBJECT`的固有职责时，可在模型中新增一个操作，将其声明为`SERVICE`并设计为独立接口。以领域模型的语言定义该接口，确保操作名称属于`UBIQUITOUS LANGUAGE`的一部分，同时让`SERVICE`保持无状态。[[Evans, pp. 104, 106](../bibli.md#evans)]

由于领域模型通常处理的是细粒度行为，聚焦于当下业务的特定方面，因此领域中的`Service`也应遵循类似原则。`Domain Service`务可能会在单个原子操作中处理多个领域对象，故而其复杂度可适当提高。

在何种情况下，某个操作不应归属于现有的 [Entity (5)](../ch5/0.md) 或`Value Object`？我们很难罗列穷尽所有原因，但此处整理了几类典型情况。你可通过`Domain Service`领域服务实现以下操作：

- 执行重要的业务流程
- 将领域对象从一种组合形式转换为另一种
- 计算需要多个领域对象作为输入的`Value`

最后一种 ——计算操作—— 虽本质上可能归属于 “重要流程” 范畴，但我特意单独列明，以求表述清晰。这类操作十分常见，其执行往往需要以两个乃至多个不同的`Aggregates`或其组合部分作为输入。而且，当把相关方法置于任意一个`Entity`或`Value`中都会显得极为牵强时，将其定义为`Service`便是最佳方案。务必保证该`Service`为 *无状态 (stateless)* ，且其接口能在所属`Bounded Context`中，清晰体现 [Ubiquitous Language (1)](../ch1/0.md) 的内涵。

#### ▶[下一节](2.md)

---

#### 1
`Domain Service`有时会涉及对外部 [Bounded Context (2)](../ch2/0.md) 的远程调用，但本文的讨论重点有所不同：此处的`Domain Service`本身并不提供远程过程调用接口，而是作为远程过程调用的调用方。
