## 确保你需要服务

#### ▶[上一节](1.md)

切勿过度倾向于将领域概念建模为`Service`，仅在符合特定情形时才应如此操作。若掉以轻心，我们很可能会将`Service`当作领域建模的 “万能良方”。对`Services`的滥用，往往会导致 *贫血领域模型 (Anemic Domain Model)* [[Fowler, Anemic](../bibli.md#fowler-anemic)] 的不良后果，所有领域逻辑都集中在`Service`中，而非主要分散于各`Entities`和`Value Objects`之中。下述分析将阐明，针对不同的建模场景审慎考量应采用的策略，遵循这些指导原则，能帮助你在是否建模为`Service`的问题上，做出合理的决策。

我们以一个案例来分析如何判断何时需要`Service`。试想在`Identity and Access Context`中，对 User 进行身份验证的场景。回想一下，在 [Entities (5)](../ch5/0.md) 的内容中，团队曾遇到过这一领域场景，并决定暂时搁置处理。而现在，是时候着手解决了：

- 系统用户必须完成身份验证，且仅当租户激活时，才能进行身份验证。

我们来分析为何有必要引入`Service`。我们能否直接将该行为归属于某个`Entity`？从调用方的角度来看，或许可以这样对身份验证进行建模：

```java
// client finds User and asks it to authenticate itself
boolean authentic = false;
User user =
    DomainRegistry
        .userRepository()
        .userWithUsername(aTenantId, aUsername);
if (user != null) {
    authentic = user.isAuthentic(aPassword);
}
return authentic;
```

我认为这个设计至少存在几个问题。我们要求客户端理解认证的含义。他们必须先找到 User，然后再询问 User 给定的密码是否与用户持有的密码匹配。此外，`Ubiquitous Language`并没有被明确建模。在这里，我们问用户是否 “真实”，而不是让模型执行 “认证”。如果可能的话，最好按照团队自然使用的表达来建模，而不是因为我们没有更好地建模概念而强迫团队调整他们的看法。但比这些问题更糟的还有其他问题。

这一设计并未恰当地体现出团队对用户身份验证流程的业务认知，其中一处明显的疏漏是，未对租户是否处于激活状态进行校验。根据需求要求，若用户所属的租户未激活，该用户则无法通过身份验证。或许我们可以通过下述方式解决这一问题：

```java
// maybe this way is better ...
boolean authentic = false;

Tenant tenant =
    DomainRegistry
        .tenantRepository()
        .tenantOfId(aTenantId);
if (tenant != null && tenant.isActive()) {
    User user =
        DomainRegistry
            .userRepository()
            .userWithUsername(aTenantId, aUsername);
    if (user != null) {
        authentic = tenant.authenticate(user, aPassword)
} }
return authentic;
```

该测试会先确认 Tenant 是否处于激活状态，再继续执行身份验证流程。我们还将 authenticate() 移至 Tenant 中，从而在 User 中剔除了 isAuthentic() 方法。

但这种做法存在问题。看看我们给客户端平添的负担：现在客户端需要了解的身份验证相关知识，已经远超其应有的范畴。我们可以在 authenticate () 方法内部检查 Tenant 的 isActive () 状态，来稍微缓解这一问题，但我认为这并非一种显式的模型设计，还会引发另一个问题 —— 此时 Tenant 可能需要处理密码相关的逻辑。要知道，我们还实现了另一项需求（尽管在本次身份验证场景中并未明确提及）：

- 密码必须加密存储，不得明文保存。

采用我们提出的这些解决方案，模型中的违和问题似乎只会愈发突出。而就最新这套方案而言，我们不得不从四种不尽合理的处理方式中选择其一：

1. 在 Tenant 中处理加密逻辑，并将加密后的密码传递给 User 。这一做法违背了 Tenant 的 `Single Responsibility` [Martin, SRP](../bibli.md#martin-srp)，其只应负责 Tenant 建模。

2. 由于 User 必须保证所有存储的密码均为加密状态，其可能本就需要掌握少量加密相关的知识。若确是如此，可在 User 中创建一个方法，使其能够根据传入的明文密码完成身份验证操作。但在此种情况下，身份验证实际成为了 Tenant 的 facade，其具体实现却完全交由 User 完成。此外， User 还必须设置一个受保护的身份验证接口，以防止模型外部的客户端直接调用该接口。

3. 由 Tenant 请求 User 对明文密码进行加密，再将加密后的密码与 User 中存储的密码做比对。这种方式不仅多了额外的操作步骤，各对象间的协作关系也显得杂乱。即便 Tenant 并未实际执行身份验证操作，仍不得不了解身份验证的具体细节。

4. 由客户端对密码进行加密后传递给 Tenant。这无疑进一步加重了客户端的职责，而事实上，客户端本应完全无需知晓密码加密的相关要求。

这些方案均无太大改善效果，客户端的设计依旧过于复杂。我们强加给客户端的这些职责，本应巧妙地内聚到领域模型之中。纯粹的领域专属知识，绝不应泄露至客户端层。即便是当客户端为`Application Service`时，该组件也无需承担身份与访问管理领域的相关职责。

|牛仔逻辑||
|---|---|
|AJ：“倘若发现自己身陷坑中，首要之事便是停止挖坑。”|<img src="../img/cbl.1.png" width="50%"/>|

事实上，客户端理应承担的业务职责只有一项：协调调用单个领域专属操作，而该操作将处理此业务问题的所有其他细节

```java
// inside an Application Service client with
// only task coordination responsibility
UserDescriptor userDescriptor =
    DomainRegistry
        .authenticationService()
        .authenticate(aTenantId, aUsername, aPassword);
```

采用这种简洁精妙的解决方案，客户端只需获取 AuthenticationService 的无状态实例引用，再调用其 authenticate () 方法即可。这一设计将身份验证的所有细节从`Application Service`客户端抽离，全部交由`Domain Service`处理。`Service`可根据需要，灵活调用任意数量的领域对象，其中也包括确保密码加密操作按规范执行。客户端无需了解任何相关细节，同时也契合了该上下文下的`Ubiquitous Language`要求，因为对身份管理领域建模的软件，会完整表达相关专业术语，而非由领域模型和客户端各自表达一部分。

`Service`方法会返回一个`Value Object` UserDescriptor 。该对象轻量且安全，与完整的 User 不同，它仅包含引用用户所需的若干核心属性：

```java
public class UserDescriptor implements Serializable  {
    private String emailAddress;
    private TenantId tenantId;
    private String username;

    public UserDescriptor(
            TenantId aTenantId,
            String aUsername,
            String anEmailAddress) {
        ...
    }
    ...
}
```

该对象适用于存储在按用户划分的 Web 会话中。客户端`Application Service`既可将该对象直接返回给其调用方，也可自行创建一个更适配调用方的对象。

#### ▶[下一节](3.md)
