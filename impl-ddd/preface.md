## 前言

#### ▶[上一节](foreword.md)

<p align="right">所有计算都表明这是行不通的。唯有一条路可走：</br>
  让它行得通。</br>
  ——Pierre-Georges Latécoère，</br>
  法国早期航空企业家</p>

而我们定要让它行得通。领域驱动的软件开发方法论 (DDD) 至关重要，绝不能让任何有能力的开发者缺乏成功实施的明确指引。

### 脚踏实地，翱翔天际

小时候，父亲学会了驾驶小型飞机。全家常一起乘机翱翔。有时飞往别处机场午餐，再折返归来。当父亲时间有限却渴望翱翔时，我们便父子二人出游，在机场上空盘旋进行“触地复飞”训练。

我们还进行过几次长途旅行。每次出发前，父亲都会提前绘制好路线图。我们这些孩子的工作就是通过观察下方地标来协助导航，确保航线不偏离。这对于我们来说充满乐趣，因为要辨认如此遥远且缺乏明显特征的物体实属挑战。其实我确信爸爸始终清楚我们的位置。仪表盘上配备了全套导航设备，而且他持有飞行执照。

从空中俯瞰的景象彻底改变了我的视角。父亲偶尔会载着我飞越乡间的老家。几百英尺的高空让我获得了前所未有的家园认知。每当父亲驾机掠过屋顶，母亲和姐妹们便会冲进院子向我们挥手。我认得她们的身影，却看不清她们的眼睛。我们无法交谈。即便我对着机窗呼喊，她们也永远听不见。我能看见前院那道分隔宅院与公路的木栅栏。地面行走时，我总像踩着平衡木般小心翼翼地跨过它。从空中俯瞰，它却像精心编织的枝条。还有那片广阔的草坪，每年夏天我总骑着割草机在草丛间来回穿梭。此刻从天而降，我只看见一片绿色的海洋，再也辨不出草叶的轮廓。

我深爱那些翱翔天际的时刻。它们在我记忆中历历在目，仿佛父亲和我刚刚降落，正滑行停靠准备系留过夜。尽管我如此热爱飞行，但空中时光终究无法替代脚踏实地的感觉。那些触地复飞的瞬间虽令人心旷神怡，却过于短暂，无法让我真正获得踏实感。

### 让 DDD 落地
接触领域驱动设计（DDD）对初学者而言，犹如孩童的飞行体验。空中景致令人惊叹，但事物往往陌生得令人难以辨明方位，从 A 点抵达 B 点似乎遥不可及。那些精通 DDD 的行家似乎永远胸有成竹。他们早已规划好航线，与导航仪器完美契合。而多数人却始终感到脚不沾地。此刻需要的正是 “降落并固定” 的能力。接下来，我们需要一张地图指引从当前位置抵达目标之地的路径。

在 *《Domain-Driven Design: Tackling Complexity in the Heart of Software》* [[Evans](bibli.md#evans)] 一书中，Eric Evans 创造了一部经久不衰的经典之作。我坚信 Eric 的著作将在未来数十年持续为开发者提供切实可行的指导。如同其他模式著作，本书在足够高的视角上为我们提供了广阔视野。然而当我们需要理解 DDD 的具体实现基础时，挑战可能稍显艰巨，我们往往渴望更详尽的示例。倘若能让我们在地面停留更久，甚至能驾车回家或前往某个熟悉的地方该多好。

我的目标之一是引导你平稳着陆，确保飞机安全，并通过一条熟悉的地面航线助你返航。这将帮助你理解如何实施 DDD ，为你提供使用熟悉工具和技术的示例。既然我们无法永远宅在家中，我还将协助你踏上其他路径探索新领域，带你去往或许从未涉足之地。前路或有陡峭，但只要策略得当，艰难而安全的攀登终将实现。此行你将领略整合多领域模型的替代架构与模式，这可能带你踏入未曾探索的疆域。书中详尽阐述了多集成战略建模，甚至教你如何开发自主服务。

我的目标是为你绘制一张地图，助你从容应对短途探险与长途跋涉，在欣赏沿途景致的同时，避免迷途或受伤。

### 绘制地形图与规划航线

在软件开发中，我们似乎总是在进行各种映射工作。我们将对象映射到数据库，将对象映射到用户界面，然后再反向映射回来。我们将对象映射到各种应用程序表示形式，包括可供其他系统和应用程序使用的表示形式。面对如此繁复的映射工作，自然需要一张从 Evans 的高级模式到具体实现的路线图。

即使你已经多次实践过 DDD ，其中仍有更多值得挖掘的价值。有时人们最初接触 DDD 时，将其视为一套技术工具集，这种实践方式常被称为 “DDD-lite”。我们可能专注于`Entities`与`Services`的设计，或许还勇敢尝试过 `Aggregates`的构造，并试图通过`Repositories`管理其持久化。这些模式因熟悉而被广泛采用。我们甚至可能在实践中发现了`Value Objects`的用武之地。这些都属于 *战术设计 (tactical design)* 模式范畴，更侧重技术层面。它们让我们能像外科医生持刀般精准地解决复杂软件问题。然而，关于这些模式以及战术设计的其他应用方向，仍有大量知识待探索。我将它们归类为实现层面的实践。

你是否已超越战术建模？是否曾探访甚至沉浸于被称为 DDD “另一半”的 *战略设计 (strategic design)* 模式？若你忽略了`Bounded Context`与`Context Maps`的使用，很可能也错过了`Ubiquitous Language`的应用。

<ins>如果说 Evans 为软件开发社区带来了一项 “发明”，那便是`Ubiquitous Language`。至少他将`Ubiquitous Language`从设计智慧的尘封档案中重新发掘出来。</ins>这种团队模式用于在软件模型本身中捕捉特定核心业务领域的概念与术语。软件模型正式纳入了开发团队使用的名词、形容词、动词及更丰富的表达方式，该团队至少包含一名业务领域专家。<ins>但若认为这种语言仅限于词汇本身，则大错特错。正如任何人类语言都映射着使用者的思维模式，`Ubiquitous Language`同样折射出业务领域专家的认知模型。</ins>因此，软件以及用于验证模型是否遵循领域原则的测试，都既捕捉又遵循这种语言，这种语言正是团队设想和使用的语言。这种语言与各种战略性和战术性建模模式同样有价值，在某些情况下甚至具有更持久的特性。

<ins>简而言之，实践 DDD-Lite 会导致构建出次等的领域模型。</ins>这是因为`Ubiquitous Language`、`Bounded Context`和`Context Maps`能带来诸多益处。你获得的远不止团队术语。当团队语言在明确的`Bounded Context`中以领域模型形式呈现时，它能创造真正的业务价值，并确保我们正在实现正确的软件。即便从技术角度看，它也能帮助我们构建更优质的模型，这些模型具备更强大的行为能力，更纯粹且更少出错。因此，我将战略设计模式映射到可理解的示例实现中。

本书以独特视角勾勒出 DDD 的全貌，助您同时领略战略设计与战术设计的双重优势。通过深入剖析细节，让您真切感受其商业价值与技术实力。

若我们对 DDD 的实践仅止步于地面，那将令人失望。沉溺于细节时，我们常会忘记高空俯瞰同样能带来深刻启示。别将自己局限于崎岖的地面行走。勇敢坐进驾驶舱迎接挑战，从高处俯瞰才能洞悉全局。通过战略设计领域的训练飞行 ——借助其`Bounded Context`与`Context Maps`—— 你将准备好以更宏大的视角审视整体实现。当你用领域驱动设计展开飞行时，我的目标便已达成。

### 章节概要

以下概述本书各章节内容，并说明您可从每章中获得哪些益处。

#### 第 1 章：DDD 入门指南

本章将带您了解采用 DDD 的优势及其最大化应用之道。您将学习 DDD 如何助力项目团队应对复杂性挑战，并掌握评估项目价值的方法，判断是否值得投入 DDD 实践。您将审视 DDD 的常见替代方案及其易引发问题的根源。本章奠定 DDD 实践基础，指导您在项目中迈出第一步，并提供向管理层、领域专家及技术团队推广 DDD 的策略。掌握这些成功要诀后，您将更有底气应对 DDD 实践中的挑战。

书中通过虚构公司与团队的项目案例，呈现真实世界的 DDD 挑战。这家以开发创新型 SaaS 产品为使命的公司，在多租户环境中经历了 DDD 落地过程中的常见失误，但团队通过关键发现成功化解危机，使项目重回正轨。该项目聚焦于开发基于 Scrum 的项目管理应用，多数开发者都能产生共鸣。此案例导论为后续章节奠定基础，每种战略与战术模式都通过团队视角展开阐述，既呈现其实施过程中的失误，也展现团队在成功践行领域驱动设计过程中逐步走向成熟的历程。

#### 第 2 章：领域、子领域与有界上下文 (Bounded Contexts)

什么是领域、子领域和`Core Domain`？什么是`Bounded Context`？为何及如何使用它们？这些问题将通过案例研究中项目团队的错误来解答。在首个 DDD 项目初期，团队未能厘清所处子域的`Bounded Context`，也未能建立简洁的`Ubiquitous Language`。事实上，他们对战略性设计完全陌生，仅利用战术模式获取技术收益，导致初始领域模型设计出现问题。所幸在陷入无法挽回的困境前，他们及时意识到了问题所在。

文中传达了一个关键信息：运用`Bounded Context`模式来正确区分和隔离模型。文章既指出了该模式的常见误用情况，也提供了有效的实施建议。随后，文本详细阐述了团队采取的纠正措施，以及这些措施如何促成两个独立`Bounded Context`的建立。这使得在第三个`Bounded Context`——即新`Core Domain`（本书主要示例）中，实现了建模概念的恰当分离。

本章将强烈引起那些曾因仅从技术层面应用 DDD 而深感痛苦的读者的共鸣。若您尚未涉足战略设计领域，本书将为您指明正确方向，助您开启成功的探索之旅。

#### 第 3 章：上下文地图 (Context Maps)

[Context Maps]是帮助团队理解业务领域、不同模型间的边界以及当前或潜在集成方式的强大工具。该技术不仅限于绘制系统架构图，更在于理解企业中各类`Bounded Contexts`之间的关系，以及用于在不同模型间清晰映射对象的模式。在复杂商业企业中成功应用`Bounded Contexts`，此工具至关重要。本章将带您了解项目团队如何运用`Context Mapping`技术，解析其首个`Bounded Context`（ [第 2 章](ch2/0.md) ）引发的问题，并展示负责设计实施新`Core Domain`团队，如何利用由此产生的两个清晰`Bounded Contexts`。

#### 第 4 章：架构

几乎所有人都了解分层架构。分层是否是承载 DDD 应用程序的唯一方式？还是可以采用其他多样化的架构？本文探讨如何在 Hexagonal （Ports 与 Adapters）、Service-Oriented、REST、CQRS、Event Driven（Pipes 与 Filters、Long-Running Processes 或 Saga、Event Sourcing）以及 Data Fabric/Grid-Based 等架构中实践 DDD 。其中若干架构风格已被项目团队实际应用。

#### 第 5 章：实体 (Entities)

讨论的第一个 DDD 战术模式是`Entities`。项目团队初期过度依赖它，忽视了在适当场景下采用`Value Objects`设计的重要性。这引发了关于如何避免因数据库与持久化框架不当影响导致`Entities`模式滥用的讨论。

当你掌握了区分`Entities`正确使用场景的方法后，便能看到大量优秀`Entities`设计范例。如何用`Entity`表达`Ubiquitous Language`？`Entities`如何进行测试、实现与持久化？本书将逐步引导你掌握这些方面的具体操作指南。

#### 第 6 章：值对象 (Value Objects)

项目团队早期错失了运用`Value Objects`进行建模的重要契机。他们过度关注`Entities`的单一属性，却未充分考量如何将多个相关属性整合为不可变的整体。本章从多角度探讨`Value Object`的设计，阐述如何识别模型中的特殊特征，从而判断何时应使用`Value`而非`Entity`。其他重要议题包括：`Value`在集成中的作用、`Standard Types`的建模方法。本章还将展示如何设计领域中心化测试、实现`Value`类型，以及如何避免持久化机制对`Aggregate`存储需求的不良影响。

#### 第 7 章：服务 (Services)

本章阐述如何判断何时应将概念建模为存在于领域模型中的细粒度、无状态`Services`。您将了解何时应设计`Services`而非`Entity`或`Value Object`，以及如何实现`Domain Services`务以处理业务领域逻辑并满足技术集成需求。通过项目团队的决策案例，本章将具体说明`Services`的使用时机及其设计方法。

#### 第 8 章：领域事件 (Domain Events)

`Domain Events`作为 DDD 的核心概念，直到 Eric Evans 的著作出版后才被正式提出。本章将阐释模型发布的`Domain Events`为何如此强大，并展示其多样化的应用场景，甚至能支持集成与自主业务服务。尽管应用程序会发送和处理各类技术事件，但`Domain Events`的独特特性在此得到重点阐释。本章提供设计与实现指南，指导你了解可选方案及其权衡取舍。随后将讲解如何创建发布-订阅机制，如何将`Domain Events`发布给企业范围内的集成订阅者，如何创建和管理事件存储库 (Event Store) ，以及如何妥善应对常见消息传递挑战。每个领域都结合项目团队的实践经验展开讨论，旨在帮助团队正确运用这些机制并发挥其最大效益。

#### 第 9 章：模块 (Modules)

如何将模型对象组织成大小适中的容器，同时确保不同容器间对象的耦合度保持在合理范围内？如何为这些容器命名才能体现`Ubiquitous Language`的精髓？在包和命名空间之外，如何利用语言和框架提供的现代化模块化设施（如 OSGi 和 Jigsaw ）？本章将展示项目团队在多个项目中如何运用模块化技术。

#### 第 10 章：聚合体 (Aggregates)

[Aggregates]可能是 DDD 战术工具中最不为人所理解的部分。然而，若遵循某些经验法则，[Aggregates]的实现可变得更简洁高效。你将学会如何突破复杂性壁垒，运用`Aggregates`在小型对象集群周围建立一致性边界。由于过度关注`Aggregates`次要的方面，案例研究中的项目团队在多个环节遭遇了挫折。我们将逐步剖析团队在建模过程中的迭代挑战，解析问题根源及其应对策略。这些实践最终深化了团队对`Core Domain`的认知。我们将重点探讨团队如何通过正确运用事务一致性与最终一致性修正错误，进而设计出适用于分布式处理环境的高可扩展性与高性能模型。

#### 第 11 章：工厂模式 (Factories)

 [[Gamma et al.](bibli.md#gamma-et-al)] 对工厂模式已有详尽论述，本书为何还要赘述？本章内容简明扼要，无意重复造轮子，相反，它侧重于理解`Factories`工厂应该存在于 *何处* 。当然，我们仍将分享若干实用技巧，指导如何在 DDD 场景中设计出优秀的`Factories`模式。观察项目团队如何在`Core Domain`创建`Factories`模式，以此简化客户端接口，并保护模型消费者免于在多租户环境中引入灾难性缺陷。

#### 第 12 章：存储库 (Repositories)

[Repository]难道不是简单的数据访问对象（DAO）吗？若非如此，两者有何区别？为何要设计模拟集合而非数据库的`Repositories`？学习如何设计一个与 ORM 一起使用的`Repository`，一个支持基于 Coherence 网格化分布式缓存的`Repository`，以及一个使用 NoSQL 键值存储的`Repository`。项目团队可以使用这些可选的持久化机制，是因为`Repository`构建块模式背后的强大功能和灵活性。

#### 第 13 章：整合有界上下文

既然你已经掌握了`Context Mapping`的高级技术，并具备了战术模式，那么实际实现模型间的集成需要哪些步骤？DDD 提供了哪些集成选项？本章将揭示几种利用`Context Mapping`实现模型集成的不同方法。指导内容基于项目团队如何将`Core Domain`与早期章节中引入的其他辅助`Bounded Contexts`进行集成。

#### 第 14 章：应用

你已根据`Core Domain`的`Ubiquitous Language`设计了模型。你已围绕其使用场景和正确性编写了充分的测试，且模型运行良好。但团队其他成员该如何设计围绕该模型的应用程序区域？他们是否应使用 DTO 在模型与用户界面间传递数据？还是存在其他方案将模型状态传递至展示组件？应用程序服务 (Application Services) 与基础设施如何运作？本章将通过熟悉的项目案例，探讨这些问题的可行方案。

#### 附录A：聚合体与事件源：A+ES

`Event Sourcing`是持久化`Aggregates`的重要技术方法，同时为构建事件驱动架构 (Event-Driven Architecture) 奠定基础。`Event Sourcing`可将`Aggregate`的完整状态表示为自创建以来发生的事件序列。通过按事件发生顺序重放这些事件，即可重建`Aggregate`的状态。该方法的核心优势在于：既能简化持久化操作，又能捕捉具有复杂行为特性的概念，同时事件本身还能对内部及外部系统产生深远影响。

### Java与开发工具

本书中的多数示例均采用 Java 编程语言实现。我本可提供 C# 示例，但经过深思熟虑后仍选择 Java。

首先，令人遗憾的是，我认为 Java 社区普遍放弃了良好的设计与开发实践。如今在多数 Java 项目中，要找到清晰明确的领域模型已非易事。<ins>在我看来，Scrum 等敏捷方法正被用作精细建模的替代品，开发人员被强行塞给产品待办事项列表，仿佛它就是设计方案。多数敏捷实践者在每日站会后，根本不会思考待办任务如何影响业务底层模型。虽然这本是无需赘言的常识，但我必须强调：Scrum 等方法绝非设计工作的替代品。无论多少项目经理和产品经理想让你踏上永不停歇的持续交付之路，Scrum 的初衷绝非仅为取悦甘特图爱好者。然而在诸多案例中，它却沦为了这样的工具。</ins>

我认为这是个重大问题，而我的核心主张是：给予合理的思考时间，如何运用良好，敏捷高效的设计技术来提升工作成效，从而激励 Java 社区回归领域建模。

此外，.NET 环境下已有不少优秀的 DDD 资源，例如 Jimmy Nilsson 的 *《Applying Domain-Driven Design and Patterns: With Examples in C# and .NET》* [[Nilsson](bibli.md#nilsson)] 。得益于 Jimmy 等推广 Alt.NET 理念的实践者，.NET 社区正涌现出大量优质的设计与开发实践。Java 开发者应当对此予以关注。

其次，我深知 C#.NET 社区完全能够理解 Java 代码。由于 DDD 社区中多数人使用 C#.NET ，我早期的大部分书籍审阅者都是 C# 开发者，而我从未收到过任何关于他们需要阅读 Java 代码的抱怨。因此，我完全不担心使用 Java 会疏远 C# 开发者。

需要补充的是，在撰写本文时，<ins>业界对基于文档和键值存储的兴趣已显著超越关系型数据库。这绝非偶然，就连 Martin Fowler 也精辟地将这类存储称为 “聚合体导向存储 (aggregate-oriented storage)”。这个称谓恰如其分，精准概括了在 DDD 场景中采用 NoSQL 存储的优势。</ins>

然而，在我的咨询工作中发现，许多人仍然对关系型数据库和对象关系映射情有独钟。因此，我认为在实践层面，我为领域模型提供对象关系映射技术指导的做法，并未对 NoSQL 爱好者群体造成任何损害。我承认，此举或许会招致某些人的鄙夷，他们认为对象关系阻抗失配使其不值得考虑。这无妨，我甘愿承受批评，因为绝大多数人仍需日复一日地忍受这种阻抗失配带来的繁琐工作，尽管在少数派眼中他们可能显得不够开明。

当然，我在 [第 12 章：存储库 (Repositories)](ch12/0.md) 中也提供了关于文档型、键值型以及 Data Fabric/Grid-Based 存储的使用指导。此外，在多个章节中我探讨了采用 NoSQL 存储如何可能影响`Aggregates`及其内部组件的替代设计方案。NoSQL 存储的兴起很可能持续推动该领域发展，因此面向对象关系型开发者需对此保持关注。如您所见，我理解双方观点并认同二者。这正是技术趋势引发的持续摩擦，而这种摩擦恰恰是推动积极变革的必要条件。

#### ▶[下一节](ack.md)

