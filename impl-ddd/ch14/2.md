## 应用服务

#### ▶[上一节](1.md)

在某些情况下，你的用户界面将使用独立的`Presentation Model`组件聚合多个 [Bounded Contexts (2)](../ch2/0.md) ，所有组件都组合在单个视图上。
无论你的用户界面渲染单个模型还是组合多个模型，它很可能会与`Application Services`进行交互，因此我们现在考虑这些服务。

`Application Services`是领域模型的直接客户端。
关于`Application Service`的逻辑位置选项，请参见 [Architecture (4)](../ch4/0.md) 。
这些服务负责用例流程的任务协调，每个流程对应一个服务方法。
在使用 ACID 数据库时，`Application Services`还控制事务，确保模型状态转换被原子地持久化。
我在这里简要讨论事务控制，但请参见 [Repositories (12)](../ch12/0.md) 以获得更广泛的视角。
安全性通常也由`Application Services`负责。

将`Application Services`与 [Domain Services (7)](../ch7/0.md) 混为一谈是错误的。
二者并不相同，其区别应当十分鲜明，下一节内容会清晰地展示这一点。
我们应尽力将所有业务领域逻辑放入领域模型中，无论是`Aggregates`、`Value Objects`，还是`Domain Services`。
*保持`Application Services`的轻量精简，仅用其协调领域模型上的任务即可。*

### 应用服务示例

我们来看一个`Application Service`的部分接口与实现类示例。
该服务为`Identity and Access Context`中的租户提供用例任务管理。
这仅为示例，不可视作最终标准实现。
其中的利弊取舍会十分清晰。

首先来看基础接口：

```java
package com.saasovation.identityaccess.application;

public interface TenantIdentityService {

    public void activateTenant(TenantId aTenantId);

    public void deactivateTenant(TenantId aTenantId);

    public String offerLimitedRegistrationInvitation(
        TenantId aTenantId,
        Date aStartsOnDate,
        Date anUntilDate);

    public String offerOpenEndedRegistrationInvitation(
        TenantId aTenantId);

    public Tenant provisionTenant(
        String aTenantName,
        String aTenantDescription,
        boolean isActive,
        FullName anAdministratorName,
        EmailAddress anEmailAddress,
        PostalAddress aPostalAddress,
        Telephone aPrimaryTelephone,
        Telephone aSecondaryTelephone,
        String aTimeZone);

    public Tenant tenant(TenantId aTenantId);
    ...
}
```

这六个`Application Service`方法用于创建或开通租户、激活与停用现有租户、向未来用户提供有限制及无限制的注册邀请，以及查询指定租户。

这些方法签名中使用了领域模型中的若干类型。
这会要求用户界面了解这些类型并对其产生依赖。
有些情况下，`Application Service`在设计时会完全将用户界面与所有此类领域知识隔离开。
若采用这种做法，`Application Service`的方法签名将只使用基本类型（int、long、double）、字符串，以及可能的 DTO。
不过，作为这些方式的替代方案，更好的做法或许是改用`Command`对象 [[Gamma et al.](../bibli.md#gamma-et-al)] 。
这些方式并无绝对的对错之分。
主要取决于你的偏好与目标。
本书会在不同示例中展示这些风格的用法。

需要权衡其中的利弊。
如果从模型中移除领域类型，虽然可以避免依赖与耦合，但会失去`Value Object`类型天然提供的强类型检查与基础校验（防护逻辑）。
如果不将领域对象作为返回类型暴露，就必须提供 DTO。
而引入 DTO 后，额外类型带来的开销可能会让方案出现不必要的复杂度。
此外，在高流量应用中，频繁创建与回收可能并非必需的 DTO，也会带来前文提到的内存开销。

当然，如果将领域对象暴露给多种不同客户端，每种客户端都需要单独处理，耦合度会随之升高；客户端类型越多，问题就越突出。
鉴于此，至少其中部分方法可以通过更好的设计来处理返回类型。
如前所述，我们可以改用`Data Transformers`：

```java
package com.saasovation.identityaccess.application;
public interface TenantIdentityService {
    ...
    public TenantData provisionTenant(
        String aTenantName,
        String aTenantDescription,
        boolean isActive,
        FullName anAdministratorName,
        EmailAddress anEmailAddress,
        PostalAddress aPostalAddress,
        Telephone aPrimaryTelephone,
        Telephone aSecondaryTelephone,
        String aTimeZone,
        TenantDataTransformer aDataTransformer);

    public TenantData tenant(
        TenantId aTenantId,
        TenantDataTransformer aDataTransformer);
    ...
}
```

目前我会继续将领域对象暴露给客户端，并假设我们只有一个基于 Web 的用户界面，这样有助于简化示例。
后续我会再回到`Data Transformers`方案。

我们来看`Application Service`接口的实现方式。
通过查看几个较为简单的方法实现，可以帮助突出一些基本要点。
注意，在本例中使用`Separated Interface` [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] 可能并无优势。
下面这个示例里，我们将直接在实现类中定义接口：

```java
package com.saasovation.identityaccess.application;

public class TenantIdentityService {

    @Transactional
    public void activateTenant(TenantId aTenantId) {
        this.nonNullTenant(aTenantId).activate();
    }

    @Transactional
    public void deactivateTenant(TenantId aTenantId) {
        this.nonNullTenant(aTenantId).deactivate();
    }
    ...

    @Transactional(readOnly=true)
    public Tenant tenant(TenantId aTenantId) {
        Tenant tenant =
            this
                .tenantRepository()
                .tenantOfId(aTenantId);

        return tenant;
    }

    private Tenant nonNullTenant(TenantId aTenantId) {
        Tenant tenant = this.tenant(aTenantId);

        if (tenant == null) {
            throw new IllegalArgumentException(
                    "Tenant does not exist.");
        }

        return tenant;
    }
}
```

客户端通过 deactivateTenant() 请求停用一个已有的 Tenant。
要与实际的 Tenant 对象交互，我们需要通过其 TenantId 从`Repository`中获取该对象。
这里我们创建了一个名为 nonNullTenant() 的内部辅助方法，该方法会委托调用 tenant()。
此辅助方法用于防范不存在的 Tenant 实例，所有需要获取已有 Tenant 的服务方法都会使用它。

activateTenant() 和 deactivateTenant() 方法通过 Spring 的 Transactional 注解标记为写事务。
tenant() 方法则标记为只读事务。
在这三种情况下，当客户端通过 Spring 上下文获取该 Bean 并调用服务方法时，事务会被启动。
当方法正常返回时，事务将提交。
根据配置，方法作用域内抛出的异常会导致事务回滚。

但我们该如何防止这些方法被滥用，例如被恶意入侵者利用？
当涉及停用或重新启用租户这类操作时，这类操作实际上应当只允许由 SaaSOvation 授权的员工用户执行。
开通新的租户订阅者同样如此。

如果我们借助类似 Spring Security 的工具呢？
我们可以使用另一个注解：PreAuthorize 。

```java
public class TenantIdentityService {
    @Transactional
    @PreAuthorize("hasRole('SubscriberRepresentative')")
    public void activateTenant(TenantId aTenantId) {
        this.nonNullTenant(aTenantId).activate();
    }

    @Transactional
    @PreAuthorize("hasRole('SubscriberRepresentative')")
    public void deactivateTenant(TenantId aTenantId) {
        this.nonNullTenant(aTenantId).deactivate();
    }
    ...
    @Transactional
    @PreAuthorize("hasRole('SubscriberRepresentative')")
    public Tenant provisionTenant(
            String aTenantName,
            String aTenantDescription,
            boolean isActive,
            FullName anAdministratorName,
            EmailAddress anEmailAddress,
            PostalAddress aPostalAddress,
            Telephone aPrimaryTelephone,
            Telephone aSecondaryTelephone,
            String aTimeZone) {

        return
            this
                .tenantProvisioningService
                .provisionTenant(
                        aTenantName,
                        aTenantDescription,
                        isActive,
                        anAdministratorName,
                        anEmailAddress,
                        aPostalAddress,
                        aPrimaryTelephone,
                        aSecondaryTelephone,
                        aTimeZone);
    }
    ...
}
```

这是声明式的方法级安全控制，能够阻止未授权用户访问`Application Services`。
当然，用户界面也会做相应设计：对未授权用户隐藏所有相关操作入口。
但这无法阻止恶意攻击者，而声明式安全控制可以做到。

这种声明式方法安全与 IdOvation 自身提供的安全机制不同。
SaaSOvation 员工登录 IdOvation 的方式与租户用户不同。
特别是拥有特殊角色 SubscriberRepresentative 的人员，才允许执行这些敏感方法，普通租户用户则一律不允许。
这自然需要在 IdOvation 与 Spring Security 之间进行集成。

现在来看 provisionTenant() 的实现，我们会发现它委托给了一个`Domain Service`。
这一点凸显了两类服务之间的区别，尤其是当我们深入领域 TenantProvisioningService 内部时更为明显。
`Domain Service`内部包含大量的领域逻辑，而`Application Service`中的逻辑则非常少。
可以看一下该`Domain Service`所做的工作（尽管此处不展示具体代码）：

1. 实例化一个新的 Tenant `Aggregate`，并将其添加到对应的`Repository`中。
2. 为新 Tenant 分配一名新管理员，包括为该 Tenant 初始化管理员角色，并发布 TenantAdministratorRegistered 事件。
3. 发布 TenantProvisioned 事件。

如果`Application Service`除了第一步之外还要承担更多工作，就会导致领域逻辑严重泄漏到领域模型之外。
由于另外两个步骤并不属于`Application Service`务的职责，我们会将全部三个步骤都放在`Domain Service`中。
通过使用`Domain Service`，我们把这一 “重要业务流程…… 置于领域内” [[Evans](../bibli.md#evans)] <sup>[5](#5)</sup>。
同时，我们也严格遵循`Application Service`的定义：负责事务管理、安全控制，并将这一重要的租户开通流程委托给领域模型。

但不妨留意一下 provisionTenant() 的参数列表带来的问题：总共有九个参数，这显然已经过多。
我们可以通过设计简洁的`Command`对象 [[Gamma et al.](../bibli.md#gamma-et-al)] 来避免这种情况：
 “将请求封装为对象，从而可以使用不同的请求对客户端进行参数化、对请求进行排队或记录日志，并支持可撤销操作。” 
换句话说，我们可以将`Command`对象视为一种序列化的方法调用；在我们的场景中，除撤销操作外，`Command`所能提供的其他所有能力我们都需要。
设计一个`Command`类就是如此简单：

```java
public class ProvisionTenantCommand {
    private String tenantName;
    private String tenantDescription;
    private boolean isActive;
    private String administratorFirstName;
    private String administratorLastName;
    private String emailAddress;
    private String primaryTelephone;
    private String secondaryTelephone;
    private String addressStreetAddress;
    private String addressCity;
    private String addressStateProvince;
    private String addressPostalCode;
    private String addressCountryCode;
    private String timeZone;

    public ProvisionTenantCommand(...) {
        ...
    }

    public ProvisionTenantCommand() {
        super();
    }

    public String getTenantName() {
        return tenantName;
    }

    public void setTenantName(String tenantName) {
        this.tenantName = tenantName;
    }
    ...
}
```

ProvisionTenantCommand 并未使用领域模型对象，仅使用了基础类型。
它既包含一个多参数构造函数，也提供了一个无参构造函数。
搭配无参构造函数使用的公共 setter 方法，能让 UI 层的 “表单字段-到-对象” 映射器（例如基于 JavaBean 或 .NET CLR 属性）为该 Command 对象赋值。
你或许会将这个`Command`看作 DTO，但它的作用远不止于此。
由于`Command`对象的命名直接对应待执行的业务操作，其语义会更明确。
该`Command`实例可传入`Application Service`方法中使用：

```java
public class TenantIdentityService {
    ...
    @Transactional
    public String provisionTenant(ProvisionTenantCommand aCommand) {
        ...
        return tenant.tenantId().id();
    }
    ...
}
```

除了将请求发送到`Application Service` API 方法的这种方式外，正如模式所述，我们还可以选择向队列发送命令，以便将其分发给命令处理器 (Command Handler)。
可以将命令处理器视为在语义上等同于`Application Service`方法，但在时间上是解耦的。
如 [附录 A](../appendix/0.md) 所讨论的，这能够提高命令处理的吞吐量和可扩展性。

### 解耦的服务输出

前面我曾多次讨论过使用`Data Transformers`以此满足不同类型客户端对特定数据类型的需求。
该方案通过转换器生成指定类型的数据，这些数据类型会实现一个所有相关类型共同遵循的抽象接口。
从客户端的视角来看，其过程大致如下：

```java
TenantData tenantData =
    tenantIdentityService.provisionTenant(
        ..., myTenantDataTransformer);

TenantPresentationModel tenantPresentationModel =
    new TenantPresentationModel(tenantData.value());
```

`Application Service`被设计为带输入和输出的 API。
传入`Data Transformer`的目的，是生成客户端所需的特定输出类型。

如果我们采取一种完全不同的思路，并规定：`Application Services`始终声明为 void 类型，因此永远不会向客户端返回数据，那会怎样？
这要如何实现？
答案在于 [Hexagonal Architecture (4)](../ch4/0.md) 所推崇的设计思想，使用`Ports and Adapters`风格。
在这种场景下，我们会使用一个标准的输出`Port`，并搭配任意数量的`Adapters`，每种客户端类型对应一个`Adapter`。
这样一来，provisionTenant() 这类`Application Service`方法就可以设计成如下形式：

```java
public class TenantIdentityService {
    ...
    @Transactional
    @PreAuthorize("hasRole('SubscriberRepresentative')")
    public void provisionTenant(
            String aTenantName,
            String aTenantDescription,
            boolean isActive,
            FullName anAdministratorName,
            EmailAddress anEmailAddress,
            PostalAddress aPostalAddress,
            Telephone aPrimaryTelephone,
            Telephone aSecondaryTelephone,
            String aTimeZone) {

        Tenant tenant =
            this
                .tenantProvisioningService
                .provisionTenant(
                        aTenantName,
                        aTenantDescription,
                        isActive,
                        anAdministratorName,
                        anEmailAddress,
                        aPostalAddress,
                        aPrimaryTelephone,
                        aSecondaryTelephone,
                        aTimeZone);
        this.tenantIdentityOutputPort().write(tenant);
    }
    ...
}
```

这里的输出`Port`是位于应用边界、具有特定名称的`Port`。
在 Spring 中，它会是一个注入到服务中的 Bean。
provisionTenant() 只需知道一件事：它必须将从`Domain Service`获取到的 Tenant 实例通过 write() 方法写入该`Port`。
这个`Port`可以拥有任意数量的读取器，这些读取器在使用`Application Service`之前会先行注册。
当 write() 执行时，每个已注册的读取器都会收到通知，将`Port`的输出作为自己的输入进行读取。
此时，读取器可以通过既定机制（例如`Data Transformer`）对输出进行转换。

这并不是为架构增加复杂度的花哨技巧。
它的优势与任何`Ports and Adapters`架构一致，无论是软件系统还是硬件设备。
每个组件只需理解它所读取的输入、自身的行为，以及用于写入输出的`Port`即可。

向`Port`写入数据，与`Aggregate`的纯命令方法的行为大致相似：这类方法不返回任何值，但会发布 [Domain Event (8)](../ch8/0.md)。
对`Aggregate`而言，[Domain Event Publisher (8)](../ch8/0.md) 就是`Aggregate`的输出`Port`。
此外，如果我们通过`Mediator`双重派发来查询`Aggregate`状态，其思路也与`Ports and Adapters`模式类似。

`Ports and Adapters`模式的一个缺点是：它可能会让执行查询的`Application Service`方法更难命名。
以示例服务中的 tenant() 方法为例，该名称现在已不再合适，因为它不再返回所查询的租户对象。
而 provisionTenant() 这个名称依然适用于开通接口，因为它本质上是一个纯命令方法，不再返回值。
但我们可能需要为 tenant() 构思一个更合适的名称，以下方案或许能有所改进：

```java
    ...
    @Override
    @Transactional(readOnly=true)
    public void findTenant(TenantId aTenantId) {
        Tenant tenant =
            this
                .tenantRepository
                .tenantOfId(aTenantId);

        this.tenantIdentityOutputPort().write(tenant);
    }
    ...
}
```

findTenant() 这个名称或许可行，因为查找并不一定意味着需要返回结果。
无论选用哪个名称，这种情况都印证了：我们做出的每一个架构决策，都会同时带来正面与负面的影响。

#### ▶[下一节](3.md)

---

#### 5
参见 [第 7 章](../ch7/0.md) 。

