## 企业组件容器

#### ▶[上一节](4.md)

如今，企业应用服务器已成为一种通用标准化组件。
应用服务器本身及其内部运行的组件容器，几乎已没有太多创新空间。
我们可以将 Enterprise JavaBean（EJB）用作`Session Facades` [[Crupi et al.](../bibli.md#crupi-et-al)]  ，或是借助控制反转容器（如 Spring ）托管的普通 JavaBean，来简化应用服务的使用。
关于哪种方式更优一直存在争议，但各类框架之间也已出现大量融合趋同。
事实上，查看部分 JEE 服务器的内部实现便可发现，其中一些正是基于 Spring 开发的。

---
➜**底层是 WebLogic 还是 Spring ？**

如果你查看 Oracle WebLogic Server 的堆栈追踪信息，很可能会看到 Spring 框架相关的类引用。
这些类并非来自你部署的应用，而你在此场景中仅使用了标准 JEE 与 EJB Session Beans 。
你所看到的 Spring 类，是 WebLogic 自身 EJB 容器实现的一部分。
这是否算得上 “打不过就加入” 的典型案例？

---

我选择使用 Spring 框架来实现书中提供的三个示例`Bounded Contexts`。
不过，这些示例同样可以轻松迁移到其他企业容器平台。
因此，即便你的项目中没有使用 Spring，也完全不会影响理解，阅读这些示例时依然会感到轻松顺畅。
不同容器之间在逻辑上的差异微乎其微。

在 [Repositories (12)](../ch12/0.md) 一节中，可以看到用于为`Application Services`配置事务支持的 Spring 配置，该事务支持用于持久化领域对象。
这里我们来看 Spring 配置的其他部分，有两个文件值得关注：

```shell
config/spring/applicationContext-application.xml
config/spring/applicationContext-domain.xml
```

正如文件名所示，`Application Services`与领域模型组件均在这些文件中进行装配。
下面来看应用层装配中的几个配置示例：

```xml
<beans ...>
    <aop:aspectj-autoproxy/>
    <tx:annotation-driven transaction-manager="transactionManager"/>
    ...
    <bean
        id="applicationServiceRegistry"
        class="com.saasovation.identityaccess.application.
ApplicationServiceRegistry"
        autowire="byName">
    </bean>
    ...
    <bean
        id="tenantIdentityService"
        class="com.saasovation.identityaccess.application
.TenantIdentityService"
        autowire="byName">
    </bean>
    ...
</beans>
```

tenantIdentityService 这个 Bean 就是前面介绍过的那个。
该 Bean 可以被装配到其他 Spring Bean 中，例如用户界面层的相关组件。
如果你更倾向于使用`Service Factory`，而非将 Bean 实例注入到其他 Bean 中，我们可以使用配置里的另一个 Bean：applicationServiceRegistry 。
这个 Bean 提供对所有`Application Services`的查找访问，使用方式如下：

```Java
...
ApplicationServiceRegistry
    .tenantIdentityService()
    .deactivateTenant(tenantId);
```

我们可以这样做，是因为该 Bean 在新建时，自身就已被注入 Spring ApplicationContext 。

系统还提供了同类的注册中心 Bean，用于访问领域模型组件，例如`Repositories`与`Domain Services`。
以下是针对领域模型的注册中心、`Repository`及`Domain Service`的 Bean 配置：

```xml
<beans ...>
    ...
    <bean
        id="authenticationService"
        class="com.saasovation.identityaccess.infrastructure
.services.DefaultEncryptionAuthenticationService"
        autowire="byName">
    </bean>

    <bean
        id="domainRegistry"
        class="com.saasovation.identityaccess.domain.model
.DomainRegistry"
        autowire="byName">
    </bean>

    <bean
        id="encryptionService"
        class="com.saasovation.identityaccess.infrastructure
.services.MessageDigestEncryptionService"
        autowire="byName">
    </bean>

    <bean
        id="groupRepository"
        class="com.saasovation.identityaccess.infrastructure
.persistence.HibernateGroupRepository"
        autowire="byName">
    </bean>

    <bean
        id="roleRepository"
        class="com.saasovation.identityaccess.infrastructure
.persistence.HibernateRoleRepository"
        autowire="byName">
    </bean>

    <bean
        id="tenantProvisioningService"
        class="com.saasovation.identityaccess.domain.model
.identity.TenantProvisioningService"
        autowire="byName">
    </bean>

    <bean
        id="tenantRepository"
        class="com.saasovation.identityaccess.infrastructure
.persistence.HibernateTenantRepository"
        autowire="byName">
    </bean>

    <bean
        id="userRepository"
        class="com.saasovation.identityaccess.infrastructure
 .persistence.HibernateUserRepository"
        autowire="byName">
    </bean>
</beans>
```

通过 DomainRegistry ，我们可以访问任意一个在 Spring 中注册的 Bean。
所有 Bean 同样也支持通过依赖注入被引入到其他 Spring Bean 中。
因此，`Application Services`既可以选择使用`Service Factory`，也可以选择依赖注入。
关于这两种方式与基于构造函数的依赖注入方式的更深入对比，可参见 [Services (7)](../ch7/0.md) 章节。

<center><img src="../img/ownit.png" align="center" width="30%" /></center>

#### ▶[下一节](6.md)
