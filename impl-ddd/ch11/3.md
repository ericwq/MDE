## 服务工厂

#### ▶[上一节](2.md)

笔者将`Service`作为工厂使用的大部分场景均与 [Integrating Bounded Contexts (13)](../ch13/0.md)集成相关，相关详细探讨留待该章节展开。
在那一章节中，笔者的研究重点将更多放在与 [Anti-Corruption Layer (3)](../ch3.md)、 [Published Language (3)](../ch3/0.md) 以及 [Open Host Service (3)](../ch3/0.md) 的集成上。
本文则希望重点阐述工厂模式本身，以及如何将服务设计为工厂。

---
| ||
|:---|---:|
| 项目团队接下来又提供了一个来自`Collaboration Context`的示例。这是一个以 CollaboratorService 形式实现的工厂，它能够根据租户标识和用户标识生成 Collaborator 实例。|<img src="../img/ovation.4.png" width="70%"/>|

```java
package com.saasovation.collaboration.domain.model.collaborator;

import com.saasovation.collaboration.domain.model.tenant.Tenant;

public interface CollaboratorService  {

    public Author authorFrom(Tenant aTenant, String anIdentity);

    public Creator creatorFrom(Tenant aTenant, String anIdentity);

    public Moderator moderatorFrom(Tenant aTenant, String anIdentity);

    public Owner ownerFrom(Tenant aTenant, String anIdentity);
       
    public Participant participantFrom(
            Tenant aTenant,
            String anIdentity);
}
```

该`Service`提供了从`Identity and Access Context`到`Collaboration Context`的对象转换功能。
正如 [Bounded Contexts (2)](../ch2/0.md) 所述，CollabOvation 团队在讨论协作相关内容时，并不会使用「用户」这一表述。
更准确地说，在协作媒体领域中，参与协作的人员对应的角色是作者、创建者、版主、所有者以及参与者。
要实现这一领域语言的映射，团队需要在服务层的封装下与`Identity and Access Context`进行交互，并将该上下文中的用户和角色对象，转换为自身模型上下文中对应的协作者对象。

由于该`Service`负责创建所有继承自抽象基类 Collaborator 的新对象，
因此它实际上承担了工厂的职责。
我们查看其中一个接口方法的实现，就能了解到相关的部分细节：

```java
package com.saasovation.collaboration.infrastructure.services;

public class UserRoleToCollaboratorService
        implements CollaboratorService {

    public UserRoleToCollaboratorService() {
        super();
    }

    @Override
    public Author authorFrom(Tenant aTenant, String anIdentity) {
        return
            (Author)
                UserInRoleAdapter
                    .newInstance()
                    .toCollaborator(
                            aTenant,
                            anIdentity,
                            "Author",
                            Author.class);
    }
    ...
}
```

因为它是一个技术实现，该类被放置在`Infrastructure Layer`的 [Module (9)](../ch9/0.md) 中。

实现部分依附于 UserInRoleAdapter，将 tenant 租户和一个标识 ——用户的用户名—— 转换为 Author 类的实例。
该`Adapter` [[Gamma et al.](../bibli.md@gamma-et-al)] 与`Identity and Access Context`的`Open Host Service`交互，以确认给定用户是否属于名为 Author 的角色。
如果为真，该`Adapter`会委托给 CollaboratorTranslator 类，将`Published Language`集成响应转换为本地模型中的 Author 类实例。
Author 类以及其他 Collaborator 子类都是简单的`Value Object`：

```java
package com.saasovation.collaboration.domain.model.collaborator;

public class Author extends Collaborator  {
    ...
}
```

除了构造方法、equals()、hashCode() 和 toString() 之外，每个子类的所有状态与行为均继承自 Collaborator 。

```java
package com.saasovation.collaboration.domain.model.collaborator;

public abstract class Collaborator implements Serializable  {
    private String emailAddress;
    private String identity;
    private String name;

    public Collaborator(
            String anIdentity,
            String aName,
            String anEmailAddress) {
        super();
        this.setEmailAddress(anEmailAddress);
        this.setIdentity(anIdentity);
        this.setName(aName);
    }
    ...
}
```

---

`Collaboration Context`将 username 用作 Collaborator 的 identity 属性。
emailAddress 和 name 均为简单的字符串实例。
在该模型中，项目团队选择将上述每个概念都尽可能设计得简洁。
例如，用户姓名被直接存储为完整的文本格式全名。
我们通过一个基于服务的工厂，成功实现了两个`Bounded Contexts`之间生命周期与概念术语的分离。

UserInRoleAdapter 和 CollaboratorTranslator 中存在一定程度的复杂性。
简而言之，UserInRoleAdapter 仅负责与外部上下文进行通信交互，
而 CollaboratorTranslator 仅负责完成以对象创建为目的的转换工作。
有关详细内容，请参阅 [Integrating Bounded Contexts (13)](../ch13/0.md) 。

<center><img src="../img/ownit.png" align="center" width="30%" /></center>

#### ▶[下一节](4.md)

