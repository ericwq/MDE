## 领域模型中的工厂

#### ▶[上一节](0.md)

使用工厂模式的主要动机如下：

- 将创建复杂对象及`AGGREGATES`实例的职责转移至一个独立对象，该对象本身在领域模型中可无任何业务职责，但仍属于领域设计的一部分。
提供一个封装所有复杂组装逻辑的接口，使得客户端无需引用待实例化对象的具体类。
将整个`AGGREGATES`作为一个整体创建，确保其不变量约束得到遵守。[[Evans, p. 138](../bibli.md#evans)]

在领域模型中，工厂除了创建对象外，可能还承担其他职责，也可能不承担。
若一个对象的唯一用途是实例化特定类型的`Aggregate`，那么它不会承担其他任何职责，甚至不会被视为模型中的一等公民。
它仅仅是一个工厂。
如果某个`Aggregate`根提供`Factory Method`，用于创建另一类型`Aggregate`（或其内部组成部分）的实例，那么该`Aggregate`根的首要职责仍是实现其自身`Aggregate`的核心业务行为，所提供的`Factory Method`只是其众多职责中的一项。

我在示例中更常采用后一种方式。
我所演示的`Aggregate`，其构建过程大多并不复杂。
但`Aggregate`构建的部分重要细节必须得到保护，避免产生错误的对象状态。
以多租户环境的需求为例：若`Aggregate`实例在错误的租户下被创建、赋予了错误的 TenantId，其后果可能是灾难性的。
我们负有高度的责任，确保每个租户的所有数据都与其他租户的数据隔离开来，且处于安全状态。
在特定的`Aggregate`根上设置经精心设计的`Factory Method`，能够保证租户标识及其他关联标识被正确创建。
该方式通过对客户端隐藏`Aggregate`的构建细节，仅要求客户端传入基础参数，通常仅为 [Value Objects (6)](../ch6/0.md) ，从而实现客户端逻辑的简化。

此外，`Aggregate`上的`Factory Method`能让你以仅靠构造方法无法实现的方式表达`Ubiquitous Language`。
当这个行为方法的命名贴合`Ubiquitous Language`、具备清晰的语义表达时，便为`Factory Method`的使用增添了一个强有力的理由。

|牛仔逻辑||
|:---|---:|
|LB：“我以前在消防栓厂上班，那地方附近压根没法停车。”|<img src="../img/cbl.3.png" width="50%"/>|

部分示例`Bounded Contexts`的构建过程确实存在复杂性，
这类情况多出现于 [Integrating Bounded Contexts (13)](../ch13/0.md) 的场景中。
此时，[Services (7)](../ch7/0.md) 会充当工厂的角色，创建各类`Aggregates`或`Value Objects`的实例。

`Abstract Factory`模式能发挥极大效用的一种典型场景，是在类层级结构中创建不同类型的对象，这也是该模式的经典用法。
此时客户端仅需传入若干基础参数，工厂便可依据这些参数确定需要创建的具体对象类型。
本文的示例中并未涉及任何领域专属的类层级结构，因此在此不演示该用法。
若你在后续的领域建模工作中遇到类层级结构的设计需求，建议参考 [Repositories (12)](../ch12/0.md) 相关章节中的探讨内容。
这能让你在开展相关工作时做到心中有数。
倘若你决定在设计中采用类层级结构，就要做好应对其潜在问题的准备。


#### ▶[下一节](2.md)
