## `Aggregate`根上的工厂方法

#### ▶[上一节](1.md)

在三个示例`Bounded Contexts`中，`Aggregate`根`Entities`均设有工厂的实现点位，[表 11.1](#table-111) 对相关内容进行了汇总。

笔者已在 [Aggregates (10)](../ch10/0.md) 章节中探讨过 Product 的工厂方法。
例如，Product 的 planBacklogItem() 方法会创建一个新的 BacklogItem，后续将该`Aggregate`聚合返回至客户端。

为演示工厂方法的设计思路，本文将以`Collaboration Context`内的三个工厂方法为例展开说明。

#### Table 11.1

|`Bounded Context` | `Aggregate` | 工厂方法|
| ---- | ---- | ---- |
|`Identity and Access Context` | Tenant | offerRegistrationInvitation() |
| | | provisionGroup()|
| | | provisionRole()|
| | | registerUser()|
|`Collaboration Context`| Calendar | scheduleCalendarEntry()|
| | Forum | startDiscussion()|
| | Discussion | post()|
|`Agile PM Context`| Product | planBacklogItem()|
| | | scheduleRelease()|
| | | scheduleSprint()|

*`Aggregate`上的工厂方法点位*

### 创建 CalendarEntry 实例

让我们看一下设计。
我们现在考虑的工厂位于 Calendar 上，用于创建 CalendarEntry 实例。
CollabOvation 团队带我们了解实现过程。

---
| ||
|:---|---:|
|这里有一个测试，用于演示 Calendar 工厂方法应该如何使用：|<img src="../img/ovation.4.png" width="30%"/>|

```java
public class CalendarTest extends DomainTest {
    private CalendarEntry calendarEntry;
    private CalendarEntryId calendarEntryId;
    ...
    public void testCreateCalendarEntry() throws Exception {

        Calendar calendar = this.calendarFixture();

        DomainRegistry.calendarRepository().add(calendar);

        DomainEventPublisher
            .instance()
            .subscribe(
                new DomainEventSubscriber<CalendarEntryScheduled>() {
                public void handleEvent(
                        CalendarEntryScheduled aDomainEvent) {
                    calendarEntryId = aDomainEvent.calendarEntryId();
                }
                public Class<CalendarEntryScheduled>
                        subscribedToEventType() {
                    return CalendarEntryScheduled.class;
                }
            });

        calendarEntry =
            calendar.scheduleCalendarEntry(
                    DomainRegistry
                        .calendarEntryRepository()
                        .nextIdentity(),
                    new Owner(
                        "jdoe",
                        "John Doe",
                        "jdoe@lastnamedoe.org"),
                    "Sprint Planning",
                    "Plan sprint for first half of April 2012.",
                    this.tomorrowOneHourTimeSpanFixture(),
                    this.oneHourBeforeAlarmFixture(),
                    this.weeklyRepetitionFixture(),
                    "Team Room",
                    new TreeSet<Invitee>(0));

        DomainRegistry.calendarEntryRepository().add(calendarEntry);

        assertNotNull(calendarEntryId);
        assertNotNull(calendarEntry);
        ...
    }
}
```

向 scheduleCalendarEntry() 方法传入了 9 个参数。
不过我们后续会看到，CalendarEntry 的构造方法总共需要 11 个参数。
我们稍后再来探讨这种设计带来的好处。
当一个新的 CalendarEntry 实例被成功创建后，客户端必须将其添加到对应的`Repository`中，
否则这个新实例将会被垃圾回收器回收销毁。

第一个断言用于验证事件所携带的 CalendarEntryId 必须非空，以此确认该事件已成功发布。
值得说明的是，Calendar 的直接调用客户端并非一定会订阅该事件，但本测试能够证明 CalendarEntryScheduled 事件确实已被发布。

新创建的 CalendarEntry 实例同样必须非空。
我们本可以添加更多断言，但上述两个断言对于记录工厂方法的设计以及客户端对该方法的使用方式而言，是最为重要的。

现在，我们来查看这个工厂方法的具体实现：

```java
package com.saasovation.collaboration.domain.model.calendar;
public class Calendar extends Entity  {
    ...
    public CalendarEntry scheduleCalendarEntry(
            CalendarEntryId aCalendarEntryId,
            Owner anOwner,
            String aSubject,
            String aDescription,
            TimeSpan aTimeSpan,
            Alarm anAlarm,
            Repetition aRepetition,
            String aLocation,
            Set<Invitee> anInvitees) {
 
        CalendarEntry calendarEntry =
            new CalendarEntry(
                    this.tenant(),
                    this.calendarId(),
                    aCalendarEntryId,
                    anOwner,
                    aSubject,
                    aDescription,
                    aTimeSpan,
                    anAlarm,
                    aRepetition,
                    aLocation,
                    anInvitees);

        DomainEventPublisher
            .instance()
            .publish(new CalendarEntryScheduled(...));

        return calendarEntry;
    }
... }
```

---

Calendar 会实例化一个新的`Aggregate`，即 CalendarEntry 。
在 CalendarEntryScheduled 事件发布完成后，这个新实例会被返回给客户端。
（本次讨论不关注事件发布的具体细节。）
你可能会注意到，该方法的开头并未设置校验逻辑 (guard)。
其实无需在工厂方法本身中添加校验，因为所有`Value`类型参数的构造方法、CalendarEntry 的构造方法，以及该构造方法通过自委托调用的所有 setter 方法，已经提供了所需的全部校验逻辑。
（关于自委托和校验逻辑的更多细节，可参阅 [Entities (5)](../ch5/0.md) ）
如果你希望做到万无一失，也可以在此处额外添加一层校验 (guards)。

---
| ||
|:---|---:|
| 团队对该方法名称的设计遵循了`Ubiquitous Language`的要求。领域专家与项目团队其他成员共同讨论了如下业务场景：</br>- Calendars 安排 calendar entries 。|<img src="../img/ovation.1.png" width="50%"/>|

倘若我们的设计仅为 CalendarEntry 提供一个公共构造方法，这不仅会降低模型的表达力，还将无法明确地对这部分领域语言进行建模。
采用当前这种设计，就需要将完整的`Aggregate`构造方法对客户端隐藏起来。
我们将该构造方法声明为 protected ，以此强制客户端必须使用 Calendar 上的 scheduleCalendarEntry() 工厂方法。

```java
public class CalendarEntry extends Entity  {
    ...
    protected CalendarEntry(
        Tenant aTenant, CalendarId aCalendarId,
        CalendarEntryId aCalendarEntryId, Owner anOwner,
        String aSubject, String aDescription, TimeSpan aTimeSpan,
        Alarm anAlarm, Repetition aRepetition, String aLocation,
        Set<Invitee> anInvitees) {
        ...
    }
    ...
}
```

这种 Calendar 工厂方法具备诸多优势：能确保严谨构建、降低客户端的使用成本，还能具备强表达力的领域模型，但它也存在一个弊端，即会带来些许额外的性能开销。
和所有这类`Aggregate`工厂方法一样，要使用 Calendar 来创建 CalendarEntry，必须先从持久化存储中获取 Calendar 实例本身。
这笔额外的性能损耗在很多情况下是完全值得的，但随着该`Bounded Context`的访问流量不断增加，团队必须谨慎权衡其带来的潜在影响。

使用工厂模式的一大相关优势在于，CalendarEntry 构造方法所需的两个参数无需由客户端传入。
该构造方法共需要 11 个必要参数，而这种设计减轻了客户端的负担，仅要求客户端提供 9 个参数即可。
这 9 个必填参数中的大部分，客户端都能相当轻松地创建出来。
（诚然，Invitee 实例 Set 的创建相对复杂，但这并非工厂方法的问题。
团队应当考虑设计一套便捷机制来提供该 Set，这或许意味着需要创建一个专门的工厂。）

尽管如此，Tenant 与相关联的 CalendarId 仅由该工厂方法统一提供，
这正是我们保障 CalendarEntry 实例只会为正确的 Tenant 创建、且仅与正确的 Calendar 相关联的关键所在。

---

现在，我们再来看一个来自`Collaboration Context`的示例。

### 创建 Discussion 实例

来看看 Forum 上的工厂方法。
该方法的设计初衷与 Calendar 上的工厂方法一致，实现方式也极为相似，因此无需对其展开详尽阐述。
而正如团队所展示的，在此处使用工厂方法还能带来一项额外优势。

---
请留意 Forum 上的特定语言 startDiscussion() 工厂方法：

```java
package com.saasovation.collaboration.domain.model.forum;

public class Forum extends Entity  {
    ...
    public Discussion startDiscussion(
            DiscussionId aDiscussionId,
            Author anAuthor,
            String aSubject) {

        if (this.isClosed()) {
            throw new IllegalStateException("Forum is closed.");
        }

        Discussion discussion = new Discussion(
                this.tenant(),
                this.forumId(),
                aDiscussionId,
                anAuthor,
                aSubject);

        DomainEventPublisher
            .instance()
            .publish(new DiscussionStarted(...));

        return discussion;
    }
    ...
}
```

该工厂方法除了创建 Discussion 实例外，还会做防护校验，若 Forum 处于关闭状态，则禁止创建新的实例。
Tenant 与关联的 ForumId 均由 Forum 统一提供，
因此客户端只需传入创建新 Discussion 实例所需五个参数中的三个即可。

该工厂方法同样贴合`Collaboration Context`的`Ubiquitous Language`。
团队通过 Forum 的 startDiscussion() 方法，将领域专家口中的业务规则精准落地为设计实现：

- 作者在论坛中发起讨论。

这一设计也让客户端的调用逻辑变得极为简洁：

```java
Discussion discussion = agilePmForum.startDiscussion(
    this.discussionRepository.nextIdentity(),
    new Author("jdoe", "John Doe", "jdoe@saasovation.com"),
    "Dealing with Aggregate Concurrency Issues");

assertNotNull(discussion);
...
this.discussionRepository.add(discussion);
```

---

简洁，的确，这一直是领域建模者的目标。

这个工厂方法模式可以根据需要重复使用。
我认为已经充分展示了在`Aggregate`上使用工厂方法如何有效地表达上下文中的语言，减少客户端在创建新的`Aggregate`实例时的负担，并确保实例化时状态正确。

#### ▶[下一节](3.md)
