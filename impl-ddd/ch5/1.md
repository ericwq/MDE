## 为什么我们使用`Entities`

#### ▶[上一节](0.md)

当我们关心一个领域概念的个体性，并且必须将其与系统中的所有其他对象区分开时，我们将其设计为`Entity`。`Entity`是独特的存在，并且能够在很长一段时间内持续变化。变化可能非常大，以至于对象看起来与以前有很大不同。然而，它在身份上仍然是同一个对象。

当对象发生变化时，我们可能会希望追踪变更发生的时间、方式以及执行人。也有可能，我们认为对象的当前状态，就足以体现其过往的状态变迁过程，因此无需进行显式的变更追踪。即便我们决定不追踪对象变更历史的每一个细节，仍然可以梳理和探讨这些对象在其整个生命周期内，可能出现的有效变更序列。正是唯一标识与可变性这两项特性，让`Entities`有别于 [Value Object (6)](../ch6/0.md) 。

有些时候，`Entity`并非恰当的建模工具。这种误用的发生频率，远比很多人以为的要高。实际上，有不少概念更适合被建模为`Value`。如果你难以认同这种思路，那或许 DDD 并不契合你的业务需求。此时，一个基于 CRUD 的系统可能会更合适。若真是如此，选择这种方案理应能为你的项目节省时间与成本。但问题在于，采用基于 CRUD 的替代方案，并非总能省下这些宝贵的资源。

企业常常耗费大量精力，去开发那些华而不实的数据库表编辑器。若未能选对合适的工具，即便是精心打造的基于 CRUD 的解决方案，也会产生过高的成本。当 CRUD 模式切实适用时，像 Groovy、Grails、Ruby on Rails 这类编程语言与框架，会是最优的选择。只要选型得当，就必然能为项目节省时间与成本。

|牛仔逻辑||
|------|---|
|AJ：“我这是踩了什么鬼玩意儿？”</br> LB：“这是牛屎蛋子，J！”</br> AJ：“我知道啥叫馅饼。苹果派、樱桃派我都认识，这玩意儿哪能叫馅饼。”</br>LB：“老话儿说得好，‘大热天的，可别去踢牛屎蛋子’。还好你没一脚踹上去。” |<img src="../img/cbl.1.png" width="40%" />|

另一方面，如果我们将 CRUD 应用于错误的系统 ——那些更复杂、需要 DDD 精确性的系统—— 我们可能会后悔。当复杂性增加时，我们会体验到工具选择不当的局限性。CRUD 系统仅仅通过捕获数据，是无法生成精细的业务模型的。

如果 DDD 在业务收益上是值得的投资，我们就按预期使用`Entities`。

 - 当一个对象是通过其身份而不是属性来区分时，应将其身份作为模型中定义的主要依据。保持类定义简单，并专注于生命周期的连续性和身份。定义一种方法来区分每个对象，无论其形式或历史如何……模型必须定义什么意味着是同一事物。 [[Evans，p. 92](../bibli.md#evans)]

本章将指导你如何正确聚焦`Entities`的核心价值，并为你介绍多种`Entity`设计技巧。

#### ▶[下一节](2.md)
