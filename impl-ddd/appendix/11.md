## 读取模型投影

#### ▶[上一节](10.md)

A+ES 设计方式中一个常见的问题是如何根据`Aggregate`的属性对其进行查询。
`Event Sourcing`本身无法简单地回答诸如 “过去一个月内所有客户订单的总金额是多少？” 这类问题。
实际上我们需要加载每一个客户实例，遍历其中过去一个月的所有订单实例，然后计算总额，这种方式效率极低。

这时读取模型投影 (Read Model Projections) 就能发挥作用。
读取模型投影 (Read Model Projections) 可以通过一组简单的领域事件订阅器来实现，用于生成并更新持久化的读取模型 (Read Model)。
换句话说，它们 *将事件投影到持久化的读取模型 (Read Model) 中* 。
当事件订阅器接收到新事件时，会计算出相应的查询结果并存储到读取模型中，供后续使用。

简言之，投影 (Projection) 与`Aggregate`实例极为相似。
当事件被接收并处理时，我们会利用其中的数据构建投影 (Projection) 的状态。
读取模型投影 (Read Model Projections) 会在每次更新后持久化，且`Bounded Context`内部和外部的众多读取者均可对其进行访问。

---
➜**投影 (Projection) 相关示例可供参考**

有关投影 (Projections) 使用方法的更多信息，包括适用于各类持久化场景的源代码以及读取模型 (Read Models) 的自动重建相关代码，可在示例项目中查阅，项目地址： http://lokad.github.com/lokad-cqrs/ 。

---

以下为我们定义投影 (Projection) 以捕获每位 Customer 的所有交易记录的实现方式：

```csharp
public class CustomerTransactionsProjection
{
  IDocumentWriter<CustomerId, CustomerTransactions> _store;

  public CustomerTransactionsProjection(
    IDocumentWriter<CustomerId, CustomerTransactions> store)
  {
    _store = store;
  }

  public void When(CustomerCreated e)
  {
    _store.Add(e.Id, new CustomerTransactions());
  }

  public void When(CustomerChargeAdded e)
  {
    _store.UpdateOrThrow(e.Id,
      v => v.AddTx(e.ChargeName, -e.Charge, e.NewBalance, e.TimeUtc));
  }

  public void When(CustomerPaymentAdded e)
  {
    _store.UpdateOrThrow(e.Id,
      v => v.AddTx(e.PaymentName, e.Payment, e.NewBalance, e.TimeUtc));
  }
}
```

这个投影 (Projection) 类与使用 Lambda 表达式、为 A+ES 设计的`Application Service`类似。
不过，我们的投影 (Projection) 是对事件做出响应，而非对`Command`；并且它通过 IDocumentWriter 更新文档，而不是更新`Aggregate`实例。

底层的读取模型实际上只是一个简单的 DTO [[Fowler](../bibli.md#fowler)] ，可以通过 IDocumentWriter 进行序列化，并持久化到某种底层存储中。

```csharp
[Serializable]
public class CustomerTransactions
{
  public IList<CustomerTransaction> Transactions =
    new List<CustomerTransaction>();

  public void AddTx(
    string name, CurrencyAmount change,
    CurrencyAmount balance, DateTime timeUtc)
  {
    Transactions.Add(new CustomerTransaction()
    {
        Name = name,
        Balance = balance,
        Change = change,
        TimeUtc = timeUtc
    });
  }
}

[Serializable]
public class CustomerTransaction
{
  public CurrencyAmount Change;
  public CurrencyAmount Balance;
  public string Name;
  public DateTime TimeUtc;
}
```

将读取模型 (Read Model) 持久化到文档数据库是一种常见做法，当然也可以使用其他方案。
我们可以将读取模型 (Read Model) 缓存在内存中（例如 memcached 实例），以文档形式推送到内容分发网络，或者将其持久化到关系型数据库的表中。

除了可扩展性 (scalability) 之外，投影 (Projections) 的一大优势在于它们完全可以丢弃。
在应用程序的整个生命周期内，随时都可以添加、修改甚至完全替换它们。
若要替换整个读取模型 (Read Model)，只需丢弃现有全部数据，再通过投影 (Projection) 类重新处理完整的事件流，生成新数据即可。
该过程可以自动化实现，甚至在完全替换读取模型 (Read Model) 时还能做到不停机。

#### ▶[下一节](12.md)
