## 单元测试与规约

#### ▶[上一节](15.md)

在创建单元测试时，使用`Event Sourcing`还能带来一项额外优势。
我们可以轻松地以 *Given-When-Expect* 的形式来定义测试，步骤如下：

1. ***Given*** 过去发生的事件
2. ***When*** 当调用`Aggregate`方法时
3. ***Expect*** 产生以下事件或抛出异常

其工作方式如下：在单元测试开始时，使用历史事件来初始化`Aggregate`的状态。
接着执行待测试的`Aggregate`方法，按需传入测试参数与`Domain Services`的 mock 实现。
最后，将`Aggregate`产生的事件与期望的事件进行比对，以此断言预期结果。

这种方法使我们能够捕获并验证与每个`Aggregate`相关的行为。
同时，我们与`Aggregate`状态的内部实现保持解耦。
这有助于降低测试的 *脆弱性* ，因为开发团队可以任意修改和优化每个`Aggregate`的实现，只要单元测试确认行为契约得到满足即可。

可以将这种方法再向前推进一步：直接使用`Command`来表示 When 子句，并将其传递给托管被测`Aggregate`的对应`Application Service`。
<ins>这让我们能够完全以`Ubiquitous Language`的术语，将单元测试表达为一种 *规约 (specification)* ，既可以通过代码实现，也可以创建 DSL 来实现</ins>。

只需少量代码，这类规约就可以自动输出为领域专家能够理解、可读性良好的用例。
这些用例定义能够帮助项目团队更好地沟通具有复杂行为的领域，从而提升建模效果。

以下是由文本文档定义的一个简单规约：

```txt
[Passed] Use case 'Add Customer Payment - Unlock On Payment'.
Given:
 1. Created customer 7 Eur 'Northwind' with key c67b30 ...
 2. Customer locked
When:
  Add 'unlock' payment 10 EUR via unlock
Expectations:
  [ok] Tx 1: payment 10 EUR 'unlock' (none)
  [ok] Customer unlocked
```

<ins>如果你对这种方法感兴趣，可以在网上搜索 “Event Sourcing Specifications” ，会找到详细的指导资料</ins>。

#### ▶[下一节](17.md)
