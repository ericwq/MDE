## 函数式语言中的`Event Sourcing`

#### ▶[上一节](16.md)

前面概述的实现模式侧重于面向对象的方法，这对于像 Java 和 C# 这样的编程语言来说非常适合。
然而，`Event Sourcing`本质上具有函数式特性。
因此，它可以使用像 F# 和 Clojure 这样的函数式语言成功实现。
这样做可能会产生更简洁且性能最优的代码。

以下是从面向对象方法切换到函数式方法实现`Aggregate`的一些特殊情况：

- 我们必须从使用可变的面向对象`Aggregate`状态对象，转向设计一个简单的不可变状态记录，并搭配一组状态变更函数。
这些状态变更函数仅接收一个状态记录和事件参数，最终返回一个新的状态记录作为结果。
这非常类似于不可变`Value Object`的设计思路，其无副作用函数仅会根据自身状态和函数参数生成新的值。
这类函数的形式为`Func<State, Event, State>`。

- 当前`Aggregate`状态可定义为所有传入状态变更函数的历史事件的左折叠。

- `Aggregate`方法也可以转换为一组无状态函数，这些函数接收`Command`参数、`Domain Services`与状态作为输入，返回零个或多个事件，其形式为`Func<TArg1, TArg2..., State, Event[]>`。

- `Event Store`可以被理解和描述为一种 *functional database* ，因为它持久化的是用于修改`Aggregate`状态的那些函数的参数。
在函数式`Event Store`中支持快照，对函数式程序员来说就是熟知的 *memoization* 技术。

借助函数式编程语言中的 A+ES 来捕获核心业务概念的开发探索，可以加速我们的领域建模工作。
<ins>更重要的是，它迫使我们将领域探索的重心从`Aggregate`结构，转向严格反映由领域行为所表达的领域`Ubiquitous Language` </ins>。
任何能够帮助我们更聚焦于`Core Domain`、更少关注技术本身的做法，都更有可能为业务创造更多价值，并帮助其获得更强的竞争优势。

#### ▶[下一节](../bibli.md)
