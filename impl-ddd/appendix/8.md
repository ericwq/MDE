## 关系型持久化

#### ▶[上一节](7.md)

关系型数据库所提供的功能特性与强一致性保障，使其成为实现 “仅追加式（append-only）持久化” 最简便的方案。
许多企业早已将一种或多种关系型数据库产品作为技术标准，这意味着将其用于`Event Store`几乎无需额外成本，也不存在学习曲线。

由于 MySQL 数据库是一款流行的开源关系型数据库服务器，且支持多平台部署，我们将以它为例实现`Event Store`。
MySQLAppendOnlyStore 类实现了 IAppendOnlyStore 接口，作为底层访问层：
它会将事件以二进制数据形式存储到 ES_Events 数据表中，并在后续加载这些已持久化的事件。

以下是该数据表的定义，其作用是为`Bounded Context`中的每种`Aggregate`类型管理对应的事件流（Event Stream）：

```sql
CREATE TABLE IF NOT EXISTS `ES_Events` (
  `Id` int NOT NULL AUTO_INCREMENT,    -- unique id
  `Name` nvarchar(50) NOT NULL,        -- name of the stream
  `Version` int NOT NULL,              -- incrementing stream version
  `Data` LONGBLOB NOT NULL             -- data payload
)
```

要通过事务将事件追加到指定的事件流（Stream），请执行以下步骤：

1. 开启事务。
2. 检查`Event Store`的版本是否偏离预期版本；若偏离，则抛出异常。
3. 若无并发冲突，则追加事件。
4. 提交事务。

以下是 Append() 方法的源代码：

```csharp
public void Append(string name, byte[] data, int expectedVersion)
{
  using (var conn = new MySqlConnection(_connectionString))
  {
    conn.Open();
    using (var tx = conn.BeginTransaction())
    {
      const string sql =
        @"SELECT COALESCE(MAX(Version),0)
          FROM `ES_Events`
          WHERE Name=?name";
      int version;
      using (var cmd = new MySqlCommand(sql, conn, tx))
      {
        cmd.Parameters.AddWithValue("?name", name);
        version = (int)cmd.ExecuteScalar();
        if (expectedVersion != -1)
        {
          if (version != expectedVersion)
          {
            throw new AppendOnlyStoreConcurrencyException(
              version, expectedVersion, name);
          }
        }
      }

      const string txt =
           @"INSERT INTO `ES_Events` (`Name`, `Version`, `Data`)
            VALUES(?name, ?version, ?data)";

      using (var cmd = new MySqlCommand(txt, conn, tx))
      {
        cmd.Parameters.AddWithValue("?name", name);
        cmd.Parameters.AddWithValue("?version", version+1);
        cmd.Parameters.AddWithValue("?data", data);
        cmd.ExecuteNonQuery();
      }
      tx.Commit();
    }
  }
}
```

从 IAppendOnlyStore 中读取数据的逻辑十分简单，仅需执行基础查询即可。
例如，以下是获取某一`Aggregate`事件流记录列表的实现方式：

```csharp
public IEnumerable<DataWithVersion> ReadRecords(
  string name, int afterVersion, int maxCount)
{
  using (var conn = new MySqlConnection(_connectionString))
  {
    conn.Open();
    const string sql =
      @"SELECT `Data`, `Version` FROM `ES_Events`
        WHERE `Name` = ?name AND `Version`>?version
        ORDER BY `Version`
        LIMIT 0,?take";
    using (var cmd = new MySqlCommand(sql, conn))
    {
      cmd.Parameters.AddWithValue("?name", name);
      cmd.Parameters.AddWithValue("?version", afterVersion);
      cmd.Parameters.AddWithValue("?take", maxCount);
      using (var reader = cmd.ExecuteReader())
      {
        while (reader.Read())
        {
          var data = (byte[])reader["Data"];
          var version = (int)reader["Version"];
          yield return new DataWithVersion(version, data);
        }
      }
    }
  }
}
```

你可以在示例代码的其余部分中找到这个基于 MySQL 的`Event Store`的完整源代码。
我们也为 Microsoft SQL Server 提供了一套类似的实现。

#### ▶[下一节](9.md)
