## 聚焦型`Aggregates`

#### ▶[上一节](9.md)

在使用传统持久化方式开发`Aggregate`时（例如不采用`Event Sourcing`的关系型数据库），向系统中引入新`Entity`或丰富现有`Entity`所带来的开发阻力会十分明显。
我们需要创建新表、定义新的映射架构与`Repository`方法。
如果我们倾向于抗拒这类开发开销，就会导致`Aggregate`不断膨胀，将更多状态结构与行为集中到每个聚合中。
相比于创建新`Aggregate`，对现有`Aggregate`进行扩展会容易得多。

不过，如果`Aggregate`能更轻松地从头设计，我们的倾向就会发生改变。
而我认为，在使用`Event Sourcing`时，情况确实如此。
根据我的经验，采用 A+ES 设计的`Aggregate`往往会更小，而这正是`Aggregate`设计的一条核心经验法则。

例如，对于一家提供软件即服务（SaaS）的公司而言，现实中的客户可以通过多个聚焦于不同行为维度的独立`Aggregates`来表示：

- Customer:505：负责账单、发票以及常规账户管理相关行为。
- Security-Account:505：维护多个用户及其各自的访问权限。
- Consumer:505：跟踪实际的服务使用情况。

这些`Aggregate`类型中的每一种都可以在不同的`Bounded Context`中实现，每个`Bounded Context`使用不同的技术和架构方案。
例如，Consumer 模块可能需要具备高可扩展性 (scalability)，并处理客户每秒数千条消息的消费。
如果是这样，这类事件流就应部署在自动扩缩容的云基础设施中。
其他模块的要求则没那么高，可以部署在资源要求较低的环境中。

当然，`Aggregate`的设计绝不应随意过小。
<ins>我们始终要以保护真正的业务不变性为目标来设计`Aggregate`，而这样做可能会使某个`Aggregate`由多个`Entities`和多个`Value Objects`构成。</ins>
尽管如此，A+ES 的易用性为我们提供了更大的空间，去追求简洁高效的设计。
这是一项应尽可能加以利用的优势。

<ins>事实上，有时在领域建模初期，先通过定义主要的输入`Command`、输出事件以及要执行的行为，来构建`Ubiquitous Language`的核心，会很有帮助。
只有到后续阶段，我们才根据相似性、关联性和业务规则，将一些概念真正归类为`Aggregates`。
这种方式——即便只是作为领域建模过程中的一个临时开发探索——也能帮助我们更深刻地理解核心业务概念。</ins>

#### ▶[下一节](11.md)
