## 支持性工具与模式

#### ▶[上一节](13.md)

使用 A+ES 进行系统的开发、构建、部署和维护，需要一套与传统系统略有不同的模式。
本节介绍一些在 A+ES 实践中被证明非常实用的模式、工具和最佳实践。

### 事件序列化器

选择一款优先支持事件版本控制与重命名的序列化器是明智之举。
在 A+ES 项目初期尤其如此，因为领域模型通常会快速迭代。
以下是使用 .NET 版 Protocol Buffers <sup>[1](#1)</sup> 注解声明的一个事件示例：

```csharp
[DataContract]
public class ProjectClosed {
  [DataMember(Order=1)] public long ProjectId { get; set; }
  [DataMember(Order=2)] public DateTime Closed { get; set; }
}
```

现在，如果我们使用 DataContractSerializer 或 JsonSerializer 而非 Protocol Buffers 来序列化 ProjectClosed 事件，那么任何重命名的成员都可能轻易破坏依赖它的消费者。
例如，假设你将属性 Closed 重命名为 ClosedUtc 。
除非你在消费端的`Bounded Context`中特别处理该重命名属性的映射，否则就会出现令人困惑的错误或产生有问题的数据。

```csharp
[DataContract]
public class ProjectClosed {
  [DataMember] public long ProjectId { get; set; }
  [DataMember(Name="Closed"] public DateTime ClosedUtc { get; set; }
}
```

Protocol Buffers 能够适应不断变化的序列化场景，因为它通过整数标签而非名称来跟踪契约成员。
从下面的代码可以看出，客户端可以成功使用 Close 或 CloseUtc 作为属性名。
它序列化对象的速度极快，并且生成的二进制表示非常紧凑。
使用 Protocol Buffers，我们可以重命名事件属性而无需担心向后兼容性，从而减少领域模型演进过程中的开发阻力。

```csharp
[DataContract]
public class ProjectClosed {
  [DataMember(Order=1)] public long ProjectId { get; set; }
  [DataMember(Order=2)] public DateTime ClosedUtc { get; set; }
}
```

一些额外的跨平台序列化工具包括 Apache Thrift、Avro 和 MessagePack，这些都是颇具价值的可选方案。

### 事件不可变性

事件流本质上被认为是不可变的。
为了使开发模型与这一理念保持一致（并避免不良副作用），事件契约应实现为不可变的。
在 .NET 平台下使用 C# 实现这一点时，我们会将字段标记为只读，且仅通过构造函数为其赋值。
以之前的 ProjectClosed 事件为例，我们可将其实现为不可变形式：

```csharp
[DataContract]
public class ProjectClosed {
  [DataMember(Order=1)] public long ProjectId { get; private set }
  [DataMember(Order=2)] public DateTime ClosedUtc { get; private set; }
  public ProjectClosed(long projectId, DateTime closedUtc)
  {
    ProjectId  = projectId;
    ClosedUtc = closedUtc;
  }
}
```

### `Value Objects`

正如在 [Value Objects (6)](../ch6/0.md) 中详细讨论的，这是一种能够极大简化丰富领域模型的开发与演进的模式。
通过使用`Value Objects`，我们将内聚的基本数据类型组合成具有明确名称的不可变类型。
例如，我们不会将项目标识声明为 long 类型，而是会显式地建模为 ProjectId ：

```csharp
public struct ProjectId
{
  public readonly long Id { get; private set; }
  public ProjectId(long id)
  {
    Id = id
  }

  public override ToString() {
    return string.Format("Project-{0}", Id);
  }
}
```

我们仍然使用 long 类型来存储实际的标识号，但会用 ProjectId 类型来将它与其他所有类型区分开。
`Value`类型当然不仅限于唯一标识。
其他适用的`Value`类型还包括金额对象（尤其在多货币系统中）、地址、电子邮箱、度量值等等。

除了让事件和`Command`契约更丰富、更具表达力之外，领域`Value Objects`还为 A+ES 实现带来了更实际的好处，比如静态类型检查和 IDE 支持。
思考下面这个场景：开发者可能会不小心以错误的顺序传入参数，导致简单事件构造函数的参数错位：

```csharp
long customerId = ...;
long projectId = ...;
var event = new ProjectAssignedToCustomer(customerId, projectId);
```

这种错误编译器无法捕获，往往只能在耗费大量时间调试、令人十分沮丧后才能发现。
但如果使用`Value Objects`作为标识，编译器（以及 IDE 编辑器）就能捕获到先传入 CustomerId、后传入 ProjectId 这种错误。

```csharp
CustomerId customerId = ...;
ProjectId projectId = ...;
var event = new ProjectAssignedToCustomer(customerId, projectId);
```

当你拥有包含大量字段的扁平契约类时，这些优势会变得更加明显。
例如，考虑这个事件（已从实际生产版本简化）：

```csharp
public class CustomerInvoiceWritten {
  public InvoiceId Id { get; private set; }
  public DateTime CreatedUtc { get; private set; }
  public CurrencyType Currency { get; private set; }
  public InvoiceLine[] Lines { get; private set; }
  public decimal SubTotal { get; private set; }
  public CustomerId Customer { get; private set; }
  public string CustomerName { get; private set; }
  public string CustomerBillingAddress { get; private set; }
  public float OptionalVatRatio { get; private set; }
  public string OptionalVatName { get; private set; }
  public decimal VatTax { get; private set; }
  public decimal Total { get; private set; }
}
```

可以想象，处理一个拥有如此多属性 <sup>[2](#2)</sup> 的类会有点复杂。
我们可以根据现有的领域概念优化模型，将这个庞大的事件重构得更清晰、更易读：

```csharp
public class CustomerInvoiceWritten {
  public InvoiceId Id { get; private set; }
  public InvoiceHeader Header { get; private set; }
  public InvoiceLine[] Lines { get; private set; }
  public InvoiceFooter Footer { get; private set; }
}
```

InvoiceHeader 和 InvoiceFooter 由内聚的属性组成：

```csharp
public class InvoiceHeader {
  public DateTime CreatedUtc { get; private set; }
  public CustomerId Customer { get; private set; }
  public string CustomerName { get; private set; }
  public string CustomerBillingAddress { get; private set; }
}

public class InvoiceFooter {
  public CurrencyAmount SubTotal { get; private set; }
  public VatInformation OptionalVat { get; private set; }
  public CurrencyAmount VarAmount { get; private set; }
  public CurrencyAmount Total { get; private set; }
}
```

我们将独立的 CurrencyType Currency 和 decimal SubTotal 属性替换为了 CurrencyAmount `Value Object`。
这样做的一个额外好处是，可以为该类增加合理性校验逻辑，防止不同货币金额之间的运算以及其他不恰当操作。
同理，增值税 (VAT) 信息也可以合并到一个独立的`Value Object`中，再与其他发票汇总项一起组合到 InvoiceFooter 里。

无论是`Command`对象、事件，还是`Aggregate`组成部分，我们都应尽可能地使用`Value Object`。

显然，在`Command`和/或事件中使用`Value Objects`需要将它们一起部署，甚至需要创建一个 [Shared Kernel (3)](../ch3/0.md) 。
然而，某些高度复杂的领域可能需要设计包含极其复杂业务逻辑的`Value Objects`。
在这种情况下，仅仅为了类型安全的反序列化而将此类`Value Objects`放在`Shared Kernel`中，很可能会导致脆弱的设计。
可以将用于以类型安全方式反序列化`Command`和事件数据的简单共享类，与 [Core Domain (2)](../ch2/0.md) 所需的更复杂类区分开来。
这意味着要创建两组`Value Object`类：一组专供`Core Domain`使用，另一组则与`Command`和事件类一起部署。
两者所持有的数据可根据需要相互转换。

依个人偏好不同，复制类可能会显得过于复杂，从而导致你在系统中无意间制造出额外的复杂度。
如果你持这种观点，或许值得考虑另一种方案。
一种替代方式是将序列化后的事件标准化为 [Published Language (3)](../ch3/0.md) 。
正如在 [Integrating Bounded Contexts (13)](../ch13/0.md) 中所阐述的，你可以选择采用动态类型方式来消费事件通知。
这样就无需将事件和`Value Object`类型部署到消费端的订阅者中。
与所有方案一样，这种方式也存在需要权衡的利弊。

#### ▶[下一节](15.md)

----

#### 1
ProtocolBuffers 由谷歌首创。其他开发者也创建了其 .NET 实现版本。

#### 2
经验数据证明了一条适用的经验法则：每个类的属性成员不应超过 5 到 7 个。
