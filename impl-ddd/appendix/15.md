## 契约生成

#### ▶[上一节](14.md)

手动维护数百个事件（和`Command`）契约既繁琐又容易出错。
通常更高效的做法是，使用某种简洁的领域特定语言（DSL）来表达契约定义，并在构建时通过代码生成自动创建正确的类。
定义 DSL 语法有多种方式，我们可以考虑采用 Protocol Buffer 的 .proto 格式或类似方案。
例如，你会发现这种方式非常实用：

```pb
CustomerInvoiceWritten!(InvoiceId Id, InvoiceHeader header,
   InvoiceLine[] lines, InvoiceFooter footer)
```

一个简单的代码生成器可以利用解析后的领域特定语言（DSL）为每一行源文件生成代码。
这里举一个例子，CustomerInvoiceWritten 就是根据前面的 DSL 生成的：

```csharp
[DataContract]
public sealed class CustomerInvoiceWritten : IDomainEvent {
  [DataMember(Order=1) public InvoiceId Id
    { get; private set; }
  [DataMember(Order=2) public InvoiceHeader Header
    { get; private set; }
  [DataMember(Order=3) public InvoiceLine[] Lines
    { get; private set; }
  [DataMember(Order=4) public InvoiceFooter Footer
    { get; private set; }
  public CustomerInvoiceWriter(
    InvoiceId id, InvoiceHeader header, InvoiceLine[] lines,
    InvoiceFooter footer)
  {
    Id = id;
    Header = header;
    Lines = lines;
    Footer = footer;
  }

  // required by serializer
  ProjectClosed() {
    Lines = new InvoiceLine[0];
  }
}
```

这具有以下实际益处：

- 支持更快的领域建模迭代，减少开发阻力。

- 降低人工操作中常见的人为错误概率。

- 简洁的表示形式可让所有事件定义在一屏内展示，提供全局视图以提升理解。
这甚至可作为`Ubiquitous Language`的简明术语表。

- 可以将事件契约以简洁定义的形式进行版本管理和分发，无需依赖源码或二进制文件。
这甚至有助于加强不同团队间的协作。

同样的方法也适用于`Command`契约。
基于 DSL 的代码生成工具的开源实现及示例可在示例项目中获取。

#### ▶[下一节](16.md)
