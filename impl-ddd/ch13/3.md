## 使用消息进行集成

#### ▶[上一节](2.md)

基于消息的集成方式可以让任何一个系统相对于其所依赖的系统实现更高程度的自治性。
只要消息传递基础设施保持正常运行，即使某个系统不可用，消息仍可被发送和投递。

DDD 可用于实现系统自治性的方式之一是通过`Domain Events`。
当一个系统中发生重要事件时，它会生成一个相关的事件。
每个系统中往往会发生若干甚至许多这样的事件，你会为每个事件创建一种独特的类型来记录它。
当事件发生时，它们通过消息机制发布给相关方。
这只是一个概览。
如果你在前面的章节中跳过了该主题的细节，建议在继续阅读本节之前，先从 [Architecture (4)](../ch4/0.md) 、[Domain Events (8)](../ch8/0.md) 和 [Aggregates (10)](../ch10/0.md) 中获取一些背景知识。

### 保持了解产品负责人和团队成员

`Agile Project Management Context`需要为每个订阅该服务的租户管理一组 Scrum 产品负责人和团队成员。
产品负责人可随时创建新产品，并为团队分配成员。
Scrum 项目管理应用如何知晓谁担任这些角色？
答案是它不会独自处理。

实际上，`Agile Project Management Context`将让`Identity and Access Context`管理这些角色，这是自然且合适的选择。
在该系统中，每个订阅 Scrum 服务的租户都会创建两个角色实例：ScrumProductOwner 和 ScrumTeamMember。
需要担任其中任一角色的 User 都会被分配至对应角色。
以下是`Identity and Access Context`中管理将 User 分配至 Role 任务的`Application Service`方法：

```java
package com.saasovation.identityaccess.application;
...
public class AccessService ... {
    ...
    @Transactional
    public void assignUserToRole(AssignUserToRoleCommand aCommand) {

        TenantId tenantId =
                new TenantId(aCommand.getTenantId());

        User user =
                this.userRepository
                    .userWithUsername(
                            tenantId,
                            aCommand.getUsername());

        if (user != null) {
            Role role =
                    this.roleRepository
                        .roleNamed(
                                tenantId,
                                aCommand.getRoleName());

            if (role != null) {
                role.assignUser(user);
            }
        }
    }
    ...
}
```

很好，但这如何帮助`Agile Project Management Context`知晓谁担任 ScrumTeamMember 或 ScrumProductOwner 角色呢？
方法如下。
当 Role 的 assignUser() 方法执行完毕后，其最后一项职责是发布一个事件：

```java
package com.saasovation.identityaccess.domain.model.access;
...
public class Role extends Entity {
    ...
    public void assignUser(User aUser) {

        if (aUser == null) {
            throw new NullPointerException("User must not be null.");
        }

        if (!this.tenantId().equals(aUser.tenantId())) {
            throw new IllegalArgumentException(
                    "Wrong tenant for this user.");
        }

        this.group().addUser(aUser);

        DomainEventPublisher
            .instance()
            .publish(new UserAssignedToRole(
                    this.tenantId(),
                    this.name(),
                    aUser.username(),
                    aUser.person().name().firstName(),
                    aUser.person().name().lastName(),
                    aUser.person().emailAddress()));   
    }
    ...
}
```

携带了 User 用户名和电子邮件地址属性的 UserAssignedToRole 事件，最终会被投递到所有相关方。
当`Agile Project Management Context`接收到该事件时，会利用它在其模型中创建新的团队成员或产品负责人。
这并非一个非常复杂的用例。
然而，需要管理的细节比乍看之下要多。
让我们逐一拆解。

事实证明，监听来自 RabbitMQ 的通知存在一些高度可复用的方面。
我们已经拥有一个简单的面向对象库，可简化 RabbitMQ Java 客户端的使用。
现在我们将再添加一个简单的类，使成为交换队列消费者变得非常简单：

```java
package com.saasovation.common.port.adapter.messaging.rabbitmq;
...
public abstract class ExchangeListener {

    private MessageConsumer messageConsumer;
    private Queue queue;

    public ExchangeListener() {
        super();

        this.attachToQueue();
        this.registerConsumer();
    }

    protected abstract String exchangeName();

    protected abstract void filteredDispatch(
            String aType, String aTextMessage);

    protected abstract String[] listensToEvents();

    protected String queueName() {
        return this.getClass().getSimpleName();
    }

    private void attachToQueue() {
        Exchange exchange =
                Exchange.fanOutInstance(
                        ConnectionSettings.instance(),
                        this.exchangeName(),
                        true);

        this.queue =
                Queue.individualExchangeSubscriberInstance(
                        exchange,
                        this.exchangeName() + "." + this.queueName());
    }

    private Queue queue() {
        return this.queue;
    }

    private void registerConsumer() {
        this.messageConsumer =
                MessageConsumer.instance(this.queue(), false);

        this.messageConsumer.receiveOnly(
                this.listensToEvents(),
                new MessageListener(MessageListener.Type.TEXT) {

            @Override
            public void handleMessage(
                    String aType,
                    String aMessageId,
                    Date aTimestamp,
                    String aTextMessage,
                    long aDeliveryTag,
                    boolean isRedelivery)
            throws Exception {
                filteredDispatch(aType, aTextMessage);
            }
        });
    }
}
```

ExchangeListener 是一个抽象基类，供具体的监听器子类复用。
具体子类在扩展该抽象基类之外，只需添加少量代码。
首先，它只需确保调用基类的默认构造函数（无论如何这都会自动发生）。
然后剩下的工作就是实现三个抽象方法，其中两个实现起来非常简单：exchangeName()、filteredDispatch() 和 listensToEvents()。

实现 exchangeName() 方法时，只需返回具体监听器要消费通知的交换机 (exchange) 字符串名称。
实现抽象方法 listensToEvents() 时，必须返回一个 String[] 数组，其中包含希望接收的通知类型。
许多监听器只消费一种类型的通知，因此会返回仅含一个元素的数组。
剩下的方法 filteredDispatch() 是三者中最复杂的，因为它负责处理接收到的消息这一核心工作。
为了解其工作原理，我们来看一下针对 UserAssignedToRole 事件通知的监听器：

```java
package com.saasovation.agilepm.infrastructure.messaging;
...
public class TeamMemberEnablerListener extends ExchangeListener {

    @Autowired
    private TeamService teamService;

    public TeamMemberEnablerListener() {
        super();
    }

    @Override
    protected String exchangeName() {
        return Exchanges.IDENTITY_ACCESS_EXCHANGE_NAME;
    }

    @Override
    protected void filteredDispatch(
                String aType,
                String aTextMessage) {
        NotificationReader reader =
                new NotificationReader(aTextMessage);

        String roleName = reader.eventStringValue("roleName");

        if (!roleName.equals("ScrumProductOwner") &&
            !roleName.equals("ScrumTeamMember")) {
            return;
        }

        String emailAddress = reader.eventStringValue("emailAddress");
        String firstName = reader.eventStringValue("firstName");
        String lastName = reader.eventStringValue("lastName");
        String tenantId = reader.eventStringValue("tenantId.id");
        String username = reader.eventStringValue("username");
        Date occurredOn = reader.occurredOn();

        if (roleName.equals("ScrumProductOwner")) {
            this.teamService.enableProductOwner(
                    new EnableProductOwnerCommand(
                        tenantId,
                        username,
                        firstName,
                        lastName,
                        emailAddress,
                        occurredOn));
        } else {
            this.teamService.enableTeamMember(
                    new EnableTeamMemberCommand(
                        tenantId,
                        username,
                        firstName,
                        lastName,
                        emailAddress,
                        occurredOn));
        }
    }

    @Override
    protected String[] listensToEvents() {
        return new String[] { "com.saasovation.identityaccess.domain.model.⏎
            access.UserAssignedToRole"
            };
    }
}
```

ExchangeListener 的默认构造函数被正确调用，exchangeName() 方法返回`Identity and Access Context`所发布到的交换机 (exchange) 名称，而 listensToEvents() 方法返回一个单元素数组，其中包含 UserAssignedToRole 事件的全限定类名。
注意，发布者和订阅者应考虑使用全限定类名，其中包含模块名和类名。
这可以消除来自不同`Bounded Contexts`的同名或相似名事件可能存在的所有冲突或歧义。

同样，filteredDispatch() 包含了大部分行为逻辑。
该方法如此命名，是因为它可以在分发到`Application Service` API 之前对通知进行进一步过滤。
在本例中，它确实在分发前进行了过滤，即忽略所有非关于 ScrumProductOwner 和 ScrumTeamMember 角色的 UserAssignedToRole 类型通知。
另一方面，如果是我们感兴趣接收事件的角色，就从通知中提取 UserAssignedToRole 详情，并分发到名为 TeamService 的应用服务。
服务的 enableProductOwner() 和 enableTeamMember() 方法分别接收一个命令对象：EnableProductOwnerCommand 或 EnableTeamMemberCommand。

起初，成员似乎只是这些事件之一的结果而被创建。
然而，由于每个用户都可能被分配到这些角色之一，之后又被取消分配，然后重新分配，因此接收到的通知中用户所代表的成员可能已经存在。
以下是 TeamService 处理这种情况的方式：

```java
package com.saasovation.agilepm.application;
...
public class TeamService ... {

    @Autowired
    private ProductOwnerRepository productOwnerRepository;

    @Autowired
    private TeamMemberRepository teamMemberRepository;

    ...
    @Transactional
    public void enableProductOwner(
                EnableProductOwnerCommand aCommand) {
        TenantId tenantId = new TenantId(aCommand.getTenantId());

        ProductOwner productOwner =
                this.productOwnerRepository.productOwnerOfIdentity(
                        tenantId,
                        aCommand.getUsername());

        if (productOwner != null) {
            productOwner.enable(aCommand.getOccurredOn());
        } else {
            productOwner =
                    new ProductOwner(
                            tenantId,
                            aCommand.getUsername(),
                            aCommand.getFirstName(),
                            aCommand.getLastName(),
                            aCommand.getEmailAddress(),
                            aCommand.getOccurredOn());
 
            this.productOwnerRepository.add(productOwner);
        }
    }
}
```

例如，服务方法 enableProductOwner() 会处理特定 ProductOwner 已存在的可能性。
如果该产品负责人已存在，我们假设可能需要重新启用它，因此会分发到对应的命令操作。
如果 ProductOwner 尚不存在，我们实例化一个新的`Aggregate`并将其添加到其`Repository`中。
实际上，我们以相同的方式处理 TeamMember ，因此 enableTeamMember() 的实现方式也是如此。

### 你能承担这份责任吗？

这一切看起来都很不错，似乎足够简单。
我们有了 ProductOwner 和 TeamMember `Aggregate`类型，并且设计它们时，让每个`Aggregate`都保存了来自外部`Bounded Context`的对应用户的一些信息。
但你是否意识到，通过这种方式设计这些`Aggregates`，我们刚刚承担了多大的责任？

回想一下，在`Collaboration Context`中，团队决定只创建包含类似信息的不可变`Value Objects`（参见[使用`Anticorruption Layer`实现 REST 客户端](2.md#使用anticorruption-layer实现-rest-客户端) ）。
由于这些`Values`是不可变的，团队永远不必担心保持共享信息的最新状态。
当然，这种优势的缺点是，如果某些共享信息被更新，`Collaboration Context`将永远不会更新它过去创建的相关对象。
因此，敏捷项目管理团队选择了相反的权衡方案。

然而，现在要保持这些`Aggregates`的最新状态面临着一些挑战。
为什么呢？我们难道不能仅仅监听额外的、携带事件的通知，来反映与我们的 ProductOwner 和 TeamMember 实例相对应的 User 实例的变化吗？
是的，我们确实可以，而且必须这样做。
但我们正在使用消息传递基础设施这一事实，使得这比表面上看起来更具挑战性。

例如，假设在`Identity and Access Context`中，一位管理员错误地将乔·约翰逊从 ScrumTeamMember 角色中移除，会发生什么？
我们会收到一个携带事件的通知，表明这一情况，于是我们使用 TeamService 禁用对应乔·约翰逊的团队成员。
等等。几秒钟后，管理员意识到她移除错了用户，她本应移除的是乔·琼斯。
于是她迅速将乔·约翰逊重新分配回角色，并移除了乔·琼斯。
接下来，`Agile Project Management Context`收到相应的通知，所有人都皆大欢喜（或许除了乔·琼斯）。
但是，事情 *真的* 一切正常吗？

我们可能对这个用例做出了错误的假设。
我们假设收到通知的顺序与它们在`Identity and Access Context`中实际发生的顺序一致。
然而，事情并非总是如此顺利。
如果出于某种原因，关于乔·约翰逊的通知按以下顺序接收：先 UserAssignedToRole，再 UserUnassignedFromRole，会发生什么？
结果是，对应乔·约翰逊的 TeamMember 将陷入禁用状态，最理想的情况是有人必须修补敏捷项目管理数据库中的数据，或者管理员需要采取一些变通方法才能重新启用正确的乔。
这种情况可能发生，而且具有讽刺意味的是，当我们忽略它可能发生的事实时，它似乎总会发生。
那么，我们该如何预防这种情况？

让我们仔细看看作为参数传递给 TeamService API 的命令对象。
例如，考虑命令 EnableTeamMemberCommand 和 DisableTeamMemberCommand。
每个命令都需要提供一个 Date 对象，即 occurredOn。
事实上，我们所有的命令对象都是这样设计的。
我们将使用 occurredOn 值来确保我们的 ProductOwner 和 TeamMember `Aggregates`以感知时间的方式处理命令操作。
回想一下之前可能给我们带来麻烦的用例，让我们看看如果我们处理 UserUnassignedFromRole 通知在 UserAssignedToRole 之后到达的可能性（即使它们的发生顺序相反）会发生什么：

```java
package com.saasovation.agilepm.application;
...
public class TeamService ... {
    ...
    @Transactional
    public void disableTeamMember(DisableTeamMemberCommand aCommand) {
        TenantId tenantId = new TenantId(aCommand.getTenantId());

        TeamMember teamMember =
                this.teamMemberRepository.teamMemberOfIdentity(
                        tenantId,
                        aCommand.getUsername());

        if (teamMember != null) {
            teamMember.disable(aCommand.getOccurredOn());
        }
    }
}
```

请注意，当我们分发到 TeamMember 的 disable() 命令方法时，需要从命令对象中传递一个 occurredOn 值。
TeamMember 会在内部使用该值来确保仅在适当的情况下执行禁用操作：

```java
package com.saasovation.agilepm.domain.model.team;
...
public abstract class Member extends Entity  {
    ...
    private MemberChangeTracker changeTracker;
    ...
    public void disable(Date asOfDate) {
        if (this.changeTracker().canToggleEnabling(asOfDate)) {
            this.setEnabled(false);
            this.setChangeTracker(
                    this.changeTracker().enablingOn(asOfDate));
        }
    }

    public void enable(Date asOfDate) {
        if (this.changeTracker().canToggleEnabling(asOfDate)) {
            this.setEnabled(true);
            this.setChangeTracker(
                    this.changeTracker().enablingOn(asOfDate));
        }
    }
    ...
}
```

请注意，此`Aggregate`行为由一个通用的抽象基类 Member 提供。
disable() 和 enable() 方法都被设计为查询 changeTracker，以根据 asOfDate 参数（命令的 occurredOn 值）确定是否可以执行所请求的操作。
MemberChangeTracker `Value Object`会维护最近相关操作的发生时间，并据此响应查询：

```java
package com.saasovation.agilepm.domain.model.team;
...
public final class MemberChangeTracker implements Serializable  {
    private Date emailAddressChangedOn;
    private Date enablingOn;
    private Date nameChangedOn;
    ...
    public boolean canToggleEnabling(Date asOfDate) {
        return this.enablingOn().before(asOfDate);
    }
    ...

    public MemberChangeTracker enablingOn(Date asOfDate) {
        return new MemberChangeTracker(
                asOfDate,
                this.nameChangedOn(),
                this.emailAddressChangedOn());
    }
    ...
}
```

如果操作被允许并执行，将通过相应的 enablingOn() 方法获取一个新的 MemberChangeTracker 实例。
由于我们可以预期 PersonNameChanged 和 PersonContactInformationChanged 变更可能会乱序到达，因此 emailAddressChangedOn 和 nameChangedOn 也提供了相同类型的机制。
事实上，对于电子邮件地址变更的情况，还有一项额外的检查。
PersonContactInformationChanged 事件可能表示的是电话号码或邮政地址的变更，而不是相对不常见的电子邮件地址变更：

```java
package com.saasovation.agilepm.domain.model.team;
...
public abstract class Member extends Entity  {
    ...
    public void changeEmailAddress(
        String anEmailAddress,
        Date asOfDate) {

        if (this.changeTracker().canChangeEmailAddress(asOfDate) &&
            !this.emailAddress().equals(anEmailAddress)) {
            this.setEmailAddress(anEmailAddress);
            this.setChangeTracker(
                this.changeTracker().emailAddressChangedOn(asOfDate));

        }
    }
    ...
}
```

在这里，我们会检查电子邮件地址是否确实发生了变更。
如果没有变更，我们就不将其记录为已变更。
如果我们这样做了，那么后续一个确实携带了变更后电子邮件地址的同类型乱序事件就会被忽略。

MemberChangeTracker 还用于使 Member 子类的命令操作具备幂等性，这样当消息传递基础设施多次投递同一通知时，冗余的投递会被忽略。

我们或许会认为，在`Aggregate`设计中引入 MemberChangeTracker 是一个错误。
我们可能会得出结论，这与基于 Scrum 的团队的`Ubiquitous Language`毫无关系。
这是事实。
然而，我们从未将 MemberChangeTracker 暴露在`Aggregate`边界之外。
它是一个实现细节，客户端永远不会知道它的存在。
客户端唯一需要知道的是，它们必须提供对应修改事实发生时的 occurredOn 值。
此外，这正是 Pat Helland 在描述最终一致性的可扩展/分布式系统中如何管理伙伴关系时所要求的那种实现细节。
在那篇论文 [[Helland](../bibli.md#helland)] 中，具体请参见第 5 节 “Activities: Coping with Messy Messages.”。

现在，回到处理我们新的责任上来……

虽然这是一个维护源自外部`Bounded Context`的重复信息变更的非常基础的示例，但承担这份责任并非小事，至少在你使用可能会乱序或多次投递消息的消息传递机制时是这样。<sup>[1](#1)</sup> 此外，当我们意识到`Identity and Access Context`中所有可能对我们在 Member 中维护的少数属性产生某种影响的操作时，这可能会给我们敲响警钟：

- PersonContactInformationChanged
- PersonNameChanged
- UserAssignedToRole
- UserUnassignedFromRole

然后我们意识到，还有其他一些事件同样值得我们做出反应：

- UserEnablementChanged
- TenantActivated
- TenantDeactivated

这些事实强调，只要有可能，最好尽量减少甚至完全消除不同`Bounded Contexts`之间的信息重复。
信息重复或许无法完全避免。
服务等级协议（SLA）可能会让每次需要时都去获取远程数据变得不切实际。
这也是团队需要在本地存储用户姓名和电子邮件地址的原因之一。
然而，以减少我们需要负责的外部信息数量为目标，将使我们的工作变得轻松得多。
这是以极简主义的心态进行集成。

当然，租户与用户标识的重复是无法避免的，而不同`Bounded Contexts`之间的标识重复通常也是必要的。
这是`Bounded Contexts`之间能够实现集成的主要方式之一。
此外，标识信息是不可变的，因此可以安全地共享。
我们甚至可以通过`Aggregate`禁用与软删除机制，确保被引用的对象永远不会消失，例如我们对 Tenant, User, ProductOwner 和 TeamMember 所做的处理。

需要注意的是，这并不意味着`Domain Events`不应包含用于传递信息的属性。
显然，事件必须提供足够的信息，以告知消费者需要采取哪些步骤来响应已发生的事实。
同时，事件数据可以用于在消费方的外部`Bounded Contexts`中执行计算并推导状态，而无需实际持有这些数据，也无需承担将其与记录系统中的官方状态保持同步的责任。

### 长时运行进程与责任规避

如果把上一节所描述的内容比作一个负责任的成年人，那么本节内容就好比试图重返少年时代。
你知道，成年人必须承担各种各样的责任。
父母得买车、上保险、花钱加油，还要掏钱修车。
而作为青少年，我们只想用父母的车，却不愿承担任何相关费用。
青少年绝不可能帮父母还车贷、加油、支付修理费或保险费。
他们只管让父母处理那些麻烦的责任问题，自己只管享受用车的乐趣就好。

我们在本节中要做的，是尽情玩转 [Long-Running Pro-
cesses (4)](../ch4/0.md) ，同时确保拒绝承担那些因从其他`Bounded Contexts`复制信息而产生的、令人头疼的责任。
我们只管享受让外部`Bounded Context`为我们创建和维护数据的乐趣，之后就让记录系统自行处理它自己的信息。

在 [Context Maps (3)](../ch3/0.md) 中，我们看到了 *创建产品 (Create a Product)* 用例：

前置条件：协作功能已启用（已购买该选项）。

1. 用户提供 Product 的描述信息。
2. 用户表明希望进行团队讨论。
3. 用户请求创建已定义的 Product 。
4. 系统创建 Product，并附带一个 Forum 和 Discussion 。

好戏从这里开始，我们要把责任通过网络踢出去。

在在 [Context Maps (3)](../ch3/0.md) 中，团队曾提议采用 RESTful 方式来实现这两个`Bounded Contexts`之间的集成。
不过，团队最终还是敲定了一个基于消息的解决方案。

另外，你可能首先注意到的一点是，最初作为 Discussion 加入`Ubiquitous Language`（在第3章中）的提议概念已经得到了细化。
敏捷项目管理团队发现有必要区分讨论的类型，因此现在有了两种不同的类型：ProductDiscussion 和 BacklogItemDiscussion 。
（在本节中，我们只关注 ProductDiscussion。）
这两个`Value Objects`具有相同的基本状态和行为，但这种区分增加了类型安全性，有助于开发人员避免将错误的讨论类型附加到 Product 和 BacklogItem 上。
从实际应用的角度来看，它们是相同的。
这两种讨论类型各自仅保存其可用性状态，以及如果已创建讨论，则保存`Collaboration Context`中实际 Discussion `Aggregate`实例的标识。

值得说明的是，`Agile Project Management Context`中最初提议将一个`Value Object`命名为与`Collaboration Context`中的`Aggregate`相同的名称，这并非判断失误。
因此，需要明确的是，将`Value Object`的名称从 Discussion 改为 ProductDiscussion，并非为了将其与`Collaboration Context`中的`Aggregate`区分开来。
从`Context Mapping`的角度来看，将`Value Object`的名称保持原样完全可行，因为上下文本身就可以区分这两个对象。
在`Agile Project Management Context`中创建两种不同的`Value`类型，完全是基于独立本地模型的需求所做的决策。

深入探讨之前，我们先来看一下用于创建 Product 的`Application Service`（API）：

```java
package com.saasovation.agilepm.application;
...
public class ProductService ... {

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private ProductOwnerRepository productOwnerRepository;
    ...

    @Transactional
    public String newProductWithDiscussion(
                NewProductCommand aCommand) {
        return this.newProductWith(
                aCommand.getTenantId(),
                aCommand.getProductOwnerId(),
                aCommand.getName(),
                aCommand.getDescription(),
                this.requestDiscussionIfAvailable());
    }
    ...
}
```

创建新的 Product 实际上有两种方式。
第一种方式（此处未展示）会创建一个不带 Discussion 的产品，而此处展示的这种方式，则会尝试最终创建一个 ProductDiscussion 并将其关联至该产品。
两个内部方法，newProductWith() 和 requestDiscussionIfAvailable() 未在此处列出。
其中后者（requestDiscussionIfAvailable()）用于检查 CollabOvation 附加组件是否已启用：
若已启用，则返回状态值 REQUESTED；若未启用，则返回状态值 ADD_ON_NOT_ENABLED。
newProductWith() 方法会调用 Product 的构造函数，接下来我们就来看一下这个构造函数：


#### ▶[下一节](4.md)

---

#### 1
这可能是一个使用 RESTful 方式消费通知具有明显优势的场景，因为通知能保证按照其追加到 [Event Store (4)](../ch4/0.md) [附录 A](../appendix.md) 的相同顺序投递。
通知从第一条到最后一条，可因不同原因被反复消费，且每次都能保证顺序一致。
