## 使用消息进行集成

#### ▶[上一节](2.md)

基于消息的集成方式可以让任何一个系统相对于其所依赖的系统实现更高程度的自治性。
只要消息传递基础设施保持正常运行，即使某个系统不可用，消息仍可被发送和投递。

DDD 可用于实现系统自治性的方式之一是通过`Domain Events`。
当一个系统中发生重要事件时，它会生成一个相关的事件。
每个系统中往往会发生若干甚至许多这样的事件，你会为每个事件创建一种独特的类型来记录它。
当事件发生时，它们通过消息机制发布给相关方。
这只是一个概览。
如果你在前面的章节中跳过了该主题的细节，建议在继续阅读本节之前，先从 [Architecture (4)](../ch4/0.md) 、[Domain Events (8)](../ch8/0.md) 和 [Aggregates (10)](../ch10/0.md) 中获取一些背景知识。

### 保持了解产品负责人和团队成员

`Agile Project Management Context`需要为每个订阅该服务的租户管理一组 Scrum 产品负责人和团队成员。
产品负责人可随时创建新产品，并为团队分配成员。
Scrum 项目管理应用如何知晓谁担任这些角色？
答案是它不会独自处理。

实际上，`Agile Project Management Context`将让`Identity and Access Context`管理这些角色，这是自然且合适的选择。
在该系统中，每个订阅 Scrum 服务的租户都会创建两个角色实例：ScrumProductOwner 和 ScrumTeamMember。
需要担任其中任一角色的 User 都会被分配至对应角色。
以下是`Identity and Access Context`中管理将 User 分配至 Role 任务的`Application Service`方法：

```java
package com.saasovation.identityaccess.application;
...
public class AccessService ... {
    ...
    @Transactional
    public void assignUserToRole(AssignUserToRoleCommand aCommand) {

        TenantId tenantId =
                new TenantId(aCommand.getTenantId());

        User user =
                this.userRepository
                    .userWithUsername(
                            tenantId,
                            aCommand.getUsername());

        if (user != null) {
            Role role =
                    this.roleRepository
                        .roleNamed(
                                tenantId,
                                aCommand.getRoleName());

            if (role != null) {
                role.assignUser(user);
            }
        }
    }
    ...
}
```

很好，但这如何帮助`Agile Project Management Context`知晓谁担任 ScrumTeamMember 或 ScrumProductOwner 角色呢？
方法如下。
当 Role 的 assignUser() 方法执行完毕后，其最后一项职责是发布一个事件：

```java
package com.saasovation.identityaccess.domain.model.access;
...
public class Role extends Entity {
    ...
    public void assignUser(User aUser) {

        if (aUser == null) {
            throw new NullPointerException("User must not be null.");
        }

        if (!this.tenantId().equals(aUser.tenantId())) {
            throw new IllegalArgumentException(
                    "Wrong tenant for this user.");
        }

        this.group().addUser(aUser);

        DomainEventPublisher
            .instance()
            .publish(new UserAssignedToRole(
                    this.tenantId(),
                    this.name(),
                    aUser.username(),
                    aUser.person().name().firstName(),
                    aUser.person().name().lastName(),
                    aUser.person().emailAddress()));   
    }
    ...
}
```

携带了 User 用户名和电子邮件地址属性的 UserAssignedToRole 事件，最终会被投递到所有相关方。
当`Agile Project Management Context`接收到该事件时，会利用它在其模型中创建新的团队成员或产品负责人。
这并非一个非常复杂的用例。
然而，需要管理的细节比乍看之下要多。
让我们逐一拆解。

事实证明，监听来自 RabbitMQ 的通知存在一些高度可复用的方面。
我们已经拥有一个简单的面向对象库，可简化 RabbitMQ Java 客户端的使用。
现在我们将再添加一个简单的类，使成为交换队列消费者变得非常简单：

```java
package com.saasovation.common.port.adapter.messaging.rabbitmq;
...
public abstract class ExchangeListener {

    private MessageConsumer messageConsumer;
    private Queue queue;

    public ExchangeListener() {
        super();

        this.attachToQueue();
        this.registerConsumer();
    }

    protected abstract String exchangeName();

    protected abstract void filteredDispatch(
            String aType, String aTextMessage);

    protected abstract String[] listensToEvents();

    protected String queueName() {
        return this.getClass().getSimpleName();
    }

    private void attachToQueue() {
        Exchange exchange =
                Exchange.fanOutInstance(
                        ConnectionSettings.instance(),
                        this.exchangeName(),
                        true);

        this.queue =
                Queue.individualExchangeSubscriberInstance(
                        exchange,
                        this.exchangeName() + "." + this.queueName());
    }

    private Queue queue() {
        return this.queue;
    }

    private void registerConsumer() {
        this.messageConsumer =
                MessageConsumer.instance(this.queue(), false);

        this.messageConsumer.receiveOnly(
                this.listensToEvents(),
                new MessageListener(MessageListener.Type.TEXT) {

            @Override
            public void handleMessage(
                    String aType,
                    String aMessageId,
                    Date aTimestamp,
                    String aTextMessage,
                    long aDeliveryTag,
                    boolean isRedelivery)
            throws Exception {
                filteredDispatch(aType, aTextMessage);
            }
        });
    }
}
```

ExchangeListener 是一个抽象基类，供具体的监听器子类复用。
具体子类在扩展该抽象基类之外，只需添加少量代码。
首先，它只需确保调用基类的默认构造函数（无论如何这都会自动发生）。
然后剩下的工作就是实现三个抽象方法，其中两个实现起来非常简单：exchangeName()、filteredDispatch() 和 listensToEvents()。

实现 exchangeName() 方法时，只需返回具体监听器要消费通知的交换机 (exchange) 字符串名称。
实现抽象方法 listensToEvents() 时，必须返回一个 String[] 数组，其中包含希望接收的通知类型。
许多监听器只消费一种类型的通知，因此会返回仅含一个元素的数组。
剩下的方法 filteredDispatch() 是三者中最复杂的，因为它负责处理接收到的消息这一核心工作。
为了解其工作原理，我们来看一下针对 UserAssignedToRole 事件通知的监听器：

```java
package com.saasovation.agilepm.infrastructure.messaging;
...
public class TeamMemberEnablerListener extends ExchangeListener {

    @Autowired
    private TeamService teamService;

    public TeamMemberEnablerListener() {
        super();
    }

    @Override
    protected String exchangeName() {
        return Exchanges.IDENTITY_ACCESS_EXCHANGE_NAME;
    }

    @Override
    protected void filteredDispatch(
                String aType,
                String aTextMessage) {
        NotificationReader reader =
                new NotificationReader(aTextMessage);

        String roleName = reader.eventStringValue("roleName");

        if (!roleName.equals("ScrumProductOwner") &&
            !roleName.equals("ScrumTeamMember")) {
            return;
        }

        String emailAddress = reader.eventStringValue("emailAddress");
        String firstName = reader.eventStringValue("firstName");
        String lastName = reader.eventStringValue("lastName");
        String tenantId = reader.eventStringValue("tenantId.id");
        String username = reader.eventStringValue("username");
        Date occurredOn = reader.occurredOn();

        if (roleName.equals("ScrumProductOwner")) {
            this.teamService.enableProductOwner(
                    new EnableProductOwnerCommand(
                        tenantId,
                        username,
                        firstName,
                        lastName,
                        emailAddress,
                        occurredOn));
        } else {
            this.teamService.enableTeamMember(
                    new EnableTeamMemberCommand(
                        tenantId,
                        username,
                        firstName,
                        lastName,
                        emailAddress,
                        occurredOn));
        }
    }

    @Override
    protected String[] listensToEvents() {
        return new String[] { "com.saasovation.identityaccess.domain.model.⏎
            access.UserAssignedToRole"
            };
    }
}
```

ExchangeListener 的默认构造函数被正确调用，exchangeName() 方法返回`Identity and Access Context`所发布到的交换机 (exchange) 名称，而 listensToEvents() 方法返回一个单元素数组，其中包含 UserAssignedToRole 事件的全限定类名。
注意，发布者和订阅者应考虑使用全限定类名，其中包含模块名和类名。
这可以消除来自不同`Bounded Contexts`的同名或相似名事件可能存在的所有冲突或歧义。

同样，filteredDispatch() 包含了大部分行为逻辑。
该方法如此命名，是因为它可以在分发到`Application Service` API 之前对通知进行进一步过滤。
在本例中，它确实在分发前进行了过滤，即忽略所有非关于 ScrumProductOwner 和 ScrumTeamMember 角色的 UserAssignedToRole 类型通知。
另一方面，如果是我们感兴趣接收事件的角色，就从通知中提取 UserAssignedToRole 详情，并分发到名为 TeamService 的应用服务。
服务的 enableProductOwner() 和 enableTeamMember() 方法分别接收一个命令对象：EnableProductOwnerCommand 或 EnableTeamMemberCommand。

起初，成员似乎只是这些事件之一的结果而被创建。
然而，由于每个用户都可能被分配到这些角色之一，之后又被取消分配，然后重新分配，因此接收到的通知中用户所代表的成员可能已经存在。
以下是 TeamService 处理这种情况的方式：

```java
package com.saasovation.agilepm.application;
...
public class TeamService ... {

    @Autowired
    private ProductOwnerRepository productOwnerRepository;

    @Autowired
    private TeamMemberRepository teamMemberRepository;

    ...
    @Transactional
    public void enableProductOwner(
                EnableProductOwnerCommand aCommand) {
        TenantId tenantId = new TenantId(aCommand.getTenantId());

        ProductOwner productOwner =
                this.productOwnerRepository.productOwnerOfIdentity(
                        tenantId,
                        aCommand.getUsername());

        if (productOwner != null) {
            productOwner.enable(aCommand.getOccurredOn());
        } else {
            productOwner =
                    new ProductOwner(
                            tenantId,
                            aCommand.getUsername(),
                            aCommand.getFirstName(),
                            aCommand.getLastName(),
                            aCommand.getEmailAddress(),
                            aCommand.getOccurredOn());
 
            this.productOwnerRepository.add(productOwner);
        }
    }
}
```

例如，服务方法 enableProductOwner() 会处理特定 ProductOwner 已存在的可能性。
如果该产品负责人已存在，我们假设可能需要重新启用它，因此会分发到对应的命令操作。
如果 ProductOwner 尚不存在，我们实例化一个新的`Aggregate`并将其添加到其`Repository`中。
实际上，我们以相同的方式处理 TeamMember ，因此 enableTeamMember() 的实现方式也是如此。

### 你能承担这份责任吗？

这一切看起来都很不错，似乎足够简单。
我们有了 ProductOwner 和 TeamMember `Aggregate`类型，并且设计它们时，让每个`Aggregate`都保存了来自外部`Bounded Context`的对应用户的一些信息。
但你是否意识到，通过这种方式设计这些`Aggregates`，我们刚刚承担了多大的责任？

回想一下，在`Collaboration Context`中，团队决定只创建包含类似信息的不可变`Value Objects`（参见[使用`Anticorruption Layer`实现 REST 客户端](2.md#使用anticorruption-layer实现-rest-客户端) ）。
由于这些`Values`是不可变的，团队永远不必担心保持共享信息的最新状态。
当然，这种优势的缺点是，如果某些共享信息被更新，`Collaboration Context`将永远不会更新它过去创建的相关对象。
因此，敏捷项目管理团队选择了相反的权衡方案。

然而，现在要保持这些`Aggregates`的最新状态面临着一些挑战。
为什么呢？我们难道不能仅仅监听额外的、携带事件的通知，来反映与我们的 ProductOwner 和 TeamMember 实例相对应的 User 实例的变化吗？
是的，我们确实可以，而且必须这样做。
但我们正在使用消息传递基础设施这一事实，使得这比表面上看起来更具挑战性。

例如，假设在`Identity and Access Context`中，一位管理员错误地将乔·约翰逊从 ScrumTeamMember 角色中移除，会发生什么？
我们会收到一个携带事件的通知，表明这一情况，于是我们使用 TeamService 禁用对应乔·约翰逊的团队成员。
等等。几秒钟后，管理员意识到她移除错了用户，她本应移除的是乔·琼斯。
于是她迅速将乔·约翰逊重新分配回角色，并移除了乔·琼斯。
接下来，`Agile Project Management Context`收到相应的通知，所有人都皆大欢喜（或许除了乔·琼斯）。
但是，事情 *真的* 一切正常吗？

我们可能对这个用例做出了错误的假设。
我们假设收到通知的顺序与它们在`Identity and Access Context`中实际发生的顺序一致。
然而，事情并非总是如此顺利。
如果出于某种原因，关于乔·约翰逊的通知按以下顺序接收：先 UserAssignedToRole，再 UserUnassignedFromRole，会发生什么？
结果是，对应乔·约翰逊的 TeamMember 将陷入禁用状态，最理想的情况是有人必须修补敏捷项目管理数据库中的数据，或者管理员需要采取一些变通方法才能重新启用正确的乔。
这种情况可能发生，而且具有讽刺意味的是，当我们忽略它可能发生的事实时，它似乎总会发生。
那么，我们该如何预防这种情况？

让我们仔细看看作为参数传递给 TeamService API 的命令对象。
例如，考虑命令 EnableTeamMemberCommand 和 DisableTeamMemberCommand。
每个命令都需要提供一个 Date 对象，即 occurredOn。
事实上，我们所有的命令对象都是这样设计的。
我们将使用 occurredOn 值来确保我们的 ProductOwner 和 TeamMember `Aggregates`以感知时间的方式处理命令操作。
回想一下之前可能给我们带来麻烦的用例，让我们看看如果我们处理 UserUnassignedFromRole 通知在 UserAssignedToRole 之后到达的可能性（即使它们的发生顺序相反）会发生什么：

```java
package com.saasovation.agilepm.application;
...
public class TeamService ... {
    ...
    @Transactional
    public void disableTeamMember(DisableTeamMemberCommand aCommand) {
        TenantId tenantId = new TenantId(aCommand.getTenantId());

        TeamMember teamMember =
                this.teamMemberRepository.teamMemberOfIdentity(
                        tenantId,
                        aCommand.getUsername());

        if (teamMember != null) {
            teamMember.disable(aCommand.getOccurredOn());
        }
    }
}
```

请注意，当我们分发到 TeamMember 的 disable() 命令方法时，需要从命令对象中传递一个 occurredOn 值。
TeamMember 会在内部使用该值来确保仅在适当的情况下执行禁用操作：

```java
package com.saasovation.agilepm.domain.model.team;
...
public abstract class Member extends Entity  {
    ...
    private MemberChangeTracker changeTracker;
    ...
    public void disable(Date asOfDate) {
        if (this.changeTracker().canToggleEnabling(asOfDate)) {
            this.setEnabled(false);
            this.setChangeTracker(
                    this.changeTracker().enablingOn(asOfDate));
        }
    }

    public void enable(Date asOfDate) {
        if (this.changeTracker().canToggleEnabling(asOfDate)) {
            this.setEnabled(true);
            this.setChangeTracker(
                    this.changeTracker().enablingOn(asOfDate));
        }
    }
    ...
}
```

请注意，此`Aggregate`行为由一个通用的抽象基类 Member 提供。
disable() 和 enable() 方法都被设计为查询 changeTracker，以根据 asOfDate 参数（命令的 occurredOn 值）确定是否可以执行所请求的操作。
MemberChangeTracker `Value Object`会维护最近相关操作的发生时间，并据此响应查询：

```java
package com.saasovation.agilepm.domain.model.team;
...
public final class MemberChangeTracker implements Serializable  {
    private Date emailAddressChangedOn;
    private Date enablingOn;
    private Date nameChangedOn;
    ...
    public boolean canToggleEnabling(Date asOfDate) {
        return this.enablingOn().before(asOfDate);
    }
    ...

    public MemberChangeTracker enablingOn(Date asOfDate) {
        return new MemberChangeTracker(
                asOfDate,
                this.nameChangedOn(),
                this.emailAddressChangedOn());
    }
    ...
}
```

如果操作被允许并执行，将通过相应的 enablingOn() 方法获取一个新的 MemberChangeTracker 实例。
由于我们可以预期 PersonNameChanged 和 PersonContactInformationChanged 变更可能会乱序到达，因此 emailAddressChangedOn 和 nameChangedOn 也提供了相同类型的机制。
事实上，对于电子邮件地址变更的情况，还有一项额外的检查。
PersonContactInformationChanged 事件可能表示的是电话号码或邮政地址的变更，而不是相对不常见的电子邮件地址变更：

```java
package com.saasovation.agilepm.domain.model.team;
...
public abstract class Member extends Entity  {
    ...
    public void changeEmailAddress(
        String anEmailAddress,
        Date asOfDate) {

        if (this.changeTracker().canChangeEmailAddress(asOfDate) &&
            !this.emailAddress().equals(anEmailAddress)) {
            this.setEmailAddress(anEmailAddress);
            this.setChangeTracker(
                this.changeTracker().emailAddressChangedOn(asOfDate));

        }
    }
    ...
}
```

在这里，我们会检查电子邮件地址是否确实发生了变更。
如果没有变更，我们就不将其记录为已变更。
如果我们这样做了，那么后续一个确实携带了变更后电子邮件地址的同类型乱序事件就会被忽略。

MemberChangeTracker 还用于使 Member 子类的命令操作具备幂等性，这样当消息传递基础设施多次投递同一通知时，冗余的投递会被忽略。

我们或许会认为，在`Aggregate`设计中引入 MemberChangeTracker 是一个错误。
我们可能会得出结论，这与基于 Scrum 的团队的`Ubiquitous Language`毫无关系。
这是事实。
然而，我们从未将 MemberChangeTracker 暴露在`Aggregate`边界之外。
它是一个实现细节，客户端永远不会知道它的存在。
客户端唯一需要知道的是，它们必须提供对应修改事实发生时的 occurredOn 值。
此外，这正是 Pat Helland 在描述最终一致性的可扩展/分布式系统中如何管理伙伴关系时所要求的那种实现细节。
在那篇论文 [[Helland](../bibli.md#helland)] 中，具体请参见第 5 节 “Activities: Coping with Messy Messages.”。

现在，回到处理我们新的责任上来……

虽然这是一个维护源自外部`Bounded Context`的重复信息变更的非常基础的示例，但承担这份责任并非小事，至少在你使用可能会乱序或多次投递消息的消息传递机制时是这样。<sup>[1](#1)</sup> 此外，当我们意识到`Identity and Access Context`中所有可能对我们在 Member 中维护的少数属性产生某种影响的操作时，这可能会给我们敲响警钟：

- PersonContactInformationChanged
- PersonNameChanged
- UserAssignedToRole
- UserUnassignedFromRole

然后我们意识到，还有其他一些事件同样值得我们做出反应：

- UserEnablementChanged
- TenantActivated
- TenantDeactivated

这些事实强调，只要有可能，最好尽量减少甚至完全消除不同`Bounded Contexts`之间的信息重复。
信息重复或许无法完全避免。
服务等级协议（SLA）可能会让每次需要时都去获取远程数据变得不切实际。
这也是团队需要在本地存储用户姓名和电子邮件地址的原因之一。
然而，以减少我们需要负责的外部信息数量为目标，将使我们的工作变得轻松得多。
这是以极简主义的心态进行集成。

当然，租户与用户标识的重复是无法避免的，而不同`Bounded Contexts`之间的标识重复通常也是必要的。
这是`Bounded Contexts`之间能够实现集成的主要方式之一。
此外，标识信息是不可变的，因此可以安全地共享。
我们甚至可以通过`Aggregate`禁用与软删除机制，确保被引用的对象永远不会消失，例如我们对 Tenant, User, ProductOwner 和 TeamMember 所做的处理。

需要注意的是，这并不意味着`Domain Events`不应包含用于传递信息的属性。
显然，事件必须提供足够的信息，以告知消费者需要采取哪些步骤来响应已发生的事实。
同时，事件数据可以用于在消费方的外部`Bounded Contexts`中执行计算并推导状态，而无需实际持有这些数据，也无需承担将其与记录系统中的官方状态保持同步的责任。

### 长时运行流程与责任规避

如果把上一节所描述的内容比作一个负责任的成年人，那么本节内容就好比试图重返少年时代。
你知道，成年人必须承担各种各样的责任。
父母得买车、上保险、花钱加油，还要掏钱修车。
而作为青少年，我们只想用父母的车，却不愿承担任何相关费用。
青少年绝不可能帮父母还车贷、加油、支付修理费或保险费。
他们只管让父母处理那些麻烦的责任问题，自己只管享受用车的乐趣就好。

我们在本节中要做的，是尽情玩转 [Long-Running Pro-
cesses (4)](../ch4/0.md) ，同时确保拒绝承担那些因从其他`Bounded Contexts`复制信息而产生的、令人头疼的责任。
我们只管享受让外部`Bounded Context`为我们创建和维护数据的乐趣，之后就让记录系统自行处理它自己的信息。

在 [Context Maps (3)](../ch3/0.md) 中，我们看到了 *创建产品 (Create a Product)* 用例：

前置条件：协作功能已启用（已购买该选项）。

1. 用户提供 Product 的描述信息。
2. 用户表明希望进行团队讨论。
3. 用户请求创建已定义的 Product 。
4. 系统创建 Product，并附带一个 Forum 和 Discussion 。

好戏从这里开始，我们要把责任通过网络踢出去。

在在 [Context Maps (3)](../ch3/0.md) 中，团队曾提议采用 RESTful 方式来实现这两个`Bounded Contexts`之间的集成。
不过，团队最终还是敲定了一个基于消息的解决方案。

另外，你可能首先注意到的一点是，最初作为 Discussion 加入`Ubiquitous Language`（在第3章中）的提议概念已经得到了细化。
敏捷项目管理团队发现有必要区分讨论的类型，因此现在有了两种不同的类型：ProductDiscussion 和 BacklogItemDiscussion 。
（在本节中，我们只关注 ProductDiscussion。）
这两个`Value Objects`具有相同的基本状态和行为，但这种区分增加了类型安全性，有助于开发人员避免将错误的讨论类型附加到 Product 和 BacklogItem 上。
从实际应用的角度来看，它们是相同的。
这两种讨论类型各自仅保存其可用性状态，以及如果已创建讨论，则保存`Collaboration Context`中实际 Discussion `Aggregate`实例的标识。

值得说明的是，`Agile Project Management Context`中最初提议将一个`Value Object`命名为与`Collaboration Context`中的`Aggregate`相同的名称，这并非判断失误。
因此，需要明确的是，将`Value Object`的名称从 Discussion 改为 ProductDiscussion，并非为了将其与`Collaboration Context`中的`Aggregate`区分开来。
从`Context Mapping`的角度来看，将`Value Object`的名称保持原样完全可行，因为上下文本身就可以区分这两个对象。
在`Agile Project Management Context`中创建两种不同的`Value`类型，完全是基于独立本地模型的需求所做的决策。

深入探讨之前，我们先来看一下用于创建 Product 的`Application Service`（API）：

```java
package com.saasovation.agilepm.application;
...
public class ProductService ... {

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private ProductOwnerRepository productOwnerRepository;
    ...

    @Transactional
    public String newProductWithDiscussion(
                NewProductCommand aCommand) {
        return this.newProductWith(
                aCommand.getTenantId(),
                aCommand.getProductOwnerId(),
                aCommand.getName(),
                aCommand.getDescription(),
                this.requestDiscussionIfAvailable());
    }
    ...
}
```

创建新的 Product 实际上有两种方式。
第一种方式（此处未展示）会创建一个不带 Discussion 的产品，而此处展示的这种方式，则会尝试最终创建一个 ProductDiscussion 并将其关联至该产品。
两个内部方法，newProductWith() 和 requestDiscussionIfAvailable() 未在此处列出。
其中后者（requestDiscussionIfAvailable()）用于检查 CollabOvation 附加组件是否已启用：
若已启用，则返回状态值 REQUESTED；若未启用，则返回状态值 ADD_ON_NOT_ENABLED。
newProductWith() 方法会调用 Product 的构造函数，接下来我们就来看一下这个构造函数：

```java
package com.saasovation.agilepm.domain.model.product;
...
public class Product extends ConcurrencySafeEntity  {
    ...
    public Product(
            TenantId aTenantId,
            ProductId aProductId,
            ProductOwnerId aProductOwnerId,
            String aName,
            String aDescription,
            DiscussionAvailability aDiscussionAvailability) {

        this();

        this.setTenantId(aTenantId);
        this.setProductId(aProductId);
        this.setProductOwnerId(aProductOwnerId);
        this.setName(aName);
        this.setDescription(aDescription);
        this.setDiscussion(
                ProductDiscussion.fromAvailability(
                        aDiscussionAvailability));

        DomainEventPublisher
            .instance()
            .publish(new ProductCreated(
                this.tenantId(),
                this.productId(),
                this.productOwnerId(),
                this.name(),
                this.description(),
                this.discussion().availability().isRequested()));
    }
    ...
}
```

客户端需要传入一个 DiscussionAvailability，它可以传递以下状态之一：ADD_ON_NOT_ENABLED、NOT_REQUESTED 或 REQUESTED。
READY 状态被保留为完成状态。
前两种状态中的任何一种都会导致创建一个具有该确切状态的 ProductDiscussion，这意味着不会有相关联的讨论，至少不会是构造的结果。
如果请求的是第三种状态 REQUESTED，则 ProductDiscussion 将以 PENDING_SETUP 状态创建。
以下是 Product 构造函数使用的 ProductDiscussion 工厂方法：

```java
package com.saasovation.agilepm.domain.model.product;
...
public final class ProductDiscussion implements Serializable {
    ...
    public static ProductDiscussion fromAvailability(
            DiscussionAvailability anAvailability) {

        if (anAvailability.isReady()) {
            throw new IllegalArgumentException(
                    "Cannot be created ready.");
        }

        DiscussionDescriptor descriptor =
                new DiscussionDescriptor(
                        DiscussionDescriptor.UNDEFINED_ID);

        return new ProductDiscussion(descriptor, anAvailability);
    }
    ...
}
```

只要请求的状态不是 READY（若为该状态则会出现问题），我们就会得到一个 ProductDiscussion 对象，它会带有其他三种状态中的一种，还有一个未定义的描述符。
如果状态为 REQUESTED，一个长时运行流程（Long-Running Process）会负责管理协作讨论的创建，以及该讨论后续与 Product 的关联初始化。
具体如何实现？回想一下，Product 构造函数执行的最后一步操作是发布 ProductCreated 事件：

```java
package com.saasovation.agilepm.domain.model.product;
    ...
    public Product(...) {
        ...
        DomainEventPublisher
            .instance()
            .publish(new ProductCreated(
                this.tenantId(),
                this.productId(),
                this.productOwnerId(),
                this.name(),
                this.description(),
                this.discussion().availability().isRequested()));
    }
    ...
}
```

如果讨论可用性的状态为 REQUESTED，事件构造函数的最后一个参数将为 true，这正是启动长时运行流程所需的条件。

回想一下 [Domain Events (8)](../ch8/0.md) ；每个事件实例，包括 ProductCreated 类型的事件，都会被追加到事件发生所在的特定`Bounded Context`的`Event Store`中。
所有新追加的事件随后会通过消息传递机制从`Event Store`转发给相关方。
在 SaaSOvation 的案例中，团队决定使用 RabbitMQ 来实现这一目的。
我们需要创建一个简单的长时运行流程，来管理讨论的创建，然后将其关联到 Product 。

在深入长时运行流程的细节之前，我们再考虑一种请求讨论的可能方式。
如果某个 Product 实例在首次创建时，要么未请求讨论，要么协作附加组件仅处于启用状态，该怎么办？
之后产品负责人决定添加讨论，且附加组件现已可用。
此时，产品负责人可以在 Product 上使用此命令方法：

```java
package com.saasovation.agilepm.domain.model.product;
...
public class Product extends ConcurrencySafeEntity  {
    ...
    public void requestDiscussion(
            DiscussionAvailability aDiscussionAvailability) {
 
        if (!this.discussion().availability().isReady()) {
            this.setDiscussion(
                    ProductDiscussion.fromAvailability(
                        aDiscussionAvailability));

            DomainEventPublisher
                .instance()
                .publish(new ProductDiscussionRequested(
                    this.tenantId(),
                    this.productId(),
                    this.productOwnerId(),
                    this.name(),
                    this.description(),
                    this.discussion().availability().isRequested()));
        }
    }
    ...
}
```

方法 requestDiscussion() 接收我们熟悉的 DiscussionAvailability 参数，因为客户端必须向 Product 证明协作附加组件已启用。
当然，客户端可能会在这里投机取巧，总是传递 REQUESTED，但如果附加组件实际上不可用，这最终只会导致一个无法解决的 bug。
同样，如果讨论可用性的状态为 REQUESTED，事件构造函数的最后一个参数将为 true，这正是启动长时运行流程所需的条件：

```java
package com.saasovation.agilepm.domain.model.product;
...
public class ProductDiscussionRequested implements DomainEvent {
    ...
    public ProductDiscussionRequested(
            TenantId aTenantId,
            ProductId aProductId,
            ProductOwnerId aProductOwnerId,
            String aName,
            String aDescription,
            boolean isRequestingDiscussion) {
        ...
    }
    ...
}
```

该事件与 ProductCreated 具有完全相同的属性，这使得两种事件类型可以由同一个监听器处理。

我们可能会问，如果可用性状态不是 REQUESTED，发布此事件是否有意义。
这是有意义的，因为无论请求能否被满足，请求本身已经发出，除非当前处于 READY 状态。
监听器的职责是决定是否需要对事件做出实际响应。
例如，接收到此事件且 isRequestingDiscussion 设为 false，可能意味着存在问题，或者附加组件的设置正在进行但尚未完成。
因此，可能需要进行一些干预。例如，流程可能需要向管理员组发送一封电子邮件。

在`Agile Proj- ect Management Context`一侧，用于管理长时运行流程的类，与用于管理 ProductOwner 和 TeamMember `Aggregates`的创建与维护的类类似（参见上一节）。
此处展示的每个监听器都通过 Spring 进行装配，以便在为该`Bounded Context`创建 Spring 应用上下文时被实例化。
第一个监听器会注册自身，以在 AGILEPM_EXCHANGE_NAME 上接收两种通知：ProductCreated 和 ProductDiscussionRequested。

```java
package com.saasovation.agilepm.infrastructure.messaging;
...
public class ProductDiscussionRequestedListener
       extends ExchangeListener {
    ...
    @Override
    protected String exchangeName() {
        return Exchanges.AGILEPM_EXCHANGE_NAME;
    }
    ...

    @Override
    protected String[] listensToEvents() {
        return new String[] {
            "com.saasovation.agilepm.domain.model⏎
.product.ProductCreated",
            "com.saasovation.agilepm.domain.model⏎
.product.ProductDiscussionRequested"
            };
    }
    ...
}
```

第二个监听器关注的是 COLLABORATION_EXCHANGE_NAME，具体用于接收 DiscussionStarted 通知：

```java
package com.saasovation.agilepm.infrastructure.messaging;
...
public class DiscussionStartedListener extends ExchangeListener {
   ...
    @Override
    protected String exchangeName() {
        return Exchanges.COLLABORATION_EXCHANGE_NAME;
    }
    ...
    @Override
    protected String[] listensToEvents() {
        return new String[] {
            "com.saasovation.collaboration.domain.model.⏎
forum.DiscussionStarted"
            };
    }
    ...
}
```

你大概能猜到接下来会发生什么。
如果第一个监听器接收到 ProductCreated 或 ProductDiscussionRequested 中的任意一个事件，它会向`Collaboration Context`分发一条命令，代表 Product 创建一个新的 Forum 和 Discussion 。
当`Collaboration Context`中的组件完成该请求后，会发布 DiscussionStarted 通知；一旦该通知被接收，Product 上对应的讨论标识就会完成初始化。
这就是这个长时运行流程（Long-Running Process）的核心内容。
以下是第一个监听器中 filteredDispatch () 方法的工作原理：

```java
package com.saasovation.agilepm.infrastructure.messaging;
...
public class ProductDiscussionRequestedListener
        extends ExchangeListener {
    private static final String COMMAND =
          "com.saasovation.collaboration.discussion.⏎
CreateExclusiveDiscussion";
    ...
    @Override
    protected void filteredDispatch(
                String aType,
                String aTextMessage) {
        NotificationReader reader =
                new NotificationReader(aTextMessage);

        if (!reader.eventBooleanValue("requestingDiscussion")) {
            return;
        }

        Properties parameters = this.parametersFrom(reader);
        PropertiesSerializer serializer =
                PropertiesSerializer.instance();
        String serialization = serializer.serialize(parameters);
        String commandId = this.commandIdFrom(parameters);
  
        this.messageProducer()
            .send(
                serialization,
                MessageParameters
                    .durableTextParameters(
                            COMMAND,
                            commandId,
                            new Date()))
            .close();
    }
    ...
}
```

无论是 ProductCreated 还是 ProductDiscussionRequested 类型的事件，若其 requestingDiscussion 属性为 false，我们则忽略该事件。
反之，我们会基于事件的状态构建一条 CreateExclusiveDiscussion 命令，并将该命令发送至`Collaboration Context`的消息交换机 (exchange)。

此刻不妨停下来思考一下这个流程的设计思路。
`Agile Project Management Context`真的需要为本地`Aggregate`发布的事件设置监听器吗？
换一种方式，在`Collaboration Context`中为 ProductCreated 事件创建监听器会不会更好？
如果采用这种方式，我们只需让`Collaboration Context`中的监听器负责专属 Forum 和 Discussion 的创建工作，同时还能精简`Agile Project Management Context`中的部分代码。
要判断哪种方案更优，需要考量以下几个因素。

上游`Bounded Context`监听下游上下文发布的事件，这合理吗？
或者，在 [Event-Driven Architecture (4)](../ch4/0.md) 中，系统之间真的存在上下游之分吗？
它们必须被套用这种模式吗？
或许更重要的考量因素是，`Collaboration Context`将 ProductCreated 事件解读为需要创建专属 Forum 和 Discussion，这一做法是否正确。
事实上，ProductCreated 事件对`Collaboration Context`而言，是否真的有任何意义？
考虑到其他上下文各自独特的事件类型，未来可能有多少上下文会希望为这一功能提供类似的自动支持？
将支持任意数量外部事件作为创建命令的负担，放在`Collaboration Context`上，这是最佳方案吗？
不过，还有另一个因素需要考虑，它要求我们更谨慎地管理长时运行流程的成功执行。
这个稍后会稍作讨论的主题，或许能帮助我们理解为何采用这种特定的处理方式。

现在，回到示例……当命令在`Collaboration Context`中被接收后，会被适配并传递给应用服务 ForumService。
请注意，此 API 尚未设计为使用命令参数，而是采用独立的属性参数：

```java
package com.saasovation.collaboration.infrastructure.messaging;
          ...
public class ExclusiveDiscussionCreationListener
        extends ExchangeListener {

    @Autowired
    private ForumService forumService;
    ...
    @Override
    protected void filteredDispatch(
                String aType,
                String aTextMessage) {
        NotificationReader reader =
                new NotificationReader(aTextMessage);

        String tenantId = reader.eventStringValue("tenantId");
        String exclusiveOwnerId =
                reader.eventStringValue("exclusiveOwnerId");
        String forumSubject = reader.eventStringValue("forumTitle");
        String forumDescription =
                reader.eventStringValue("forumDescription");
        String discussionSubject =
                reader.eventStringValue("discussionSubject");
        String creatorId = reader.eventStringValue("creatorId");
        String moderatorId = reader.eventStringValue("moderatorId");
        forumService.startExclusiveForumWithDiscussion(
            tenantId,
            creatorId,
            moderatorId,
            forumSubject,
            forumDescription,
            discussionSubject,
            exclusiveOwnerId);
    }
    ...
}
```

这一点合乎情理，但难道这个 ExclusiveDiscussionCreationListener 不该向`Agile Project Management Context`发送一条响应消息吗？
其实并非如此。
Forum 和 Discussion 这两个`Aggregates`都会在各自创建完成后发布一个事件作为响应，分别是 ForumStarted 和 DiscussionStarted。
该`Bounded Context`会通过其由 COLLABORATION_EXCHANGE_NAME 定义的交换机，发布所有领域事件。
这也是为什么`Agile Project Management Context`中的 DiscussionStartedListener 能够接收到 DiscussionStarted 事件。
以下是该监听器接收到事件后的处理逻辑：

```java
package com.saasovation.agilepm.infrastructure.messaging;
...
public class DiscussionStartedListener extends ExchangeListener {
    @Autowired
    private ProductService productService;
    ...
    @Override
    protected void filteredDispatch(
                String aType,
                String aTextMessage) {
        NotificationReader reader =
                new NotificationReader(aTextMessage);

        String tenantId = reader.eventStringValue("tenant.id");
        String productId = reader.eventStringValue("exclusiveOwner");
        String discussionId =
                reader.eventStringValue("discussionId.id");

        productService.initiateDiscussion(
                new InitiateDiscussionCommand(
                    tenantId,
                    productId,
                    discussionId));
    }
    ...
}
```

该监听器将接收到的通知的事件属性进行适配，作为命令传递给`Application Service` ProductService。
此 initiateDiscussion() 服务方法的工作方式如下：

```java
package com.saasovation.agilepm.application;
...
public class ProductService ... {
    @Autowired
    private ProductRepository productRepository;
    ...
    @Transactional
    public void initiateDiscussion(
                InitiateDiscussionCommand aCommand) {
        Product product =
                productRepository
                    .productOfId(
                            new TenantId(aCommand.getTenantId()),
                            new ProductId(aCommand.getProductId()));
 
        if (product == null) {
            throw new IllegalStateException(
                    "Unknown product of tenant id: "
                    + aCommand.getTenantId()
                    + " and product id: "
                    + aCommand.getProductId());
        }

        product.initiateDiscussion(
                new DiscussionDescriptor(
                        aCommand.getDiscussionId()));
    }
    ...
}
```

最终，Product `Aggregate`的 initiateDiscussion() 行为将被执行：

```java
package com.saasovation.agilepm.domain.model.product;
...
public class Product extends ConcurrencySafeEntity  {
    ...
    public void initiateDiscussion(DiscussionDescriptor aDescriptor) {
        if (aDescriptor == null) {
            throw new IllegalArgumentException(
                    "The descriptor must not be null.");
        }

        if (this.discussion().availability().isRequested()) {
            this.setDiscussion(this.discussion().nowReady(aDescriptor));

            DomainEventPublisher
                .instance()
                .publish(new ProductDiscussionInitiated(
                        this.tenantId(),
                        this.productId(),
                        this.discussion()));
        }
    }
    ...
}
```

如果 Product Discussion 属性仍处于 REQUESTED 状态，它会通过 DiscussionDescriptor 转换为 READY 状态，该描述符持有对`Collaboration Context`中专属 Discussion 的标识引用。
为 Product 创建并关联 Forum 和 Discussion 的请求现已达成一致，尽管这是最终一致性的结果。

不过，如果在调用此命令时 Discussion 已处于 READY 状态，则不会进行进一步的状态转换。
这是一个 bug 吗？不是。
这是确保 initiateDiscussion() 为幂等操作的一种方式。
我们必须假定，如果当前状态为 READY，则长时运行流程已经完成。
后续的任何命令调用可能都是由于通知重发导致的，因为团队选择使用了至少投递一次的消息传递机制。
无论何种情况，我们都无需担心，因为幂等操作允许在必要时无害地忽略任何数量的基础设施和架构层面的影响。
此外，在这个特定场景中，我们无需像为 Member 子类及其 MemberChangeTracker 那样设计 ProductChangeTracker。
Discussion 处于 READY 状态这一简单事实，就足以说明我们需要知道的一切。

不过，这种整体方案可能存在一个问题。
如果长时运行流程因消息传递机制出现某种故障，会发生什么？
我们如何确保流程能够完整执行完毕？
嗯，或许是时候让这个青少年稍微成熟一点了。

### 流程状态机与超时追踪器

我们可以通过添加一个与 [Long-Running Processes (4)](../ch4/0.md) 中所述概念类似的机制，让该流程更加完善。
SaaSOvation 的开发人员创建了一个可复用的概念，命名为 TimeConstrainedProcessTracker 。
追踪器会监控那些已超过规定完成时限的流程，以及在超时前可重试任意次数的流程。
追踪器的设计支持按固定间隔进行重试（如果需要），并且在完全不重试或达到指定重试次数后，最终会彻底超时。

需要明确的是，该追踪器并非`Core Domain`的一部分。
而是技术子域的一部分，可供任何 SaaSOvation 项目复用。
这意味着，在持久化追踪器并对其进行后续修改时，某些情况下我们不必过度遵循`Aggregates`的规则。
追踪器相对独立，且由于与关联流程是一一对应的关系，通常不会遇到并发冲突。
不过，若确实发生冲突，我们可以依靠消息重试机制来解决。
通知投递过程中出现的任何异常都会导致监听器对消息发送否定确认（NAK），进而触发 RabbitMQ 重新投递。
当然，我们并不预期需要大量重试。

Product 本身持有流程的当前状态，在该上下文中，当重试间隔到达，或被监控的流程彻底超时时，追踪器会发布以下事件：

```java
package com.saasovation.agilepm.domain.model.product;
import com.saasovation.common.domain.model.process.ProcessId;
import com.saasovation.common.domain.model.process.ProcessTimedOut;
public class ProductDiscussionRequestTimedOut extends ProcessTimedOut {
    public ProductDiscussionRequestTimedOut(
            String aTenantId,
            ProcessId aProcessId,
            int aTotalRetriesPermitted,
            int aRetryCount) {

        super(aTenantId, aProcessId,
              aTotalRetriesPermitted, aRetryCount);
    }
}
```

当重试间隔到达或完全超时时，追踪器会使用继承自 ProcessTimedOut 的事件。
事件监听器可通过事件方法 hasFullyTimedOut() 判断该事件表示完全超时还是仅为重试。
若允许重试，假设监听器使用 ProcessTimedOut 类，可向事件查询相关标识 (indicators) 与值，例如 allowsRetries()、retryCount()、totalRetriesPermitted() 及 totalRetriesReached()。

借助接收重试与超时通知的能力，我们能让 Product 参与更完善的流程。
首先需要启动流程，这一步可通过现有的 ProductDiscussionRequestedListener 实现：

```java
package com.saasovation.agilepm.infrastructure.messaging;
...
public class ProductDiscussionRequestedListener
        extends ExchangeListener {
    @Override
    protected void filteredDispatch(
                String aType,
                String aTextMessage) {
        NotificationReader reader =
                new NotificationReader(aTextMessage);

        if (!reader.eventBooleanValue("requestingDiscussion")) {
            return;
        }

        String tenantId = reader.eventStringValue("tenantId.id");
        String productId = reader.eventStringValue("product.id");
 
         productService.startDiscussionInitiation(
                new StartDiscussionInitiationCommand(
                        tenantId,
                        productId));

        // send command to Collaboration Context
        ...
    }
    ...
}
```


ProductService 创建并持久化追踪器，并将该流程与指定的 Product 关联起来。

```java
package com.saasovation.agilepm.application;
...
public class ProductService ... {
    ...
    @Transactional
    public void startDiscussionInitiation(
            StartDiscussionInitiationCommand aCommand) {

        Product product =
                productRepository
                    .productOfId(
                            new TenantId(aCommand.getTenantId()),
                            new ProductId(aCommand.getProductId()));
 
        if (product == null) {
            throw new IllegalStateException(
                    "Unknown product of tenant id: "
                    + aCommand.getTenantId()
                    + " and product id: "
                    + aCommand.getProductId());
        }

        String timedOutEventName =
                ProductDiscussionRequestTimedOut.class.getName();

        TimeConstrainedProcessTracker tracker =
                new TimeConstrainedProcessTracker(
                        product.tenantId().id(),
                        ProcessId.newProcessId(),
                        "Create discussion for product: "
                            + product.name(),
                        new Date(),
                        5L * 60L * 1000L, // retries every 5 minutes
                        3, // 3 total retries
                        timedOutEventName);

        processTrackerRepository.add(tracker);

        product.setDiscussionInitiationId(
                tracker.processId().id());
    }
    ...
}
```


TimeConstrainedProcessTracker 被实例化为每五分钟重试三次，在必要时。
诚然，我们通常不会对这些值进行硬编码，但这样做可以让我们清楚地看到追踪器是如何被创建的。

---
➜**你是否发现这里可能存在一个问题？**

如果我们不够谨慎，我们正在使用的重试规则可能会引发问题，但目前我们先保持这个设计不变，就当我们认为它是可行的。

---

正是这种为 Product 代建追踪器的设计思路，最能解释我们为何选择在本地处理 ProductCreated 事件，而非交由`Collaboration Context`来解析该事件。
这种设计让我们的系统能够自主搭建流程管理机制，同时将 ProductCreated 事件与`Collaboration Context`中的 CreateExclusiveDiscussion 命令解耦。

后台会有一个定时任务定期触发，检查各流程的已运行时长。
该定时任务会将检查逻辑委托给 ProcessService 中的 checkForTimedOutProcesses () 方法执行：

```java
package com.saasovation.agilepm.application;
...
public class ProcessService ... {
    ...
    @Transactional
    public void checkForTimedOutProcesses() {
        Collection<TimeConstrainedProcessTracker> trackers =
            processTrackerRepository.allTimedOut();

        for (TimeConstrainedProcessTracker tracker : trackers) {
            tracker.informProcessTimedOut();
        } 
    }
    ...
}
```

正是追踪器的 informProcessTimedOut() 方法会确认流程是否需要重试或彻底超时；一旦确认，该方法就会发布 ProcessTimedOut 的事件子类。
接下来，我们需要新增一个监听器来处理重试与超时逻辑。
按照设计，系统会根据需要每五分钟进行一次重试，最多可重试三次。
这个监听器就是 ProductDiscussionRetryListener：

```java
package com.saasovation.agilepm.infrastructure.messaging;
...
public class ProductDiscussionRetryListener extends ExchangeListener {
    @Autowired
    private ProcessService processService;
    ...
    @Override
    protected String exchangeName() {
        return Exchanges.AGILEPM_EXCHANGE_NAME;
    }
    @Override
    protected void filteredDispatch(
                String aType,
                String aTextMessage) {
        Notification notification =
            NotificationSerializer
                .instance()
                .deserialize(aTextMessage, Notification.class);
        ProductDiscussionRequestTimedOut event =
                notification.event();
        if (event.hasFullyTimedOut()) {
            productService.timeOutProductDiscussionRequest(
                    new TimeOutProductDiscussionRequestCommand(
                            event.tenantId(),
                            event.processId().id(),
                            event.occurredOn()));
        } else {
            productService.retryProductDiscussionRequest(
                    new RetryProductDiscussionRequestCommand(
                            event.tenantId(),
                            event.processId().id()));
    @Override
    protected String[] listensToEvents() {
        return new String[] {
                "com.saasovation.agilepm.process.⏎
ProductDiscussionRequestTimedOut"
                };
    }
}
```

该监听器仅关注 ProductDiscussionRequestTimedOut 事件，其设计支持处理任意组合的重试与超时场景。
流程与追踪器会决定该监听器可能收到通知的次数。
事件的触发分两种情况：要么是流程彻底超时，要么是触发操作重试的通知。
无论哪种情况，该监听器都会将请求转发至新的 ProductService；
若流程已彻底超时，这个`Application Service`会做相应的异常处理：

```java
package com.saasovation.agilepm.application;
...
public class ProductService ... {
    ...
    @Transactional
    public void timeOutProductDiscussionRequest(
            TimeOutProductDiscussionRequestCommand aCommand) {

        ProcessId processId =
                ProcessId.existingProcessId(
                        aCommand.getProcessId());

        TenantId tenantId = new TenantId(aCommand.getTenantId());

        Product product =
                productRepository
                    .productOfDiscussionInitiationId(
                            tenantId,
                            processId.id());

        this.sendEmailForTimedOutProcess(product);

        product.failDiscussionInitiation();
    }
    ...
}
```

首先，系统会向产品负责人发送一封邮件，告知讨论区创建流程已失败，然后将该 Product 标记为讨论初始化失败状态。
从新增的 Product 方法 failDiscussionInitiation() 可以看出，我们需要为 DiscussionAvailability 新增一个 FAILED 状态。
方法 failDiscussionInitiation() 执行必要的简单补偿操作，以确保 Product 处于稳定状态：

```java
package com.saasovation.agilepm.domain.model.product;
...
public class Product extends ConcurrencySafeEntity  {
    ...
    public void failDiscussionInitiation() {
        if (!this.discussion().availability().isReady()) {
            this.setDiscussionInitiationId(null);
            this.setDiscussion(
                    ProductDiscussion
                        .fromAvailability(
                                DiscussionAvailability.FAILED));

        }
    }
    ...
}
```

这里可能缺少的是，由 failDiscussionInitiation() 发布一个新的 DiscussionRequestFailed 事件。
团队需要考虑这样做可能带来的好处。
事实上，发送给产品负责人和其他管理相关人员的邮件，最好是作为该事件的处理结果来完成。
毕竟，如果 ProductService 的 timeOutProductDiscussionRequest() 方法在发送邮件时遇到问题，情况就会变得很麻烦。（啊哈！）
团队已经注意到这一点，并会在稍后回来处理这个问题。

另一方面，如果事件表明应该尝试重试，监听器会将操作委托给 ProductService 中的以下方法：

```java
package com.saasovation.agilepm.application;
...
public class ProductService ... {
    ...
    @Transactional
    public void retryProductDiscussionRequest(
            RetryProductDiscussionRequestCommand aCommand) {

        ProcessId processId =
                ProcessId.existingProcessId(
                        aCommand.getProcessId());

        TenantId tenantId = new TenantId(aCommand.getTenantId());

        Product product =
                productRepository
                    .productOfDiscussionInitiationId(
                            tenantId,
                            processId.id());

        if (product == null) {
            throw new IllegalStateException(
                    "Unknown product of tenant id: "
                    + aCommand.getTenantId()
                    + " and discussion initiation id: "
                    + processId.id());
        }

        this.requestProductDiscussion(
                new RequestProductDiscussionCommand(
                        aCommand.getTenantId(),
                        product.productId().id()));
    }
    ...
 }
```

Product 通过关联的 ProcessId 从其`Repository`中获取，该 ProcessId 已设置在产品的 discussionInitiationId 属性上。
获取 Product 后，ProductService（通过自委托）使用该产品再次请求创建讨论。

最终我们得到了预期的结果。
当讨论成功启动时，`Collaboration Context`会发布 DiscussionStarted 事件。
紧接着，`Agile Project Management Context`中的 DiscussionStartedListener 会像之前一样接收通知并将其转发给 ProductService。
不过这一次，会有新的行为：

```java
package com.saasovation.agilepm.application;
...
public class ProductService ... {
    ...
    @Transactional
    public void initiateDiscussion(
               InitiateDiscussionCommand aCommand) {
        Product product =
                productRepository
                    .productOfId(
                            new TenantId(aCommand.getTenantId()),
                            new ProductId(aCommand.getProductId()));

        if (product == null) {
            throw new IllegalStateException(
                    "Unknown product of tenant id: "
                    + aCommand.getTenantId()
                    + " and product id: "
                    + aCommand.getProductId());
        }

        product.initiateDiscussion(
                new DiscussionDescriptor(
                        aCommand.getDiscussionId()));

        TimeConstrainedProcessTracker tracker =
                this.processTrackerRepository.trackerOfProcessId(
                        ProcessId.existingProcessId(
                                product.discussionInitiationId()));
 
         tracker.completed();
    }
    ...
}
```


ProductService 现在为该流程提供收尾行为，通知追踪器流程它已 completed()。
从此时起，追踪器将不再被选为重试或超时通知器。
流程就此结束。

尽管我们可能对结果感到满意，但这种设计可能存在一点问题。
按照目前的情况，如果我们保持`Collaboration Context`的设计不变，重试创建 Product 讨论区的请求可能会导致一些问题。
根本问题在于，`Collaboration Context`中的操作目前并非幂等。
以下是对这个小设计缺陷的分析以及应采取的改进措施：

- 由于使用了至少一次的保证消息投递机制，一旦消息发送到交换机，它最终必然会送达对应的监听器。
如果在创建新的协作对象时出现延迟，甚至引发一次重试，那么这次重试反过来会导致同一个 CreateExclusiveDiscussion 命令被多次发送。
所有这些命令最终都会被投递。
因此，任何重试都会让`Collaboration Context`多次尝试创建相同的 Forum 和 Discussion。
实际上我们并不会产生重复数据，因为 Forum 和 Discussion 的属性上已经施加了唯一性约束。
所以，多次创建尝试的错误最终是无害的。
但从错误日志的角度看，这些失败的尝试看起来像是由 bug 引起的。
问题是，在我们仍然希望规定完整的流程超时时间的前提下，是否应该禁用周期性重试？

- 虽然看起来解决方案是在`Agile Project Management Context`中禁用重试，但核心在于我们需要让`Collaboration Context`的操作具备幂等性。
要知道，RabbitMQ 保证至少一次投递，因此即便命令消息只发送一次，它也可能被多次投递。
让协作操作具备幂等性，将避免多次尝试创建相同的 Forum 和 Discussion，并抑制无害失败的日志记录。

`Agile Project Management Context`在尝试发送 CreateExclusiveDiscussion 命令时可能会失败。
如果消息发送出现问题，必须谨慎处理，
确保尝试重新发送直至成功。
否则，创建 Forum 和 Discussion 的请求将永远不会被执行。
我们可以通过几种方式确保命令的重新发送尝试。
如果消息发送失败，我们可以从 filteredDispatch() 中抛出异常，这将导致消息否定确认（NAK）。
因此，RabbitMQ 将认为有必要重新投递 ProductCreated 或 ProductDiscussionRequested 事件通知，并且我们的 ProductDiscussionRequestedListener 将再次接收它。
另一种处理方式是简单地重试发送直至成功，或许可以使用有上限的指数退避策略。
在 RabbitMQ 离线的情况下，重试可能会失败相当长一段时间。
因此，结合使用消息否定确认和重试可能是最佳方法。
不过，如果我们的流程每五分钟重试三次，这可能就足够了。
毕竟，流程完全超时后会发送一封邮件，请求人工干预。

最终，如果`Collaboration Context`的 ExclusiveDiscussionCreationListener 能够委托给一个具备幂等性的`Application Service`操作，将能解决我们的诸多问题：

```java
package com.saasovation.collaboration.application;
...
public class ForumService ... {
    ...
    @Transactional
    public Discussion startExclusiveForumWithDiscussion(
            String aTenantId,
            String aCreatorId,
            String aModeratorId,
            String aForumSubject,
            String aForumDescription,
            String aDiscussionSubject,
            String anExclusiveOwner) {

        Tenant tenant = new Tenant(aTenantId);

        Forum forum =
                forumRepository
                    .exclusiveForumOfOwner(
                            tenant,
                            anExclusiveOwner);

        if (forum == null) {
            forum = this.startForum(
                    tenant,
                    aCreatorId,
                    aModeratorId,
                    aForumSubject,
                    aForumDescription,
                    anExclusiveOwner);
        }

        Discussion discussion =
                discussionRepository
                    .exclusiveDiscussionOfOwner(
                            tenant,
                            anExclusiveOwner);

        if (discussion == null) {
            Author author =
                    collaboratorService
                        .authorFrom(
                                tenant,
                                aModeratorId);

            discussion =
                    forum.startDiscussion(
                            forumNavigationService,
                            author,
                            aDiscussionSubject);

            discussionRepository.add(discussion);
        }

        return discussion;
    }
    ...
}
```

通过根据唯一的专属所有者属性查找 Forum 和 Discussion ，我们避免了尝试创建两个可能已存在的`Aggregate`实例。
哇，仅仅几行代码就让我们的事件驱动处理变得如此出色！

### 设计更复杂的流程

不过，我们可能希望设计一个更复杂的流程。
在需要多个完成步骤的情况下，使用更精细的状态机效果最佳。
为满足此类需求，以下是 Process 接口的定义：

```java
package com.saasovation.common.domain.model.process;

import java.util.Date;

public interface Process {

    public enum ProcessCompletionType {
        NotCompleted,
        CompletedNormally,
        TimedOut
    }

    public long allowableDuration();
    public boolean canTimeout();
    public long currentDuration();
    public String description();
    public boolean didProcessingComplete();
    public void informTimeout(Date aTimedOutDate);
    public boolean isCompleted();
    public boolean isTimedOut();
    public boolean notCompleted();
    public ProcessCompletionType processCompletionType();
    public ProcessId processId();
    public Date startTime();
    public TimeConstrainedProcessTracker
               timeConstrainedProcessTracker();
    public Date timedOutDate();
    public long totalAllowableDuration();
    public int totalRetriesPermitted();
}
```

以下是 Process 提供的一些更重要的操作：

- allowableDuration()：若 Process 可超时，返回总时长或重试间隔时长。

- canTimeout()：若 Process 可超时，该方法返回 true。

- timeConstrainedProcessTracker()：若 Process 可超时，返回一个新的唯一限时流程追踪器（TimeConstrainedProcessTracker）。

- totalAllowableDuration()：返回 Process 的总允许时长。
若不允许重试，返回值为 allowableDuration()；
若允许重试，返回值为 allowableDuration() 乘以 totalRetriesPermitted()。

- totalRetriesPermitted()：若 Process 允许超时和重试，该方法返回可尝试的总重试次数。

在我们熟悉的 TimeConstrainedProcessTracker 的控制下，可以对 Process 的实现者进行超时和重试监控。
创建流程后，我们可以向其请求一个唯一的追踪器。
该测试展示了这两个对象如何协同工作，其方式与 Product 和其追踪器的协作方式基本相同：

```java
rocess process =
     new TestableTimeConstrainedProcess(
            TENANT_ID,
            ProcessId.newProcessId(),
            "Testable Time Constrained Process",
            5000L);

TimeConstrainedProcessTracker tracker =
    process.timeConstrainedProcessTracker();

process.confirm1();

assertFalse(process.isCompleted());
assertFalse(process.didProcessingComplete());
assertEquals(process.processCompletionType(),
        ProcessCompletionType.NotCompleted);

process.confirm2();

assertTrue(process.isCompleted());
assertTrue(process.didProcessingComplete());
assertEquals(process.processCompletionType(),
        ProcessCompletionType.CompletedNormally);
assertNull(process.timedOutDate());

tracker.informProcessTimedOut();

assertFalse(process.isTimedOut());
```

本次测试创建的 Process 必须在 5 秒（5000 毫秒）内完成执行且不触发重试，而该 Process 始终能满足这一要求。
只有当 confirm1 () 和 confirm2 () 方法均被调用后，此 Process 才会被标记为执行完成，代表整个处理流程完全结束。
该 Process 内部已预设规则：必须完成两个状态的确认操作。

```java
public class TestableTimeConstrainedProcess extends AbstractProcess {
    ...
    public void confirm1() {
        this.confirm1 = true;
        this.completeProcess(ProcessCompletionType.CompletedNormally);
    }
    public void confirm2() {
        this.confirm2 = true;

        this.completeProcess(ProcessCompletionType.CompletedNormally);
    }
    ...
    protected boolean completenessVerified() {
        return this.confirm1 && this.confirm2;
    }

    protected void completeProcess(
            ProcessCompletionType aProcessCompletionType) {

        if (!this.isCompleted() && this.completenessVerified()) {
            this.setProcessCompletionType(aProcessCompletionType);
        }
    }
    ...
}
```

即便该 Process 自行调用了 completeProcess () 方法，也必须等到 completenessVerified () 方法返回 true 后，流程才能被标记为完成。
只有当 confirm1 和 confirm2 的状态均被设为 true 时，这个方法才会返回 true。
换言之，confirm1 () 和 confirm2 () 两个操作都必须执行完毕。
因此，completenessVerified () 方法的设计，支持在整个 Process 被判定为完成前，先对多个处理步骤的完成状态逐一确认；
而每一种特定的 Process 实现，都可以自定义自身的 completenessVerified () 方法判定逻辑。

那么，当执行到该测试的最后一步时，会发生什么呢？

```java
...

tracker.informProcessTimedOut();

assertFalse(process.isTimedOut());
```

追踪器会依据自身的内部状态判断出，该 Process 实际上并未发生超时。
因此，下一行代码中的断言结果永远为 false。
（当然，这里假设整个测试会在五秒内执行完毕，而且我们有充分的理由相信，在正常的测试环境下，该测试始终能满足这一条件。）

基类 AbstractProcess 实现了 Process 接口，同时承担适配器的角色，为开发更复杂的长时运行流程提供了一套极为便捷的实现方式。
由于 AbstractProcess 继承自基类`Entity`，我们可以轻松将`Aggregate`设计为一个 Process。
例如，我们可以让 Product 类继承 AbstractProcess 作为其子类，尽管目前产品模块并不需要如此复杂的设计。
但我们完全可以预见，借助这种设计思路，能够适配更复杂的业务流程，同时通过实现 completenessVerified () 方法，来校验所有必要的步骤是否均已执行完成

### 当消息系统或你的系统不可用时

没有任何一种开发复杂软件系统的方法是万能的。
任何方法都存在问题和缺陷，其中一些我们已经讨论过。
消息系统的一个问题是它可能在一段时间内不可用。
这种情况可能不常发生，但一旦发生，有几件事需要牢记。

当消息机制离线一段时间时，通知发布者将无法通过它发送消息。
由于发布客户端可能会检测到这种情况，最好的做法是退避 (back off) 重试发送通知，直到消息系统再次可用。
当任意一次发送成功时，就说明系统恢复了。
但在此之前，要确保发送尝试的频率低于系统正常运行时。
重试间隔退避至 30 秒甚至 1 分钟是合理的。
请记住，如果你的系统有`Event Store`，事件会继续在运行系统中排队，一旦消息系统恢复，就可以立即发送。

如果消息基础设施在一段时间内不可用，监听器自然无法接收新的携带事件的通知。
当消息机制恢复可用后，你的客户端监听器会自动重新激活，还是需要重新订阅消费端客户端机制？
如果不支持消费者自动恢复，你就必须确保消费者被重新注册。
否则，你最终会发现一个不希望出现的情况：你的`Bounded Context`无法接收维持其与所依赖`Bounded Contexts`交互所需的通知。
这是一种你需要避免的最终一致性问题。

并非所有基于消息的问题都源于消息机制本身。
设想这样一种场景：你的`Bounded Context`在很长一段时间内不可用。
当它再次恢复时，其所订阅的持久化消息交换机/队列中已经堆积了大量未投递的消息。
一旦你的`Bounded Context`重新启动并注册其消费者，接收并处理所有可用通知可能需要相当长的时间。
对于这种情况，除了坚持不懈地追求更短的停机时间目标、开发热部署方案，以及通过设计冗余节点（集群）来避免因单个节点故障导致系统不可用之外，你可能别无他法。
尽管如此，有时你仍无法避免一定程度的停机。
例如，如果应用代码的变更需要同步修改数据库，而你无法在不引发问题的情况下进行热补丁更新，那么你就需要安排系统停机。
在这种情况下，你的消息消费处理可能只能进行追赶式消费。
显然，这是一种我们需要意识到的情况，并计划在可能成为问题时进行规避或处理。

<center><img src="../img/ownit.png" align="center" width="30%" /></center>

#### ▶[下一节](4.md)

---

#### 1
这可能是一个使用 RESTful 方式消费通知具有明显优势的场景，因为通知能保证按照其追加到 [Event Store (4)](../ch4/0.md) [附录 A](../appendix.md) 的相同顺序投递。
通知从第一条到最后一条，可因不同原因被反复消费，且每次都能保证顺序一致。
