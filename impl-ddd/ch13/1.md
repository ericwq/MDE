## 集成基础

#### ▶[上一节](0.md)

当两个`Bounded Contexts`需要进行集成时，在代码层面有几种相当直接的实现方式。

其中一种直接的方式是：一个`Bounded Context`对外暴露应用程序编程接口（API），另一个`Bounded Context`通过远程过程调用（RPC）来使用该 API。
该 API 可以基于 SOAP 实现，也可以仅支持通过 HTTP 发送 XML 请求和响应（这与 REST 不同）。
实际上，创建可远程访问的 API 有多种方式。
这是一种较为流行的集成方式，并且由于它支持过程调用风格，对于习惯调用过程或方法的程序员来说很容易理解。
我们几乎所有人都属于这类程序员。

将`Bounded Contexts`整合的第二种直接方法是通过使用消息机制。
每个需要交互的系统都通过消息队列或`Publish-Subscribe` [[Gamma et al.](../bibli.md#gamma-et-al)] 机制进行通信。
当然，这些消息网关完全可以被视为 API，但如果我们简单地将它们称为服务接口，可能会更容易被广泛接受。
在使用消息机制时，可以采用大量的集成技术，其中许多在 [[Hohpe & Woolf](../bibli.md#hohpe--woolf)] 中有讨论。

第三种集成`Bounded Contexts`的方式是使用 RESTful HTTP。
<ins>有人将其视为一种 RPC 方式，但实际上并非如此</ins>。
它与 RPC 有一些相似的特性，即一个系统向另一个系统发出请求，但这些请求并非通过带参数的过程来实现。
<ins>正如在 [Architecture (4)](../ch4/0.md) 中所讨论的，REST 是一种交换和修改资源的方式，这些资源通过唯一的 URI 进行标识。
可以对每个资源执行各种操作</ins>。
RESTful HTTP 提供了多种方法，主要包括 GET、PUT、POST 和 DELETE。
尽管这些方法看似仅支持 CRUD 操作，但稍加思考，我们就可以将具有明确意图的操作归类到这四种方法中的某一种。
例如，GET 可用于归类各类查询操作，PUT 可用于封装在 [Aggregate (10)](../ch10/0.md) 上执行的命令操作。

当然，这绝不意味着集成应用只有这三种方式。
例如，你可以使用基于文件的集成和共享数据库集成，但这样做可能会让你提前衰老。

|牛仔逻辑||
|:---|---:|
|AJ：“你最好在马鞍上坐低点。那匹马性子烈，会让你提前觉得自己老了。”|<img src="../img/cbl.2.png" width="50%"/>|

虽然我已经重点介绍了三种用于集成`Bounded Contexts`的常用方式，但在本章中我们将只专注于其中两种。
我们将主要聚焦于通过消息机制进行集成，同时也会介绍如何使用 RESTful HTTP。
我们将避免使用 RPC 的示例，因为你可以很容易地想象出创建过程式 API 来替代另外两种方式的场景。
此外，当我们的目标是支持自治服务（也称为自治应用）时，RPC 的弹性较差。
一个通常提供基于 RPC 的 API 的系统一旦发生故障，将会导致依赖它的系统无法正常完成自身的操作。

这就引出了一个至关重要的话题，需要每一位集成开发人员予以重视。

### 分布式系统从根本上就截然不同

当不熟悉分布式系统原理的开发者忽略其固有的复杂性时，集成过程中总会出现问题。
在使用 RPC 时尤其如此，因为那些缺乏分布式经验的人通常会认为，任何一次远程调用都和进程内调用一样可靠。
当某个系统或其组件变得不可用时（哪怕只是暂时不可用），这种假设会导致任意数量的系统发生级联故障。
因此，所有在分布式系统中工作的开发者，其成败都取决于以下分布式计算原则 (Principles of Distributed Computing)：

- 网络并不可靠。
- 总会存在延迟，有时延迟还会很大。
- 带宽并非无限。
- 不要假设网络是安全的。
- 网络拓扑会发生变化。
- 知识和策略分散在多个管理员手中。
- 网络传输存在成本。
- 网络是异构的。

这些原则的表述方式与 “分布式计算的谬误 (Fallacies of Distributed Computing)” [[Deutsch](../bibli.md#deutsch)] 刻意有所不同。
我将它们称为 *原则* ，是为了强调那些必须设法规避的挑战和必须提前规划的复杂性，而不是那些新手常犯的错误。

### 跨系统边界交换信息

大多数情况下，当我们需要外部系统为自身系统提供服务时，需要向该服务传递信息数据。
我们使用的服务有时需要提供响应。
因此，我们需要一种可靠的方式在系统之间传递信息数据。
这些数据需要以所有相关方都能轻松使用的结构在不同系统间交换。
我们大多数人会选择使用某种标准方式来实现这一点。

作为参数或消息发送的信息数据仅构成机器可读的结构，可以多种格式生成。
我们还必须在数据交换系统之间创建某种形式的契约，甚至可能包括解析或解释这些结构的机制，以便它们能够被使用。

有多种方式可以生成用于在系统间交换信息的结构。
<ins>一种技术实现仅依赖编程语言工具，将对象序列化为二进制格式，并在消费端进行反序列化。</ins>
只要所有系统都支持相同的语言工具，且序列化在不同硬件架构之间实际兼容或可互换，这种方式就能很好地工作。
它还要求你将跨系统使用的所有对象接口和类部署到每个使用特定对象类型的系统中。

<ins>另一种构建可交换信息结构的方法是使用某种标准中间格式。
一些选择包括使用 XML、JSON 或诸如 Protocol Buffers 之类的专用格式。</ins>
每种方法都有其优缺点，其中一些包括丰富性和紧凑性因素、类型转换的性能、对对象版本间灵活性的支持以及易用性。
考虑到前面列出的分布式计算原则（例如，“网络传输存在成本”），其中一些方法可能会产生高昂的影响。

使用这种中间格式的方法，你可能仍然希望部署所有跨系统使用的对象接口和类，并使用工具将中间格式的数据填充到你的类型安全对象中。
这样做的好处是，你可以在消费系统中以与源系统相同的方式使用这些对象。

当然，部署这些接口和类也会带来相关的复杂性，这通常意味着消费系统需要重新编译，以保持与最新版本接口和类定义的兼容性。
还存在一种风险，即在消费系统中随意使用外部对象，就像它们是我们自己的一样，这往往会违反我们一直努力遵循的 DDD 战略设计原则。
有些人可能会认为，将其声明为 [Shared Kernel (3)](../ch3/0.md) 就能为这种做法提供保障。
然而，要注意的是，系统间共享对象所带来的便利，可能会让你陷入一个危险的境地。
不过，尽管存在模型被污染的复杂性和潜在风险，许多人仍然认为，通过这种策略获得的强类型特性，是应对所需复杂性的一种合适的权衡。

尽管如此，我仍遇到一些人因各种原因对此感到困扰，他们往往希望有一种更简单、更安全的方法，同时又不完全舍弃类型安全。
让我们来思考这样一种方法。

<ins>如果我们能在生成可交换信息结构的系统与使用这些结构的系统之间定义一种契约，使得使用者可以放心地使用这些数据，而无需将其反序列化为特定类的对象实例，那会怎样？
我们可以使用一种基于标准的方法来定义这样一种可靠的契约，这实际上构成了一种 [Published Language (3)](../ch3/0.md) 。
其中一种标准方法是定义一种自定义媒体类型，或语义上等价的类型。</ins>
无论你是否有充分的理由按照 RFC 4288 的指导原则注册这样的媒体类型，真正重要的是实际的规范。
该规范定义了生产者与消费者之间的绑定契约，并提供了一种万无一失的方式来交换此类媒体，而无需共享接口和类的二进制文件。

这当然也需要像往常一样做出一些权衡。
你将无法像拥有每个对象的接口/类及其相关类型安全那样，通过属性访问器来导航数据。
同时，你也会失去一些 IDE 支持，例如代码补全功能。
但这其实算不上什么大的缺点。
此外，你也无法获得事件类所能提供的操作函数/方法支持。
不过，我并不认为缺少事件操作函数/方法是一个缺点，相反，这是一种保护。
消费方`Bounded Context`只应关注数据属性，绝不应被诱惑去使用属于另一个模型的功能。
消费方的 [Port Adapters (4)](../ch4/0.md) 应保护其领域模型免受任何此类依赖的影响，而必须将所需的事件数据作为仅在其自身`Bounded Context`中定义的类型的适当参数进行传递。
任何必要的计算或处理都应由生产方`Bounded Context`执行，并作为丰富的事件数据属性提供。

举个例子。SaaSOvation 需要在其各个`Bounded Contexts`之间交换媒体类型。
它将通过 RESTful 资源以及在服务间发送包含 [Events (8)](../ch8/0.md) 的消息来实现。
事实上，一种 RESTful 资源就是 notification，而基于事件的消息也会作为 Notification 对象发送给订阅者。
换句话说，在这两种情况下，Notification 中都包含一个事件，并且二者被格式化为单一结构。
针对通知和事件的自定义媒体类型规范可以定义一份包含以下内容的契约：

- Type：Notification 格式：JSON
- notificationId：长整型唯一标识
- typeName：文本字符串类型的通知类型，示例类型名为 com.saasovation.agilepm.domain.model.product.backlogItem.BacklogItemCommitted
- version：通知的整数版本号
- occurredOn：通知所包含事件发生的日期/时间
- event：JSON 负载详情；参见具体的事件类型

在 typeName 中使用全限定类名（包含包名）可以让订阅者精确区分不同的 Notification 类型。
通知规范之后会跟随各种事件类型的规范。
举个例子，来看一个我们熟悉的名为 BacklogItemCommitted 的事件：

- Event Type：com.saasovation.agilepm.domain.model.product.backlogItem.BacklogItemCommitted
- eventVersion：事件的整数版本号，与 Notification 版本号相同
- occurredOn：事件发生的日期/时间，与 Notification occurredOn 相同
- backlogItemId：BacklogItemId，包含 id 文本字符串属性
- committedToSprintId：SprintId，包含 id 文本字符串属性
- tenantId：TenantId，包含 id 文本字符串属性
- 事件详情：参见具体事件类型

当然，我们会为每种事件类型指定事件详情。
在定义好 Notification 和所有事件类型后，我们就可以安全地使用 NotificationReader，如本测试所示：

```java
DomainEvent domainEvent = new TestableDomainEvent(100, "testing");

Notification notification = new Notification(1, domainEvent);

NotificationSerializer serializer =
     NotificationSerializer.instance();
 
String serializedNotification = serializer.serialize(notification);

NotificationReader reader =
     new NotificationReader(serializedNotification);

assertEquals(1L, reader.notificationId());
assertEquals("1", reader.notificationIdAsString());
assertEquals(domainEvent.occurredOn(), reader.occurredOn());
assertEquals(notification.typeName(), reader.typeName());
assertEquals(notification.version(), reader.version());
assertEquals(domainEvent.eventVersion(), reader.version());
```

该测试展示了 NotificationReader 如何为每个序列化的 Notification 对象提供类型安全的标准部分。

下一个测试展示了如何从 Notification 负载中读取每个事件详情的特定部分。
事件对象导航可使用类似 XPath 的语法、点分隔属性，或逗号分隔的属性名（Java 可变参数）实现。
你可以看到，每个属性都能以 String 值读取，若非 String 类型，也能以其实际基本类型（int、long、boolean、double 等）读取。

```java
TestableNavigableDomainEvent domainEvent =
    new TestableNavigableDomainEvent(100, "testing");

Notification notification = new Notification(1, domainEvent);

NotificationSerializer serializer = NotificationSerializer.instance();

String serializedNotification = serializer.serialize(notification);

NotificationReader reader =
     new NotificationReader(serializedNotification);

assertEquals("" + domainEvent.eventVersion(),
    reader.eventStringValue("eventVersion"));
assertEquals("" + domainEvent.eventVersion(),
    reader.eventStringValue("/eventVersion"));
assertEquals(domainEvent.eventVersion(),
    reader.eventIntegerValue("eventVersion").intValue());
assertEquals(domainEvent.eventVersion(),
    reader.eventIntegerValue("/eventVersion").intValue());

assertEquals("" + domainEvent.nestedEvent().eventVersion(),
    reader.eventStringValue("nestedEvent", "eventVersion"));
assertEquals("" + domainEvent.nestedEvent().eventVersion(),
    reader.eventStringValue("/nestedEvent/eventVersion"));
assertEquals(domainEvent.nestedEvent().eventVersion(),
    reader.eventIntegerValue("nestedEvent", "eventVersion").intValue());
assertEquals(domainEvent.nestedEvent().eventVersion(),
    reader.eventIntegerValue("/nestedEvent/eventVersion").intValue());

assertEquals("" + domainEvent.nestedEvent().id(),
    reader.eventStringValue("nestedEvent", "id"));
assertEquals("" + domainEvent.nestedEvent().id(),
    reader.eventStringValue("/nestedEvent/id"));
assertEquals(domainEvent.nestedEvent().id(),
    reader.eventLongValue("nestedEvent", "id").longValue());
assertEquals(domainEvent.nestedEvent().id(),
    reader.eventLongValue("/nestedEvent/id").longValue());

assertEquals("" + domainEvent.nestedEvent().name(),
    reader.eventStringValue("nestedEvent", "name"));
assertEquals("" + domainEvent.nestedEvent().name(),
    reader.eventStringValue("/nestedEvent/name"));

assertEquals("" + domainEvent.nestedEvent().occurredOn().getTime(),
    reader.eventStringValue("nestedEvent", "occurredOn"));
assertEquals("" + domainEvent.nestedEvent().occurredOn().getTime(),
    reader.eventStringValue("/nestedEvent/occurredOn"));
assertEquals(domainEvent.nestedEvent().occurredOn(),
    reader.eventDateValue("nestedEvent", "occurredOn"));
assertEquals(domainEvent.nestedEvent().occurredOn(),
    reader.eventDateValue("/nestedEvent/occurredOn"));

assertEquals("" + domainEvent.occurredOn().getTime(),
    reader.eventStringValue("occurredOn"));
assertEquals("" + domainEvent.occurredOn().getTime(),
    reader.eventStringValue("/occurredOn"));

assertEquals(domainEvent.occurredOn(),
    reader.eventDateValue("occurredOn"));
assertEquals(domainEvent.occurredOn(),
    reader.eventDateValue("/occurredOn"));
```

TestableNavigableDomainEvent 持有一个 TestableDomainEvent，这使我们能够测试对更深层属性的导航。
各类属性通过类似 XPath 的语法结合可变参数属性导航来读取。
我们还测试了以不同类型读取每个属性值。

由于 Notification 和事件实例始终带有版本号，你可以依据版本号读取特定版本中的专属属性。
专注于某个版本的消费者可以提取出所需的特定部分。
不过，消费者也可以将任何包含事件的 Notification 当作版本 1 来接收。

因此，倘若我们仔细考量每种事件类型的设计方式，就能保证大多数消费者在仅需某一事件的版本 1 时，不会受到兼容性问题的影响。
当事件发生变更时，这类消费者完全无需进行修改或重新编译。
不过，你确实必须从版本兼容性的角度进行思考，并且为新版本的灵活修改做好规划，以免影响大多数消费者的正常使用。
虽然有时这一点难以实现，但在很多情况下，它是完全可以做到的。

这种方法还有一个额外的优势：事件不仅可以存储基本属性和字符串。
还能安全地存储更复杂的 [Value Objects (6)](../ch6/0.md) 实例，尤其是当这些`Value`的类型趋于稳定时，这种方式的效果会格外显著。
BacklogItemId、SprintId 和 TenantId 无疑就是这样的例子，如下代码所示（本次使用点分隔的属性导航方式）：

```java
NotificationReader reader =
      new NotificationReader(backlogItemCommittedNotification);

String backlogItemId = reader.eventStringValue("backlogItemId.id"));

String sprintId = reader.eventStringValue("sprintId.id"));

String tenantId = reader.eventStringValue("tenantId.id"));
```

结构中所包含的`Value`实例是固定不变的，这一事实使得事件不仅是不可变的，而且是永久固定的。
事件所包含的`Value Object`类型的新版本，不会影响你从已存在的 Notification 实例中读取这些`Values`旧版本的能力。
当然，当事件版本频繁且大幅变更时，Protocol Buffers 的使用会简便得多，而对于使用 NotificationReader 的消费者而言，处理这些变更会变得十分棘手。

要明白，这只是一种无需在各处部署事件类型及其依赖项，就能优雅地处理反序列化的方案。
有些人会觉得这种方法相当优雅且解放思想，而另一些人则会认为它存在风险、笨拙，甚至极其危险。
与之相反，在序列化对象被消费的所有地方，都部署接口和类的方法是众所周知的。
在这里，我指出了一条少有人走的路，希望能提供一些思考。

|牛仔逻辑||
|:---|---:|
|LB：“你知道吗，J，当一个牛仔老到没法再树立坏榜样时，他就会给出好建议。”|<img src="../img/cbl.2.png" width="50%"/>|

每种方法 ——部署类以交换序列化对象，还是定义媒体类型契约—— 在项目的不同阶段都可能各有优势。
例如，根据团队数量、`Bounded Contexts`、变更频率及其他因素，在项目启动阶段共享类和接口或许可行，但在生产阶段使用更解耦的自定义媒体类型契约可能效果更好。
在实践中，这对某个或某些团队而言可能适用，也可能不适用。
有时团队最初采用的方案最终会成为他们一直沿用的方案，他们从未花时间做出彻底的改变。

为了让我们的示例保持简洁易懂，在本章剩余部分中，我将全程使用 NotificationReader。
是否在你的`Bounded Contexts`中使用自定义媒体类型契约和 NotificationReader，由你自行决定。

#### ▶[下一节](2.md)
