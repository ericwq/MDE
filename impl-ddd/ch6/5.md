## 实现

#### ▶[上一节](4.md)

我很喜欢这个 BusinessPriority 示例，因为它完整展现了`Value`的所有核心特征，甚至还体现了更多延伸用法。除了演示如何设计出具备不可变性、概念完整性、可替换性、值相等性和无副作用行为的对象外，它还展示了如何将`Value`类型用作`Strategy`模式 [[Gamma et al.](../bibli.md#gamma-et-al)]（也称作`Policy`模式）。

---
| ||
|---|---|
|随着每个测试方法的开发，团队愈发清楚客户端会如何使用 BusinessPriority 对象，这也让他们能够按照测试断言的预期行为来实现这个类。以下是团队编写的基础类定义，以及对应的构造函数代码：|![](../img/ovation.2.png)|

```java
public final class BusinessPriority implements Serializable  {

    private static final long serialVersionUID = 1L;

    private BusinessPriorityRatings ratings;

    public BusinessPriority(BusinessPriorityRatings aRatings) {
        super();
        this.setRatings(aRatings);
    }

    public BusinessPriority(BusinessPriority aBusinessPriority) {
        this(aBusinessPriority.ratings());
    }
```

团队决定将其`Value`类型声明为 Serializable 。在某些情况下，`Value`的实例需要被序列化，例如当它要与远程系统通信时，这在某些持久化策略中也可能很有用。

BusinessPriority 本身被设计为包含一个名为 ratings 的`Value` property，其类型为 BusinessPriorityRatings（此处未显示）。ratings property 描述了实现或不实现某个产品待办项时在业务价值与成本之间的权衡。BusinessPriorityRatings 类型为 BusinessPriority 提供了收益、成本、损失和风险等评级，从而支持进行一系列计算。

---

<ins>通常，我会为每个`Value Objects`至少支持两个构造函数。第一个构造函数接收完整的参数集，这些参数是推导和/或设置状态属性所必需的。这个主构造函数首先初始化其默认状态。基本属性的初始化是通过调用私有 setter 来完成的</ins>。我建议使用自委托（self‑delegation），并在此处通过私有 setter 来展示它的用法。

---
➜**保持`Values`不可变**

只有主构造函数会使用自委托（self‑delegation）来设置属性/特征。其他任何方法都不允许通过自委托调用 setter 方法。由于`Value Object`中的所有 setter 方法始终是 private 的，因此外部使用者没有机会修改其属性。这两点是维持`Values`不可变性的重要因素。

---

<ins>第二个构造函数用于复制一个已有的`Value`以创建新的实例，也就是所谓的 *复制构造函数* 。该构造函数执行的是 *浅复制（shallow copy）* ，因为它通过自委托调用其主构造函数，并将被复制`Value`的各个对应属性作为参数传递进去</ins>。我们也可以执行 *深复制（deep copy）* 或 *克隆* ，即对所有包含的属性和 properties 进行复制，以生成一个完全独立的对象，但在值层面上仍与原对象相等。然而，在处理`Values`时，深复制往往既复杂又没有必要。如果确实需要深复制，也可以再添加。但在处理不可变`Values`时，多个实例之间共享属性从来都不是问题。

第二个构造函数，即复制构造函数，在单元测试中非常重要。当我们测试一个`Value Object`时，需要验证它是否是不可变的。如前所述，在单元测试开始时，先创建一个新的测试`Value Object`实例，并使用复制构造函数创建它的副本，然后断言这两个实例相等。接下来，测试该`Value`实例的无副作用行为。如果所有测试目标的断言都通过，那么最后一个断言就是：被测试的实例与复制的实例仍然相等。

接下来，我们实现`Value`类型的`Strategy/Policy`部分：

```java
    public float costPercentage(BusinessPriorityTotals aTotals) {
        return (float) 100 * this.ratings().cost() /
            aTotals.totalCost();
    }

    public float priority(BusinessPriorityTotals aTotals) {
        return
            this.valuePercentage(aTotals) /
                (this.costPercentage(aTotals) +
                    this.riskPercentage(aTotals));
    }

    public float riskPercentage(BusinessPriorityTotals aTotals) {
        return (float) 100 * this.ratings().risk() /
            aTotals.totalRisk();
    }

    public float totalValue() {
        return this.ratings().benefit() + this.ratings().penalty();
    }

    public float valuePercentage(BusinessPriorityTotals aTotals) {
        return (float) 100 * this.totalValue() / aTotals.totalValue();
    }

    public BusinessPriorityRatings ratings() {
        return this.ratings;
    }
```

某些计算行为需要一个类型为 BusinessPriorityTotals 的参数。这个`Value`提供了所有产品待办项在成本和风险方面的总计信息。在计算百分比以及与其他所有待办项相比的整体业务优先级时，这些总计是必需的。这些行为都不会修改其自身的实例状态。在测试中，我们会在执行每个行为后，将复制的状态与当前状态进行比较，从而在外部断言这一点。

目前，该`Strategy`并没有`Separated Interface` [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] ，因为目前只有一个实现。毫无疑问，随着时间的推移，情况将会改变，Agile PM SaaS 产品的客户将获得其他业务优先级计算选项，每个选项都有自己的`Strategy`实现。

无副作用函数（Side-Effect-Free Functions）的方法名称非常重要。虽然这些方法都返回`Values`（因为它们是遵循 CQS 的查询方法），但它们有意避免使用带 get- 前缀的 JavaBean 命名约定。这种简单但有效的对象设计方法使`Value Object`更忠实于`Ubiquitous Language`。使用 getValuePercentage() 是一种技术性的计算机语句，而 valuePercentage() 则是一种流畅、人类可读的语言表达。

---
### 我的流畅 Java 去哪儿了？

我认为 JavaBean 规范对对象设计产生了负面影响，它总体上并不促进 DDD 的原则，也不利于良好的对象设计。想想在 JavaBean 规范出现之前就存在的 Java API。以 java.lang.String 为例，String 类中只有少数查询方法以 get 为前缀。大多数查询方法的命名更加流畅，例如 charAt ()、compareTo ()、concat ()、contains ()、endsWith ()、indexOf ()、length ()、replace ()、startsWith ()、substring () 等等。那里完全没有 JavaBean 的代码坏味道！当然，仅凭这个例子并不能完全证明我的观点。尽管如此，自 JavaBean 规范出现以来，Java API 确实受到了极大影响，并且在表达上缺乏流畅性。流畅、人类可读的语言表达是一种非常值得采用的风格。

如果你担心某些工具依赖 JavaBean 规范，其实是有解决方案的。例如，Hibernate 提供了对字段级访问（object attributes）的支持。因此，就 Hibernate 而言，你可以按需要命名你的方法，而不会对持久化造成负面影响。

然而，在使用其他工具时，采用富有表达力的接口设计可能会有一些缺点。例如，如果你希望使用标准的 Java EL 或 OGNL，你将无法直接渲染此类类型。你必须使用其他方式，例如带有 getter 的`Data Transfer Object` [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] ，来将`Value Object`的 properties 传输到用户界面。尽管 DTO 通常在技术上并非必要，但它是一个常用模式，因此有些人可能认为这没什么大不了的。如果 DTO 不适合你，还有其他选择。例如，可以考虑 [Application (14)](../ch14/0.md) 中讨论的`Presentation Model``。由于你的`Presentation Model`可以充当`Adapter` [[Gamma et al.](../bibli.md#gamma-et-al)] ，它可以为使用 EL 的视图提供 getter 方法。当然，如果所有方法都不可行，你可能不得不勉强为领域对象设计 getter。

如果你得出了这样的结论，你仍然不应该为`Value Objects`设计完整的 JavaBean 功能，例如允许通过公共的 setter 方法来初始化它们的状态。这会破坏`Value`至关重要的不可变性特征。

---

下一组方法包括标准的对象覆盖方法：equals()、hashCode() 和 toString()：

```java
    @Override
    public boolean equals(Object anObject) {
        boolean equalObjects = false;
        if (anObject != null &&
                this.getClass() == anObject.getClass()) {
            BusinessPriority typedObject = (BusinessPriority) anObject;
            equalObjects =
                this.ratings().equals(typedObject.ratings());
        }
        return equalObjects;
    }

    @Override
    public int hashCode() {
        int hashCodeValue =
            + (169065 * 179)
            + this.ratings().hashCode();
        return hashCodeValue;
    }

    @Override
    public String toString() {
        return
            "BusinessPriority"
            + " ratings = " + this.ratings();
    }
```

equals () 方法满足`Value Object`检查`Value`相等性的要求，这是`Value`对象的五个特性之一。在这里，我们总是排除 null 参数的相等性比较。参数的类必须与该`Value`的类相同。如果它们相同，则会比较两个`Values`中的每个 properties/attributes。如果每个 property/attribute 都被确认与其对应的属性相等，那么这两个`Whole Values`就被认为是相等的。

按照 Java 标准，hashCode() 与 equals() 遵循相同的契约：所有相等的`Values`也必须产生相等的哈希码值。

toString() 没有什么特别之处，它只是创建`Value`实例状态的人类可读表示形式。你可以根据需要设计其输出格式。

还有几个剩余方法需要说明：

```java
    protected BusinessPriority() {
        super();
    }

    private void setRatings(BusinessPriorityRatings aRatings) {
        if (aRatings == null) {
            throw new IllegalArgumentException(
                    "The ratings are required.");
        }
        this.ratings = aRatings;
    }
}
```

提供无参构造函数是为了满足某些框架工具的要求，例如 Hibernate。由于无参构造函数始终是隐藏的（非公有），因此模型的客户端不会有机会创建无效的实例。Hibernate 完全可以在隐藏构造函数和访问器的情况下正常工作。这个构造函数使 Hibernate 和其他工具能够在从持久化存储等地方重建对象时创建该类型的实例。工具会使用无参构造函数创建一个初始为空的实例，然后调用每个属性的 setter 方法来合成 (hydrate) 对象。你也可以选择让 Hibernate 绕过 setter 方法，直接设置属性，就像本模型中这样，因为它并没有提供完整的 JavaBean 接口。需要再次强调的是，模型的客户端应使用公共构造函数，而绝不能使用这个隐藏的构造函数。

最后，类定义以 ratings 属性的 setter 方法结束。自封装/自委托（self‑encapsulation/delegation）的一个优势就体现在这个方法中。访问器方法 ——无论是 getter 还是 setter—— 并不局限于设置实例字段。它还可以执行重要的`Assertions` [[Evans](../bibli.md#evans)] ，这是总体软件开发、特别是 DDD 模型成功的关键要素。

对有效参数的`Assertion`被称为 *guard* ，因为它可以防止方法接收明显无效的数据。当错误的参数如果被当成正确值处理，会在后续造成更严重的问题时，任何方法都可以而且应该使用 guards 。这里的 setter 断言参数 aRatings 不为 null，如果它恰好为 null，则抛出 IllegalArgumentException。诚然，在`Value`的生命周期中，这个 setter 在逻辑上只会被调用一次。尽管如此，这个`Assertion`仍然是一个放置得当的 guard。你也会在其他地方看到自委托（self‑delegation）带来的好处。特别是在 [Entities (5)](../ch5/0.md) 中，会在讨论 [验证](../ch5/3.md#验证validation) 的部分对这项技术进行全面解释。



#### ▶[下一节](6.md)
