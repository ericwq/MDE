## 持久化`Value Objects`

#### ▶[上一节](5.md)

将`Value Object`实例持久化到持久化存储中有多种方式。一般来说，这涉及将对象序列化为某种文本或二进制格式并保存到磁盘。然而，由于我们并不关心单独持久化各个`Value`实例，因此我不会专注于通用的持久化方式。相反，我们更关心的是在持久化包含`Values`的`Aggregate`实例状态时，一并持久化这些`Values`。以下方法都假设最终是由一个父`Entity`持有对这些将被持久化的`Value`实例的引用。以下所有示例都基于这样的假设：当一个`Aggregate`被添加到其 [Repository (12)](../ch12/0.md) 或从`Repository`中读取时，其包含的`Values`会在幕后与包含它们的`Entity`（例如`Aggregate Root`）一起被持久化和重建。

对象关系映射（ORM，例如 Hibernate）持久化方式非常流行且被广泛使用。然而，使用 ORM 将每个类映射到一张表、每个属性映射到一列会增加复杂性，而这种复杂性有时是不必要的。近年来，NoSQL 数据库和键值 (key-value) 存储的使用越来越普及，因为它们能够提供高性能、可扩展、容错且高可用的企业级存储。此外，键值存储还能极大地简化`Aggregate`的持久化。在本章中，我仍然使用基于 ORM 的持久化方式。由于 NoSQL 和键值存储在持久化`Aggregates`方面表现特别出色，我会在 [Repositories (12)](../ch12/0.md) 中重点介绍这种方式。

但在我们深入探讨值对象的 ORM 持久化示例之前，有一个至关重要的建模原则必须被充分理解并严格遵守。因此，作为开头，<ins>让我们先讨论当数据建模（而非领域建模）对你的领域模型产生不恰当影响时可能发生的情况，以及我们可以如何抵制这种错误且有害的影响</ins>。

### 拒绝数据模型泄漏带来的不当影响

大多数情况下，当`Value Object`被持久化到数据存储（例如，使用 ORM 工具和关系数据库）时，它是以非规范化（denormalized）的方式存储的；也就是说，它的属性与父`Entity`对象存储在同一个数据库表行中。这种方式使`Values`的存储和检索既干净又高效，并避免了任何持久化存储细节泄漏到领域模型中。当`Values`能够以这种方式持久化时，不仅令人愉快，也让人感到轻松。

然而，在某些情况下，模型中的`Value Object`在关系型持久化存储中必须被当作`Entity`来存储。换句话说，当进行持久化时，某个特定`Value Object`类型的实例会占据关系数据库中专门为该类型创建的表中的一行，并拥有自己的数据库主键列。例如，当使用 ORM 支持`Value Object`实例的集合时，就会出现这种情况。在这些情况下，`Value`类型的持久化数据在数据库中被建模为一个数据库实体。

这是否意味着领域模型对象应该反映数据模型的设计，而被建模为`Entity`而不是`Value`？不。当你面对这种阻抗不匹配带来的后果时，重要的是保持领域模型的视角，而不是持久化的视角。<ins>为了让自己始终聚焦于领域模型，你可以问自己以下这些问题：</ins>

1. <ins>我正在建模的这个概念，是领域中的一个事物，还是用来度量、量化或描述某个事物的一个 properties？</ins>

2. <ins>如果为了描述领域中的一个元素而对其进行了正确建模，这个模型概念是否必须具备前面所概述的全部或大部分值对象特征？</ins>

3. <ins>我考虑在模型中使用`Entity`，仅仅是因为底层数据模型必须将这个领域模型对象作为数据库中的一个实体来存储吗？</ins>

4. <ins>我之所以使用`Entity`，是因为领域模型本身需要它具有唯一标识，我关心的是各个独立实例，并且必须在该对象的生命周期内管理其连续的变化吗？</ins>

<ins>如果你的回答依次是 “描述性的，是，是，否” ，那么你应该使用`Value Object`。以必要的方式对持久化存储进行建模以处理对象的存储，但不要让这种存储方式影响团队在领域模型中对该值属性的概念化理解。</ins>

---
➜**数据模型应处于从属地位**

为了领域模型而设计数据模型，而不是为了数据模型而设计领域模型。

---

如果可能的话，永远要为了领域模型而设计数据模型，而不是为了数据模型而设计领域模型。如果你选择前者，你将保持领域模型的视角；如果你选择后者，你将保持持久化视角，而你的领域模型往往会沦为数据模型的投影。当你训练自己从领域模型的角度思考 ——也就是 DDD 思维—— 而不是从数据模型的角度思考时，你就能够避免数据模型泄漏带来的负面影响。更多关于 DDD 思维的讨论，请参见 [Entities (5)](../ch5/0.md) 。

当然，也有些时候数据库的参照完整性非常重要（例如外键约束）。你肯定希望关键字段有适当的索引。当然，也确实需要支持针对业务数据运行的商业智能（BI）报表工具。你可以在适当且必要的地方实现所有这些功能。大多数人都会得出结论：报表和商业智能不应该直接操作生产数据，而应该使用专门设计的数据模型。遵循这种更具战略性的思路，你就可以更自由地设计领域模型所依赖的数据模型，使其能够最好地支持你的 DDD 工作。

无论你的数据模型采用哪些技术方面，它的实体、主键、参照完整性和索引都 *绝不能* 驱动你对领域对象的建模方式。DDD 不是关于以规范化方式结构化数据，而是关于在一致的`Bounded Context`中建模`Ubiquitous Language`。我鼓励你遵循 DDD，而不是遵循数据结构。当你这样做时，你应该明智地采取一切可能的步骤，将所有数据模型泄漏的痕迹（在使用 ORM 时至少会在某种程度上发生）从你的领域模型及其客户端中隐藏起来。这是我在下一节中要讨论的内容。

### ORM 与单个`Value Object`

将单个`Value Object`实例持久化到数据库通常非常直接。这里我重点讨论 Hibernate 与 MySQL 关系数据库的使用。基本思路是：将`Value`的每个属性存储在其父`Entity`所在行的不同列中。换句话说，单个值对象被 *非规范化* 到其父`Entity`的行中。采用列命名约定有一些好处，可以清楚地标识并标准化序列化对象的命名方式。下面我将介绍一种持久化`Value Object`的命名约定。

当使用 Hibernate 持久化单个`Value Object`实例时，应使用 `component` 映射元素。之所以使用 `component` 元素，是因为它允许将`Value`以非规范化的方式直接映射到父`Entity`表的行中。这是一种最佳的序列化技术，同时仍然允许在 SQL 查询中包含这些`Values`。

下面是 Hibernate 映射文档中描述 BusinessPriority `Value Object`映射的部分，该对象由其父`Entity` BacklogItem 类持有：

```xml
<component name="businessPriority"
    class="com.saasovation.agilepm.domain.model.product.BusinessPriority">
    <component name="ratings"
            class="com.saasovation.agilepm.domain.model.product.↵ 
             BusinessPriorityRatings">
        <property
            name="benefit"
            column="business_priority_ratings_benefit"
            type="int"
            update="true"
            insert="true"
            lazy="false"
            />
        <property
            name="cost"
            column="business_priority_ratings_cost"
            type="int"
            update="true"
            insert="true"
            lazy="false"
            />
        <property
            name="penalty"
            column="business_priority_ratings_penalty"
            type="int"
            update="true"
            insert="true"
            lazy="false"
            />
        <property
            name="risk"
            column="business_priority_ratings_risk"
            type="int"
            update="true"
            insert="true"
            lazy="false"
            />
    </component>
</component>
```

这是一个很好的例子，因为它展示了一个简单的`Value Object`映射，但其中包含一个子`Value Object`实例。回想一下，BusinessPriority 只有一个 ratings 值属性，没有其他属性。因此，在映射描述中，外层的 component 元素包含一个嵌套的 component 元素。这用于将 BusinessPriority 中包含的、类型为 BusinessPriorityRatings 的单个 ratings `Value` property 进行非规范化存储。由于 BusinessPriority 本身没有任何属性，外层 component 中没有映射任何属性。相反，我们直接嵌套其 ratings `Value` property 的映射。最终，我们实际上只将 BusinessPriorityRatings 实例的四个整数属性存储到 tbl_backlog_item 表的四个不同列中。因此，我们映射了两个 component 元素的`Value Objects`：一个本身没有属性，另一个内部`Value`有四个属性。

请注意每个 Hibernate property 元素所使用的标准列命名方式。这种命名约定基于从最终的父`Value`一直导航到各个属性的路径。例如，考虑从 BusinessPriority 导航到 ValueCostRiskRatings 实例的 benefit 属性的路径，逻辑上是：

```
businessPriority.ratings.benefit
```

要将此导航路径表示为单个关系列名，我使用以下方式：

```
business_priority_ratings_benefit
```

当然，如果你愿意，也可以使用其他更具代表性的名称。也许你更喜欢将驼峰式命名 (camel case) 与下划线混合使用：

```
businessPriority_ratings_benefit
```

在你看来，这种示例命名方式可能更能清晰地表达导航路径。我已经统一使用全下划线命名，因为它更接近传统的 SQL 列名，而不是对象名。对应的 MySQL 数据库表定义包含以下列：

```SQL
CREATE TABLE `tbl_backlog_item` (
    ...
    `business_priority_ratings_benefit` int NOT NULL,
    `business_priority_ratings_cost` int NOT NULL,
    `business_priority_ratings_penalty` int NOT NULL,
    `business_priority_ratings_risk` int NOT NULL,
    ...
) ENGINE=InnoDB;
```

Hibernate 映射和关系数据库表定义共同提供了一种既优化又可查询的持久化对象方式。由于`Value`的属性被非规范化到其父`Entity`的表行中，数据库甚至不需要使用连接（join）来检索深度嵌套的`Value`实例。当你指定一个 HQL 查询时，Hibernate 能够轻松地将对象属性的对象表达式映射为使用列的优化 SQL 查询表达式，其中

```
businessPriority.ratings.benefit
```

变为

```
business_priority_ratings_benefit
```

因此，尽管对象与关系数据库之间存在明显的阻抗不匹配，我们仍实现了一种功能更强、更优化的映射方式。

### ORM 与序列化到单个列中的多个`Values`

使用 ORM 将多个`Value Objects`的集合映射到关系数据库时，会面临一些独特的挑战。需要明确的是，这里所说的 “集合” 指的是由`Entity`持有、包含零个、一个或多个`Value`实例的 List 或 Set。这些挑战并非无法克服，但对象–关系之间的阻抗不匹配在这种场景下会变得格外明显。

Hibernate 对象–关系映射提供的一种选择是：将整个对象集合序列化为文本形式，并将该文本持久化到单个列中。这种方法存在一些缺点。然而，在某些情况下，这些缺点并不明显，为了利用该方法的优势，它们可能会被直接忽略。在这种情况下，你可以决定使用这种`Value`集合持久化方式。需要考虑的潜在缺点如下：

- *列宽限制 (Column width)* 。有时你无法确定集合中`Value`元素的最大数量，也无法确定每个序列化`Value`的最大大小。例如，某些对象集合可能包含任意数量的元素——上限未知。此外，集合中的每个`Value`元素在序列化后可能具有不确定的字符宽度。当`Value`类型的一个或多个属性是 String 类型，并且其字符长度很长或没有明确限制时，就会出现这种情况。在这两种情况中的任意一种或同时出现时，序列化后的整个集合都有可能超出字符列的最大可用宽度。如果字符列本身的最大宽度相对较窄，或者存储整行数据的总字节数有限，这个问题会进一步加剧。例如，MySQL InnoDB 引擎的 VARCHAR 最大宽度为 65,535 个字符，但单行的总存储字节数也限制在 65,535 字节。你必须为存储整个`Entity`的所有列预留足够的空间。Oracle Database 的 VARCHAR2/NVARCHAR2 最大宽度为 4,000 个字符。如果你无法预先确定存储`Value`集合序列化形式所需的最大宽度，或者你的最大列宽可能被超出，就应该避免使用这种方式。

- *必须查询 (Must Query)* 。由于在这种方式中`Value`集合被序列化为扁平的文本形式，因此单个`Value`元素的属性无法在 SQL 查询表达式中使用。如果任何`Value`属性必须支持查询，那么你就不能使用这种方式。不过，这可能是一个不太常见的避免理由，因为从包含的集合对象中查询一个或多个属性的需求本身就比较少见。

- *需要自定义用户类型 (Requires custom user type)* 。要使用这种方法，你必须开发一个 Hibernate 自定义用户类型，用于管理每个集合的序列化和反序列化。就我个人而言，我认为这比其他问题的影响要小，因为一个经过深思熟虑的自定义用户类型实现就可以支持所有`Value Object`类型的集合（“一个实现适配所有”）。

我在这里没有提供用于将集合序列化为单个列的 Hibernate 自定义用户类型，但 Hibernate 社区提供了大量指导，帮助你实现自己的版本。

### ORM 与由数据库实体支持的多个`Values`

使用 Hibernate（或其他 ORM）和关系数据库持久化`Value`集合的一种非常直接的方法，是将`Value`类型在数据模型中当作一个实体来处理。需要重申的是，正如我在 [拒绝数据模型泄漏的不当影响](#拒绝数据模型泄漏带来的不当影响) 一节中所主张的，这种方法 **绝不能** 导致仅仅因为某个概念在持久化时最适合表示为数据库实体，就错误地将其在领域模型中建模为`Entity`。在某些情况下，是对象–关系阻抗不匹配要求采用这种方法，而不是 DDD 的原则。如果有一种完全匹配的持久化方式可供你使用，你就会将该概念建模为`Value`类型，而不会再考虑数据库实体的特性。这样思考有助于我们保持正确的领域建模思维。

为了实现这一点，我们可以使用`Layer Supertype` [[Fowler, P of EAA](../bibli.md#fowler-p-of-eaa)] 。就我个人而言，把必要的代理标识（主键）隐藏起来会让我感觉更舒服。不过，由于 Java（以及其他语言）中的每个对象都已经拥有一个仅由虚拟机使用的内部唯一标识，你可能会觉得直接在`Value`中添加一个专门的标识是合理的。我认为，无论我们偏好哪种方式，在围绕对象–关系阻抗不匹配进行变通时，都需要在心中为自己的技术选择找到有说服力的理由。接下来我会说明我的偏好。

下面是我偏爱的代理主键（surrogate key）实现方式示例，它使用了两个`Layer Supertype`类：

```Java
public abstract class IdentifiedDomainObject implements Serializable  {

    private long id = -1;

    public IdentifiedDomainObject() {
        super();
    }

    protected long id() {
        return this.id;
    }

    protected void setId(long anId) {
        this.id = anId;
    }
}
```

第一个涉及的`Layer Supertype`是 IdentifiedDomainObject 。这个抽象基类提供了一个基本的代理主键，并对客户端隐藏。由于访问器方法被声明为 protected，客户端永远不必疑惑这些方法是否是供他们使用的。当然，你也可以通过将它们的作用域声明为 private 来进一步避免客户端知晓这些方法。Hibernate 使用反射访问方法或字段时，对非 public 的任何作用域都没有问题。

接下来，我再提供一个专门用于`Values Objects`的`Layer Supertype`：

```Java
public abstract class IdentifiedValueObject extends IdentifiedDomainObject  {

    public IdentifiedValueObject() {
        super();
    }
}

```
你可以把 IdentifiedValueObject 类视为一个纯粹的标记类，一个没有任何行为的 IdentifiedDomainObject 子类。我认为它具有源代码文档方面的价值，因为它更明确地表达了它所解决的建模挑战。同样地，IdentifiedDomainObject 还有另一个直接的抽象子类 Entity，这将在 [Entities (5)](../ch5/0.md) 中讨论。我喜欢这种方式。你也可以选择去掉这些额外的类。

既然现在有了一种方便且适当隐藏的方式，可以为任何`Value`类型提供代理标识，下面给出一个使用它的示例类：

```Java
public final class GroupMember extends IdentifiedValueObject  {
    private String name;
    private TenantId tenantId;
    private GroupMemberType type;

    public GroupMember(
            TenantId aTenantId,
            String aName,
            GroupMemberType aType) {
        this();
        this.setName(aName);
        this.setTenantId(aTenantId);
        this.setType(aType);
        this.initialize();
    }
    ...
}
```

GroupMember 类是一个`Value`类型，由`Aggregate`根`Entity` Group 类进行收集。该根`Entity`可以包含任意数量的 GroupMember 实例。现在，由于每个 GroupMember 实例在数据模型中都通过其代理主键被唯一标识，我们就可以在领域模型中仍然将其作为`Value`的同时，自由地将其持久化映射为数据库实体。下面是 Group 类的相关部分：

```Java
public class Group extends Entity  {
    private String description;
    private Set<GroupMember> groupMembers;
    private String name;
    private TenantId tenantId;

    public Group(
            TenantId aTenantId,
            String aName,
            String aDescription) {
        this();
        this.setDescription(aDescription);
        this.setName(aName);
        this.setTenantId(aTenantId);
        this.initialize();
    }
    ...
    protected Group() {
        super();
        this.setGroupMembers(new HashSet<GroupMember>(0));
    }
    ...
}
```

Group 类会在其 groupMembers 集合中逐步累积任意数量的 GroupMember 实例。请记住，如果你需要执行整个集合的替换操作，一定要在替换之前调用集合的 clear () 方法。这样做可以确保底层的 Hibernate 集合实现会从数据存储中删除过时的元素。下面这段代码并不是 Group 类的真实方法，而是一个示例，用来演示在执行整个集合替换时，通常如何避免出现孤立的`Value`元素：

```Java
public void replaceMembers(Set<GroupMember> aReplacementMembers) {
    this.groupMembers().clear();
    this.setGroupMembers(aReplacementMembers);
}
```

我认为这种 ORM 细节向模型的渗透是无明显影响的，因为它使用的是通用的 Collection 工具，而且客户端完全看不到这些细节。不过，将集合内容与数据库同步并非总能想当然地处理。调用 Collection 的 remove () 方法会自动触发单个`Value`在数据存储中的删除操作，在这种场景下则完全不存在 ORM 细节渗透的问题。

接下来，我们重点关注 Group 映射配置中用于映射该集合的部分：

```xml
<hibernate-mapping>
<class name="com.saasovation.identityaccess.domain.model.↵
        identity.Group"
     table="tbl_group" lazy="true">
        ...
        <set name="groupMembers" cascade="all,delete-orphan"
          inverse="false" lazy="true">
            <key column="group_id" not-null="true" />
            <one-to-many class="com.saasovation.↵
              identityaccess.domain.model.identity.GroupMember" />
        </set>
... </class>
</hibernate-mapping>
```

groupMembers Set 被完全当作数据库实体进行映射。此外，我们还可以看到完整的 GroupMember 映射描述：

```xml
<hibernate-mapping>
<class name="com.saasovation.identityaccess.domain.model.↵
           identity.GroupMember"
           table="tbl_group_member" lazy="true">
        <id
            name="id"
            type="long"
            column="id"
            unsaved-value="-1">
            <generator class="native"/>
        </id>
        <property
            name="name"
            column="name"
            type="java.lang.String"
            update="true"
            insert="true"
            lazy="false"
        />
        <component name="tenantId" class="com.saasovation.identityaccess.domain.model.↵
                identity.TenantId">
            <property
                name="id"
                column="tenant_id_id"
                type="java.lang.String"
                update="true"
                insert="true"
                lazy="false"
            />
        </component>
        <property
            name="type"
            column="type" type="com.saasovation.identityaccess.infrastructure.↵ 
                persistence.GroupMemberTypeUserType"
            update="true"
            insert="true"
            not-null="true"
        />
    </class>
</hibernate-mapping>
```

请注意 `<id>` 元素，它定义了用于持久化的代理主键。最后，下面是对应的 MySQL `tbl_group_member` 表定义：

```SQL
CREATE TABLE `tbl_group_member` (
    `id` int(11) NOT NULL auto_increment,
    `name` varchar(100) NOT NULL,
    `tenant_id_id` varchar(36) NOT NULL,
    `type` varchar(5) NOT NULL,
    `group_id` int(11) NOT NULL,
    KEY `k_group_id` (`group_id`),
    KEY `k_tenant_id_id` (`tenant_id_id`),
    CONSTRAINT `fk_1_tbl_group_member_tbl_group`
        FOREIGN KEY (`group_id`) REFERENCES `tbl_group` (`id`),
    PRIMARY KEY (`id`)
) ENGINE=InnoDB;
```

当我们查看 GroupMember 的映射和数据库表定义时，会强烈感觉到我们正在处理一个实体。它有一个名为 id 的主键，有一个必须与 tbl_group 进行连接的独立表，还有一个指向 tbl_group 的外键。无论从哪个角度看，这都是一个实体，*但这仅仅是从数据模型的角度而言* 。在领域模型中，GroupMember 显然是一个`Value Object`。我们已经在领域模型中采取了适当的步骤，小心地隐藏了所有与持久化相关的细节。我没有向领域模型的客户端透露任何持久化渗透的迹象。更重要的是，即使是模型内部的开发人员，也必须仔细查看才能发现任何持久化渗透的痕迹。

### ORM 与由连接表支持的多个`Values`

Hibernate 提供了一种方式，可以在连接表（join table）中持久化多值集合，而不需要`Value`类型本身具备任何数据模型实体的特征。这种映射类型会将集合中的`Value`元素简单地持久化到一个专用表中，并将父`Entity`领域对象的数据库标识作为外键。因此，所有集合中的`Value`元素都可以通过其父`Entity`的外键标识进行查询，并重组回模型中的`Value`集合。这种映射方式的优势在于：`Value`类型不需要为了实现连接而拥有隐藏的代理标识。要使用这种`Value`集合映射方式，你需要使用 Hibernate 的 <composite-element> 标签。

这似乎是一个很大的优势，而且在你的需求场景中可能确实如此。然而，这种方法也存在一些你应该注意的弱点。其中一个缺点是，即使你的`Value`类型不需要代理键，也仍然需要进行连接，因为它涉及到两个表的规范化。确实，[ORM 与由数据库实体支持的多个`Values`](#orm-与由数据库实体支持的多个values) 那一种方法也需要连接。但该方法并不受此方法的第二个弱点限制，而这个弱点是……

如果你的集合是 Set，那么你的`Value`类型的任何属性都不能为 null。原因是：为了删除（数据模型中的垃圾回收）某个特定的 Set 元素，必须使用该元素中所有能使其成为唯一`Value`的属性，作为一种组合键来查找并删除它。而 null 不能作为所需组合键的一部分。当然，如果你确定某个`Value`类型永远不会有 null 属性，那么这种方法是可行的 —— 前提是你没有其他相互冲突的需求。

使用这种映射方式的第三个缺点是：被映射的`Value`类型本身不能包含集合。如果元素本身包含集合，<composite-element> 就无法提供相应的映射支持。只有当你的`Value`类型不包含任何集合，并且在其他方面也满足这种映射方式的要求时，它才是可用的。

最后，我发现这种映射方式的限制足够多，因此总体上应该避免使用。对我来说，更简单的做法是在被收集为一对多关联的`Value`类型上放置一个隐藏良好的代理标识，而不必担心 <composite-element> 的任何约束。你可能会有不同的看法，而且如果所有建模条件都恰好适合你，这种方式当然也可以为你带来好处。

### ORM 与作为状态对象的枚举类型

如果你发现枚举类型（enum）是用于标准类型（Standard Type）和 / 或状态对象（State object）的有效建模选择，就需要找到持久化它们的方法。在 Hibernate 中，Java 枚举类型需要借助专门的持久化技术来处理。遗憾的是，截至目前，Hibernate 开发社区并未将枚举类型作为开箱即用的属性类型提供支持。因此，要在模型中持久化枚举类型，我们必须创建一个 Hibernate 自定义用户类型。

回顾一下，每个 GroupMember 实例都包含一个 GroupMemberType 类型的属性：

```java
public final class GroupMember extends IdentifiedValueObject  {
    private String name;
    private TenantId tenantId;
    private GroupMemberType type;

    public GroupMember(
            TenantId aTenantId,
            String aName,
            GroupMemberType aType) {
        this();
        this.setName(aName);
        this.setTenantId(aTenantId);
        this.setType(aType);
        this.initialize();
    }
    ...
}
```

GroupMemberType 枚举类型的标准类型包括 GROUP 和 USER。其定义如下：

```java
package com.saasovation.identityaccess.domain.model.identity;
public enum GroupMemberType {
    GROUP {
        public boolean isGroup() {
            return true;
        }
    },
    USER {
        public boolean isUser() {
            return true;
        }
    };

    public boolean isGroup() {
        return false;
    }

    public boolean isUser() {
        return false;
    }
}
```

持久化 Java 枚举`Value`的简单方法是存储它的文本表示。然而，这个简单的方法会引出一种稍微复杂一些的技术 —— 创建一个 Hibernate 自定义用户类型。这里不再列出 Hibernate 社区提供的各种 EnumUserType 实现方式，我提供对应的 wiki 文章链接：http://community.jboss.org/wiki/Java5EnumUserType 。

在撰写本书时，该 wiki 文章提供了多种实现方式。其中包括：为每个枚举类型实现一个自定义用户类型类的示例；一种使用 Hibernate 3 参数化类型来避免为每个枚举类型都实现自定义用户类型的方法（非常实用）；一种不仅支持文本字符串，还支持枚举值的数值表示的实现；甚至还有 Gavin King 提供的增强版实现。Gavin King 的增强版实现允许将枚举用作类型鉴别器（type discriminator）或数据表标识（id）。

在从这些选项中选择了一种方式之后，下面是枚举类型 GroupMemberType 的映射示例：

```xml
<hibernate-mapping>
<class name="com.saasovation.identityaccess.domain.model.↵
            identity.GroupMember" table="tbl_group_member" lazy="true">
        ...
        <property
            name="type"
            column="type"
            type="com.saasovation.identityaccess.infrastructure.↵
                persistence.GroupMemberTypeUserType"
            update="true"
            insert="true"
            not-null="true"
        />
    </class>
</hibernate-mapping>
```

请注意，`<property>`元素的 type 属性被设置为 GroupMemberTypeUserType 类的完整类路径。这只是其中一种选择，你可以根据自己的偏好任选其一。回顾一下，MySQL 表定义中包含了用于存储该枚举值的列：

```SQL
CREATE TABLE `tbl_group_member` (
    ...
    `type` varchar(5) NOT NULL,
    ...
) ENGINE=InnoDB;
```

type 列是 VARCHAR 类型，最大长度为 5 个字符，足以容纳最长的类型文本表示：GROUP 或 USER。

<center><img src="../img/ownit.png" align="center" width="30%" /></center>

#### ▶[下一节](7.md)
