## 测试`Value Objects`

#### ▶[上一节](5.md)

为了强调测试优先，我会先给出示例测试，然后再提供`Value Object`的实现。<ins>这些测试通过展示客户端将如何使用每个对象，从而驱动领域模型的设计。</ins>

采用这种风格时，我们并不是那么关心单元测试的各个方面，也不是要从各个角度彻底证明模型是完全无懈可击的。相反，在这个阶段，我们更感兴趣的是展示领域模型中的各种对象将如何被客户端使用，以及这些客户端在使用它们时可以期望得到什么。<ins>在设计模型时，必须站在客户端的角度来思考，以便捕捉到核心概念。否则，我们可能是从自己的视角而不是从业务的视角来建模。</ins>

---

➜**最佳示例代码**

可以这样理解这种测试风格：如果我们要为该模型编写一份用户手册，那么这些测试就是最恰当的代码示例，用来展示客户端应该如何使用这个特定的领域对象。

---

这并不是说不应该开发单元测试。所有符合团队标准的额外测试都应该而且必须编写。然而，每种类型的测试都有不同的目的。单元测试和行为测试都有它们的位置，下面的建模测试也是如此。

所选的`Value Object`是从最新的 [Core Domain (2)](../ch2/0.md)，`Agile Project Management Context`中提取的一个很好的通用表示。

---
| ||
|---|---|
| 在这个`Bounded Context`中，业务领域专家会谈到 “待办项的业务优先级”。为了体现`Ubiquitous Language`的这一部分，我们将该概念建模为一个 BusinessPriority。它会提供经过计算的输出，用来支持对每个产品待办项开发价值的业务分析 [[Wiegers](../bibli.md#wiegers)] 。这些输出包括：|![](../img/ovation.1.png)|

- **成本百分比（cost percentage）**：即开发某个特定待办项的成本，相对于开发所有其他待办项成本的比例；
- **总价值（total value）**：即开发某个特定待办项所获得的总价值；
- **价值百分比（value percentage）**：即开发某个特定待办项的价值，相对于开发其他任何待办项价值的比例；
- **优先级（priority）**：即在与所有其他待办项比较时，业务在考虑为该待办项分配优先级时应参考的、经过计算得出的优先级。

这些测试实际上是在多次简短的重构迭代中，通过逐步细化而形成的，尽管在这里它们是以一套完成的形式呈现出来的：

```java
package com.saasovation.agilepm.domain.model.product;

import com.saasovation.agilepm.domain.model.DomainTest;

import java.text.NumberFormat;

public class BusinessPriorityTest extends DomainTest {

    public BusinessPriorityTest() {
        super();
    }
    ...
    private NumberFormat oneDecimal() {
        return this.decimal(1);
    }

    private NumberFormat twoDecimals() {
        return this.decimal(2);
    }

    private NumberFormat decimal(int aNumberOfDecimals) {
        NumberFormat fmt = NumberFormat.getInstance();
        fmt.setMinimumFractionDigits(aNumberOfDecimals);
        fmt.setMaximumFractionDigits(aNumberOfDecimals);
        return fmt;
    }
}
```

这个类包含一些测试夹具辅助方法。由于团队需要测试各种计算的准确性，他们编写了一些方法来提供 NumberFormat 实例，用于处理小数点后保留一位或两位的小数数值。你接下来会看到这些方法为什么很有用：

```java
    public void testCostPercentageCalculation() throws Exception {

        BusinessPriority businessPriority =
            new BusinessPriority(
                    new BusinessPriorityRatings(2, 4, 1, 1));

        BusinessPriority businessPriorityCopy =
            new BusinessPriority(businessPriority);

        assertEquals(businessPriority, businessPriorityCopy);

        BusinessPriorityTotals totals =
            new BusinessPriorityTotals(53, 49, 53 + 49, 37, 33);

        float cost = businessPriority.costPercentage(totals);

        assertEquals(this.oneDecimal().format(cost), "2.7");

        assertEquals(businessPriority, businessPriorityCopy);
    }
```

团队想出了一个测试不可变性的好办法。每个测试首先创建一个 BusinessPriority 实例，然后使用拷贝构造函数生成一个与其等价的副本。测试中的第一个断言用于确保拷贝构造函数生成的副本与原始对象相等。

接下来，他们设计了测试来创建一个 BusinessPriorityTotals 实例，并将其赋值给 totals 方法变量。借助 totals，他们能够调用 costPercentage() 查询方法，并将结果赋值给 cost。然后他们断言返回的值应为 2.7，这是手动计算得出的正确结果。最后，他们断言 costPercentage() 方法的行为确实是无副作用的——如果 businessPriority 与 businessPriorityCopy 仍然保持值相等，就说明这一点成立。通过这个测试，他们清楚地了解了如何计算成本百分比，以及计算结果应该是什么样的。

接下来，他们需要测试优先级、总价值以及价值百分比的计算，使用的是同样的基本测试思路：

```java
    public void testPriorityCalculation() throws Exception {

        BusinessPriority businessPriority =
            new BusinessPriority(
                    new BusinessPriorityRatings(2, 4, 1, 1));

        BusinessPriority businessPriorityCopy =
            new BusinessPriority(businessPriority);

        assertEquals(businessPriorityCopy, businessPriority);

        BusinessPriorityTotals totals =
            new BusinessPriorityTotals(53, 49, 53 + 49, 37, 33);

        float calculatedPriority = businessPriority.priority(totals);

        assertEquals("1.03",
                    this.twoDecimals().format(calculatedPriority));
        assertEquals(businessPriority, businessPriorityCopy);
    }

    public void testTotalValueCalculation() throws Exception {
        BusinessPriority businessPriority =
            new BusinessPriority(
                    new BusinessPriorityRatings(2, 4, 1, 1));

        BusinessPriority businessPriorityCopy =
            new BusinessPriority(businessPriority);

        assertEquals(businessPriority, businessPriorityCopy);

        float totalValue = businessPriority.totalValue();
      
        assertEquals("6.0", this.oneDecimal().format(totalValue));

        assertEquals(businessPriority, businessPriorityCopy);
    }

    public void testValuePercentageCalculation() throws Exception {
        BusinessPriority businessPriority =
            new BusinessPriority(
                    new BusinessPriorityRatings(2, 4, 1, 1));

        BusinessPriority businessPriorityCopy =
            new BusinessPriority(businessPriority);

        assertEquals(businessPriority, businessPriorityCopy);

        BusinessPriorityTotals totals =
            new BusinessPriorityTotals(53, 49, 53 + 49, 37, 33);

        float valuePercentage =
                businessPriority.valuePercentage(totals);

        assertEquals("5.9", this.oneDecimal().format(valuePercentage));

        assertEquals(businessPriorityCopy, businessPriority);
    }
```

➜**测试应具有领域意义**

你的模型测试应该对领域专家有意义。

非技术背景的领域专家 ——在稍微帮助下—— 阅读这些基于示例的测试时，能够理解 BusinessPriority 是如何被使用的、它会产生哪些类型的结果、它的行为被保证是无副作用的，并且它符合`Ubiquitous Language`的概念和意图。

重要的是，这个`Value Object`的状态在所有使用场景中都被保证是不可变的。客户端可以对任意数量的产品待办项进行优先级计算、排序、比较，并根据需要调整每个项的 BusinessPriorityRatings。

---

#### ▶[下一节](7.md)
