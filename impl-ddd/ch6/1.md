## `Value`的特征

#### ▶[上一节](0.md)

<ins>作为首要事项，当你将一个领域概念建模为`Value Object`时，要确保你是在围绕`Ubiquitous Language`进行表达。你可以把这视为一条总体原则，也是必须达到的一个特征。我会在整章中不断体现这一原则。</ins>

<ins>当你试图判断一个概念是否是值对象时，你应该确定它是否拥有以下大部分特征：</ins>

- 它在领域中度量、量化或描述某个事物。
- 它可以被设计为不可变的。
- 它通过将相关属性组合成一个整体单元来建模一个概念上的整体。
- 当度量或描述发生变化时，它可以被完全替换。
- 它可以通过`Value`相等性与其他对象进行比较。
- 它向协作对象提供`Side-Effect-Free Behavior` [[Evans](../bibli.md#evans)] 。

更详细地理解这些特征会很有帮助。通过采用这种方法来分析模型中的设计元素，你可能会发现：你应该比以往更频繁地使用`Value Objects`。

### 度量、量化或描述

<ins>当你的模型中存在一个真正的`Value Objects`时，无论你是否意识到，它都不是领域中的一个东西。相反，它实际上是一个用于度量、量化或以其他方式描述领域中某个事物的概念</ins>。例如，一个人有年龄。年龄并不是一个真正的东西，而是用来度量或量化这个人（事物）已经生活了多少年。一个人有名字。名字也不是一个东西，而是用来描述这个人（事物）被如何称呼。

这一点与`Conceptual Whole`特征密切相关。

### 不可变（Immutable）

<ins>一个作为`Value`的对象在创建之后就不能被修改</ins>。<sup>[1](#1)</sup> 例如，在 Java 或 C# 中编程时，你会使用`Value`类的某个构造函数来创建实例，并将其状态所基于的所有对象作为参数传入。这些参数可以是直接作为`Value`属性的对象，也可以是在构造过程中用于派生一个或多个新构成属性的对象。下面是一个`Value Object`类型的示例，它持有对另一个`Value Object`的引用：

```Java
package com.saasovation.agilepm.domain.model.product;

public final class BusinessPriority implements Serializable {

    private BusinessPriorityRatings ratings;

    public BusinessPriority(BusinessPriorityRatings aRatings) {
        super();
        this.setRatings(aRatings);
        this.initialize();
    }
    ...
}
```

<ins>仅通过实例化并不能保证一个对象是不可变的。在对象通过构造过程被实例化并初始化之后，它的任何方法，无论是公共的还是隐藏的，从那时起都不应导致其状态发生变化</ins>。在这个例子中，只有 `setRatings()` 和 `initialize()` 方法可能会改变状态，因为它们只在构造过程的范围内被使用。方法 `setRatings()` 是私有/隐藏的，不能从实例外部调用。<sup>[2](#2)</sup> 此外，`BusinessPriority` 类的实现必须确保：除了构造函数之外，其他任何方法（无论是公共的还是隐藏的）都不得调用这个设置方法。稍后我将讨论如何对`Value Objects`的不可变性进行测试。

根据你的喜好，<ins>有时你可以设计持有对`Entities`引用的`Value Objects`。但这一点可能需要谨慎。当被引用的`Entities`通过其自身的行为改变状态时，这个`Value`也会随之改变，这就违反了不可变性</ins>。因此，<ins>最好采用这样一种思路：
`Value`类型持有`Entity`引用，应该只是为了组合式不可变性、表达力和便利性</ins>。否则，如果持有`Entities`的明确目的是为了通过`Value`的接口来修改`Entities`的状态，那很可能是一个错误的组合理由。在做决定时，需要权衡这些相互冲突的因素，同时考虑本章后面将要讨论的`Side-Effect-Free Behavior`特征。

---
➜**挑战你的假设**

如果你认为自己正在设计的对象必须通过其行为来修改状态，那么问问自己：为什么这是必要的？当这个值必须改变时，是否可以改用替换（replacement）的方式来处理？在可能的情况下采用这种方式，是在朝着简化设计的方向努力。

有时，让一个对象不可变根本没有意义。这完全没问题，而且这表明该对象应该被建模为一个`Entity`。如果你的分析得出了这样的结论，请参考 [Entities (5)](../ch5/0.md) 。

---

### 概念整体（Conceptual Whole）

一个`Value Object`可能只包含一个、几个或多个单独的属性，而这些属性彼此相关。每个属性都为一个整体贡献重要的一部分，而这些属性共同描述了这个整体。如果把它们彼此分离，每个属性都无法提供一个连贯的含义。只有当所有属性组合在一起时，才能形成完整的、预期的度量或描述。这与仅仅把一组属性简单地放在一个对象中是不同的。如果这个整体不能充分描述模型中的另一个事物，那么这种分组本身几乎没有意义。 *(译注：如果没有特别标注，attribute 被翻译为属性，property 会单独标注)*

正如 Ward Cunningham 在他的`Whole Value`模式 <sup>[3](#3)</sup> ，又名`Value Object`，中所说明的那样，`Value` {50,000,000 dollars} 有两个属性：属性 50,000,000 和属性 dollars。如果把它们分开来看，这些属性要么描述的是别的东西，要么就没有什么特别的意义。数字 50,000,000 尤其如此，当然 “dollars” 也是如此。只有当这些属性组合在一起时，它们才构成一个概念整体，用来描述一个货币度量。因此，我们不会期望一个据说价值 50,000,000 dollars 的事物，用两个单独的属性来描述它的价值：一个是金额（amount）= 50,000,000，另一个是货币单位（currency）= dollars。因为这个事物的价值不只是 50,000,000，也不只是 dollars。下面是一种不清晰的建模方式：

```Java
// incorrectly modeled thing of worth
public class ThingOfWorth {
    private String name; // attribute
    private BigDecimal amount; // attribute
    private String currency; // attribute
    // ...
}
```

在这个例子中，模型及其使用者必须知道何时以及如何同时使用 amount 和 currency，因为它们没有构成一个概念整体。这就需要一种更好的建模方式。

要恰当地描述一个事物的价值，就不能把它当作两个独立的属性，而应将其视为一个整体值：{50,000,000 dollars}。下面是将其建模为`Whole Value`的方式：

```Java
public final class MonetaryValue implements Serializable {
    private BigDecimal amount;
    private String currency;

    public MonetaryValue(BigDecimal anAmount, String aCurrency) {
        this.setAmount(anAmount);
        this.setCurrency(aCurrency);
    }
    ...
}
```

这并不是说 MonetaryValue 已经很完美、不能再改进了。当然，使用一个额外的`Value`类型（例如 Currency）会有所帮助。我们可以用更具描述性的 Currency 类型来替代 currency 属性的 String 类型。此外，使用一个`Factory`，或者可能是一个`Builder`来处理它，也可能是个不错的选择 [[Gamma et al.](../bibli.md#gamma-et-al)] 。但这些话题会偏离这个简单示例的重点，它本来是为了说明`Whole Value`的概念。

因为领域中某个概念的整体性非常重要，所以对一个`Value Object`的父对象引用不只是一个属性。相反，它是模型中包含它的父对象/事物所拥有的一个 *property* ，这个 property 持有对该`Value Object`的引用。诚然，这个`Value Object`类型本身有一个或多个属性（在 MonetaryValue 的例子中有两个）。但对于持有该`Value Object`实例引用的那个事物来说，它只是一个 property  。因此，那个价值 50,000,000 美元的事物 ——让我们称之为 ThingOfWorth—— 会有一个 property ，可能名为 worth ，该 property 持有一个`Value Object`实例的引用，而这个`Value Object`实例通过它的两个属性共同描述了 {50,000,000 dollars} 这个度量。<ins>不过要记住，property 名——可能是 worth，以及`Value`类型名——可能是 MonetaryValue，只有在确定了我们的 [Bounded Context (2)](../ch2/0.md) 及其`Ubiquitous Language`之后才能决定</ins>。下面是一个改进后的实现：

```Java
// correctly modeled thing of worth
public class ThingOfWorth {
    private ThingName name; // property
    private MonetaryValue worth; // property
    // ...
}
```

不出所料，我修改了 `ThingOfWorth` 让他拥有一个名为 `worth`、类型为 `MonetaryValue` 的 property。这无疑清理了原本杂乱无章的属性。但更重要的是，现在有了一个表达整体的`Value`。

我想提醒你注意第二个变化，这可能是你没有预料到的。`ThingOfWorth` 的 name 可能和它的 worth 一样，都非常重要，需要恰当地描述。因此，我也把 name 的 String 类型替换成了 ThingName 类型。一开始，使用 String 类型来表示 name 似乎已经足够。<ins>但在后续迭代中你会发现，使用普通的 String 会带来问题：它会导致围绕 `ThingOfWorth` 的 name 的领域逻辑从模型中泄漏出去，泄漏到模型的其他部分，甚至泄漏到客户端代码中：</ins>

```Java
// clients deal with naming issues
String name = thingOfWorth.name();
String capitalizedName =
    name.substring(0, 1).toUpperCase()
    + name.substring(1).toLowerCase();
```

在这里，客户端试图对名称可能存在的大小写问题进行无力的修复。相反，如果我们定义一个 ThingName 类型，就可以将所有与 `ThingOfWorth` 名称相关的处理逻辑集中在一起。<ins>基于这个例子，`ThingName` 可以在实例化时对文本名称进行完整的格式化，从而减轻客户端的负担。这也强调了在整个模型中大量使用`Values`的必要性，而不是削弱它们的重要性和使用场景</ins>。现在，`ThingOfWorth` 不再包含三个意义较弱的属性，而是包含两个类型恰当、命名清晰的`Values` property。

`Value`类的构造函数对概念整体（conceptual whole）的有效性起着关键作用。<ins>除了不可变性之外，我们还要求`Value`类的构造函数一次性确保`Whole Value`被完整创建。你不能允许`Value`实例的属性在构造之后再被填充，就像把一个`Whole Value`逐块拼装起来一样</ins>。相反，它的最终状态必须被保证是一次性、原子化地初始化完成。前面提到的 `BusinessPriority` 和 `MonetaryValue` 的构造函数就体现了这一点。

关于基本值类型（例如 String、Integer 或 Double）被过度使用，这里还有另一个角度的看法。有些编程语言（例如 Ruby）允许你通过添加新的、专门的行为来有效地修补一个类。借助这种能力，你可能会考虑使用例如双精度浮点数（double）来表示货币。如果你需要计算不同货币之间的汇率，你只需给 Double 类修补一个 convertToCurrency(Currency aCurrency) 行为即可。这看起来可能很酷，但在这种情况下使用这样的语言特性真的是个好主意吗？首先，这种特定于货币的行为很可能会淹没在双精度浮点数那一大堆通用职责中。这是第一击。同样，Double 类本身并没有内置对货币的理解。所以你必须在这个语言的默认类型上堆砌更多与货币相关的逻辑。毕竟，你必须传入一个 Currency 对象才能知道要转换成哪种货币。这是第二击。最重要的是，Double 类并没有明确表达你的领域概念。如果不应用`Ubiquitous Language`，你就会失去对领域关注点的掌控。这是大大的失分，第三击。

---
➜**挑战你的假设**

如果你倾向于在一个`Entity`上放置多个属性，结果导致它与所有其他属性的关系被削弱，那么这些属性很可能应该被组合成一个单一的`Value`类型，或多个`Value`类型。每个`Value`类型都应构成一个概念上的整体，体现内聚性，并使用领域`Ubiquitous Language`中恰当的名称来命名。即使只有一个属性与某个描述性概念相关联，将该概念的所有关注点集中在一起，也很可能会提升模型的表达能力。如果其中一个或多个属性必须随时间变化，可以考虑使用`Whole Value`替换的方式，而不是让一个`Entity`在很长的生命周期中持续被维护。

---

### 可替换性

在你的模型中，一个不可变的`Value`应该由一个`Entity`作为引用持有，只要其常量状态描述的是当前正确的`Whole Value`。如果情况不再如此，整个`Value`将被完全替换为一个表示当前正确整体的新`Value`。

可替换性的概念在数字语境中很容易理解。假设你的领域中有一个表示 total 的整数概念。如果当前 total 是 3，但现在需要变成 4，你当然不会去修改整数 3 本身，让它变成 4。相反，你只是把 total 重新设为整数 4：

```Java
int total = 3;

// later...

total = 4;
```

这一点虽然显而易见，但有助于说明问题。在这个例子中，我们只是把 total 从值 3 替换成了值 4。这并不是过度简化。即使某个`Value Object`类型比整数更复杂，替换的本质也是完全一样的。再考虑一个更复杂的`Value`类型：

```Java
FullName name = new FullName("Vaughn", "Vernon");

// later...

name = new FullName("Vaughn", "L", "Vernon");
```

这个 name 最初由我的名字（first name）和姓氏（last name）构成，作为一个描述性的值。之后，这个`Whole Value`被替换为一个新的`Whole Value`，它由我的名字、中间名的首字母和姓氏组成。我并没有调用 FullName 上的某个方法来修改 name 的状态，使其包含中间名的首字母。那样做会破坏 FullName 这个`Value`类型的不可变性。相反，我们只是使用`Whole Value`替换的方式，将 name 对象引用重新赋值为一个全新的 FullName 实例。（当然，这个例子并不是处理替换的最佳方式，后面会有更好的写法。）

---
➜**挑战你的假设**

如果你因为一个对象的属性必须发生变化而倾向于创建一个`Entity`，那么请挑战你自己的假设：它真的是正确的模型吗？是否可以用对象替换（object replacement）来替代？回想前面的替换示例，你可能会认为创建新实例既不切实际，也缺乏表达力。但即使你处理的对象很复杂，而且变化相当频繁，替换也未必是不切实际甚至丑陋的做法。后面的示例将展示一种`Side-Effect-Free Behavior`，它提供了一种简单且富有表达力的方式来处理`Whole Value`替换。

---

### 值相等性（Value Equality）

当比较两个`Value Object`实例时，需采用对象相等性校验的逻辑。在整个系统中，可能存在大量相等但并非同一个对象的`Value`实例。<ins>判断相等性的规则是：先比较两个对象的类型，再比较它们的属性；若类型和属性均完全相同，则判定这两个`Values`相等</ins>。进一步来说，只要任意两个或多个`Value`实例是相等的，你就可以将其中任意一个相等的`Value`实例赋值（通过替换）给`Entity`中对应类型的 property，且这种赋值操作不会改变该 property 的实际值。

以下是 `FullName` 类实现`Value`相等性校验的示例：

```Java
public boolean equals(Object anObject) {
    boolean equalObjects = false;
    if (anObject != null &&
            this.getClass() == anObject.getClass()) {
        FullName typedObject = (FullName) anObject;
        equalObjects =
            this.firstName().equals(typedObject.firstName()) &&
            this.lastName().equals(typedObject.lastName());
    }
    return equalObjects;
}
```

两个 FullName 实例的每个属性都会相互比较（假设这个版本只包含名字和姓氏，不包含中间名）。如果两个对象中的所有属性都相等，那么这两个 FullName 实例就被认为是相等的。这个特定的`Value`在构造时会确保 firstName 和 lastName 不为 null。因此，在 equals() 方法中比较各个对应属性时，就不需要再做 null 防护。此外，我倾向于使用自封装（self-encapsulation），即通过查询方法（query methods）来访问属性。这样可以支持派生属性，而不必要求每个属性都以显式状态的形式存在。同时，这也意味着需要提供一个对应的 hashCode() 实现（稍后会展示）。

考虑一下支持 [Aggregate (10)](../ch10/0.md) 唯一标识所必需的那些`Value`特性组合。例如，当我们通过标识查询某个特定的`Aggregate`实例时，就需要`Value`相等性能力。不可变性（Immutability）同样至关重要。唯一标识绝不能改变，而`Value`的不可变性特性在一定程度上可以确保这一点。我们还能从概念整体（conceptual whole）这一特性中受益，因为标识是根据领域`Ubiquitous Language`来命名的，并且将所有用于识别唯一性的属性都集中在一个实例中。不过，在这个特定场景中，我们并不需要`Value Object`的可替换特性，因为`Aggregate Root`的唯一标识永远不会被替换。但缺少对可替换性的需求，并不妨碍我们在这里使用`Value`。此外，如果标识需要一些`Side-Effect-Free Behavior`，这些行为可以直接在`Value`类型上实现。

---
➜**挑战你的假设**

问问自己：你正在设计的这个概念，是否必须是一个与所有其他对象都能唯一区分的`Entity`，还是使用`Value`相等性就足够表达它了？如果这个概念本身并不需要唯一标识，那就把它建模为一个`Value Object`。

---

### 无副作用行为（Side‑Effect‑Free Behavior）

对象的方法可以被设计为`Side‑Effect‑Free Function` [[Evans](../bibli.md#evans)] 。*函数 (function)* 是对象的一种操作，它会产生输出，但不会修改对象自身的状态。由于在执行某个特定操作时不会发生任何修改，因此该操作被称为无副作用。<ins>不可变`Value Object`的所有方法都必须是`Side‑Effect‑Free Function`，因为它们不能破坏`Value`的不可变性。你可以将这一特性视为不可变性的组成部分，二者紧密相关</ins>。不过，我更倾向于将它单独列为一个独立特性，因为这样做可以突出`Value Objects`的一个巨大优势。否则，我们可能只会把`Values`看作属性容器，从而忽略该模式中最强大的一个方面。

---
➜**函数式方式（The Functional Way）**

函数式编程语言通常会强制实施这一特性。事实上，纯函数式语言只允许无副作用行为（Side-Effect-Free Behavior），要求所有闭包只能接收和产生不可变的`Value Objects`。

---

<ins>Bertrand Meyer 将`Side‑Effect‑Free Functions`描述为他的命令–查询分离原则（Command‑Query Separation，简称 CQS）中的 *查询 (Query)* 方法，Martin Fowler 在 [[Fowler, CQS](../bibli.md#fowler-cqs)] 中也讨论过这一原则。查询方法是向对象询问问题的方法。根据定义，向对象提问不应该改变问题的答案。</ins>

下面是`FullName`类型使用`Side‑Effect‑Free Functions`来生成一个新的、用于替换自身的值的示例：

```Java
FullName name = new FullName("Vaughn", "Vernon");

// later...

name = name.withMiddleInitial("L");
```

这会产生与 [可替换性](#可替换性) 一节中讨论的示例相同的结果，但表达方式更具可读性和表现力。这个`Side‑Effect‑Free Functions`的实现如下：

```Java
public FullName withMiddleInitial(String aMiddleNameOrInitial) {

    if (aMiddleNameOrInitial == null) {
        throw new IllegalArgumentException(
            "Must provide a middle name or initial.");
    }

    String middle = aMiddleNameOrInitial.trim();

    if (middle.isEmpty()) {
        throw new IllegalArgumentException(
            "Must provide a middle name or initial.");
    }

    return new FullName(
        this.firstName(),
        middle.substring(0, 1).toUpperCase(),
        this.lastName());
}
```

在这个例子中，`withMiddleInitial()` 方法不会修改它自身`Value`的状态，因此是无副作用的。相反，它会创建一个新的`Value`，这个新`Value`由它自身的某些部分和给定的中间名首字母组合而成。这个方法将重要的领域业务逻辑封装在模型内部，而不是让它泄漏到客户端代码中，这正是前面那个例子中可能发生的情况。

---
➜**当`Value`引用`Entity`时**

`Value Object`的方法是否应该被允许修改作为参数传入的`Entity`？即使不明确提出规则，如果这样的方法确实修改了`Entity`，那么它真的是`Side-Effect-Free`的吗？测试这样的方法会容易吗？我认为不容易，或者至少没那么容易。<ins>因此，当`Value`的方法接收一个`Entity`作为参数时，最好让它返回一个结果，由`Entity`根据自己的逻辑自行决定如何修改自身。</ins>

---

尽管如此，这样的设计仍然存在一些问题。举个例子：在这个场景中，Scrum Product 是一个`Entity`，它以某种方式被 BusinessPriority 这个`Value Object`用来计算优先级：

```Java
float priority = businessPriority.priorityOf(product);
```

你看出这里面的问题了吗？你很可能已经得出结论：至少存在一些问题：

- 我想提醒的是，我们在这里迫使这个`Value`不仅依赖于一个 Product，还必须理解这个`Entity`的结构。只要有可能，就应该限制`Value`，使其只依赖并理解它自己的类型以及它自身属性的类型。这虽然并非总能做到，但却是一个值得追求的目标。

- 阅读代码的人无法知道会使用 Product 的哪些部分。表达式不够显式，这会削弱模型的清晰度。如果传递的是 Product 的某个实际属性或派生属性，会好得多。

- 对于本次讨论来说更重要的是：任何接收`Entity`作为参数的`Value`方法，都难以证明它不会导致该`Entity`被修改，从而使该操作更难测试。因此，即使`Value`承诺不会造成修改，也没有人能轻易证明这一点。

基于这一分析，我们尚未在这里真正改善任何东西。<ins>要改变这种情况并让`Value`更健壮，你应该只将`Values`作为参数传递给`Value`的方法。这样你就能达到最高级别的`Side‑Effect‑Free Behavior`。这并不难实现：</ins>

```Java
float priority =
    businessPriority.priority(
        product.businessPriorityTotals());
```

在这里，我们只是让 Product 提供一个 BusinessPriorityTotals `Value`的实例。你可能会认为 priority() 方法不应该返回 float 类型。尤其是当优先级在`Ubiquitous Language`中应该是一个更正式的概念时，使用自定义值类型会更合适。这类设计决策来自于对模型的持续精化。事实上，经过进一步分析，SaaSOvation 团队发现 Product `Entity`本身根本不应该负责计算业务优先级总和。这项职责最终会由一个 [Domain Service (7)](../ch7/0.md) 来承担，你将在那一章看到更好的解决方案。

<ins>如果你决定不设计一个专门的`Value Object`，而是转而使用语言自带的基本值类型（原始类型或其包装类型），那么你可能正在亏待你的模型。你将失去为这个基本值类型赋予`Side‑Effect‑Free Functions`的机会。任何特殊行为都将与值本身分离</ins>。而且，即使你的编程语言允许你通过补丁方式为基本类型添加新行为，这真的能让你捕捉到深层的领域洞察吗？


---
➜**挑战你的假设**

如果你认为某个特定方法无法做到无副作用，而必须修改它所在实例的状态，那么请挑战你的假设。是否存在一种方式，可以通过替换（replacement）而不是修改（mutation）来实现？前面的例子提供了一种非常简单的方法：通过复用现有`Value`的部分内容，并只替换那些明确需要改变的部分，来创建一个新的`Value`。系统中几乎不可能所有对象都是`Value`。有些对象几乎肯定会是`Entities`。请仔细比较`Value`的特征与`Entities`的特征。团队通过适度的思考和讨论，应该能够得出正确的结论。

---

---
SaaSOvation 团队在阅读了 [[Evans](../bibli.md#evans)] 中关于`Side‑Effect‑Free Functions`以及其他`Whole Value`相关内容后，意识到他们应该更频繁地使用`Value Objects`。从那以后，团队逐渐认识到，理解前面所讲的`Value`特性，确实帮助他们在自己的领域中发现了更多更自然的`Value`类型。

---

---
➜**一切都是`Value Object`吗？**

到现在为止，你可能已经开始觉得所有东西看起来都像`Value Object`。这比认为所有东西都是实体`Entity`要好得多。不过，你需要稍微谨慎的地方是：当某些属性确实非常简单，根本不需要任何特殊处理。例如，Booleans 或某些完全独立的数值，它们不需要额外的功能支持，也与同一`Entity`中的其他属性没有关联。这些简单属性本身就是一个有意义的整体（Meaningful Whole）。<ins>即便如此，你就算 “犯个错”，把一个单一属性不必要地包装成一个没有特殊功能的`Value`类型，也仍然比那些从不考虑`Value`设计的人要好。如果你后来发现自己有点过度设计了，也随时可以做一点重构。</ins>

---

#### ▶[下一节](2.md)

---

#### 1

有时`Value Objects`也可以被设计为可变的，但这种需求通常很少见。本书不重点讨论可变`Values`。如果你有兴趣了解何时使用可变`Value`类型，请参见 [[Evans](../bibli.md#evans)] 一书第 [101](../../ddd/ch5/3.md#设计-value-objects) 页的侧栏内容。

#### 2
在某些情况下，像对象关系映射（ORM）或序列化库（用于 XML、JSON 等）这样的框架，可能需要使用 setter 方法来从其序列化形式中重建`Value`的状态。

#### 3
也称为有意义的整体（Meaningful Whole）。
