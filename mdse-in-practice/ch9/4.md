## 9.4 掌握代码生成技术

#### ▶[上一节](3.md)

为应对基于模型的代码生成器实现过程中的复杂性，可采用若干高级技术，下文将对其进行简要说明。

**抽象模板** 。代码生成的图灵测试（参见第 [3](../ch3/0.md) 章）是关键议题。为确保生成的代码获得开发者认可，尤其在仅能进行部分代码生成时，从具体参考示例中抽象代码生成模板已被证明是行之有效的方法。Acceleo 支持将具体参考示例重构为模板。多种重构操作可将示例代码替换为标签。例如，可选取 Java 类的具体名称，将其重构为表达式，表达式则从模型元素中查询名称值。借助此工具支持，可系统性地从示例代码中提取模板，确保开发人员在模板完成后能熟悉其生成的输出结果。

**模板复用** 。当前 M2T 转换语言提供多种功能来结构化与复用转换逻辑。例如，模板可构建为继承树结构，从而实现多态 (polymorphic) 模板调用 —— 即对通用模板的调用将基于模型元素类型，自动分派至最具体的模板。此特性尤为重要，因为元模型中广泛采用类的继承机制来复用功能。因此，模板可被复用并扩展至先前为基类定义的子类，从而避免代码重复。M2T 语言还支持其他特性：通过定义和编织横切关注点来生成代码，或通过覆盖模板（而非继承扩展）来完善完整的转换模块。

**分步骤生成** 。当模型层与代码层存在显著差距时，通过串联转换 (chaining transformations) 将代码生成过程拆分为多个步骤尤为有效。但这会导致啰嗦的 (verbose) 代码生成模板，同时掩盖了最终输出的结构。因此，通过再次运用转换链概念（参见第 [8.4](../ch8/4.md) 节），利用混合的 M2M 与 M2T 转换步骤，采用分而治之 (divide-and-conquer) 原则开发代码生成器，可获得更易读、可复用且易维护的组件。例如，假设需要开发嵌套状态机的代码生成器。若已存在普通 (flat) 状态机生成器，只需提供从嵌套状态机到普通状态机的 M2M 转换，即可复用现有代码生成器。

**将转换逻辑与文本分离** 。复杂计算（如查询输入模型的或复杂字符串运算）应尽可能重构为查询或库，以便在模板中按需导入。由此，最终输出的结构在模板中更清晰可见，先前定义的代码也可在其他模板或代码生成器中复用。

**掌握代码布局** 。代码布局由模板布局决定。例如，当模板包含多个循环和条件时，要精确生成预期布局往往颇具挑战。某些方案如 Xtend 允许将代码美化器作为代码生成器的后处理单元。除后处理外，为更精准控制输出布局，M2T 语言提供多项特性：如忽略模板中换行符的操作符、 在循环中通过生成特殊符号来分隔元素等。

**注意模型/代码同步问题**。虽然在采用部分代码生成策略时，保护区域的概念非常有用，但可能存在手工添加的代码没有放在新生成代码中（下次生成器运行时）正确位置的情况。例如，假设示例中的 *Tutorial* 类被重命名为 *Talk* 。这意味着在下次生成器运行时，会生成新的 Java 类，但手工添加到（现已过时的） *Tutorial* 类的代码可能丢失。尤其当我们采用 “类名+方法名” 作为受保护区域 ID 时，若在模型层同时对类名和方法名进行重命名重构，将导致模型与代码无法同步。若采用此类重构操作，最终将生成包含 “新” 操作的新 Java 文件，此时需将该操作的实现代码从旧 Java 文件复制到新类中，并手动适配新命名。某些 M2T 转换框架（如 Acceleo）至少会报告手工添加的代码无法与新生成代码合并的情况。此时，可通过代码生成器生成的日志文件，查阅未被整合到新代码版本的行数汇总。

<ins>这个简单的例子很好地说明了，在模型上应用重构操作且已使用部分代码生成时，必须格外谨慎。处理此类重构的可行方案包括：在模型层执行重构操作，在代码层执行对应重构，待重构传播完成后再运行代码生成器</ins>。另一种方案是直接采用模型元素的内部 ID（该 ID 不可变且由建模工具自动分配）来定义受保护区域的 ID。前一种方案需投入更多精力构建模型/代码同步支持机制，而后者则无需额外工作量。但前者具备强大适应性，可自动将先前手工添加的代码适配至新模型版本，而后者则无法实现此功能。

#### ▶[下一节](5.md)
