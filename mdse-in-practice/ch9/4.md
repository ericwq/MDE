## 9.4 掌握代码生成技术

#### ▶[上一节](3.md)

# TODO

为应对基于模型的代码生成器实现过程中的复杂性，可采用若干高级技术，下文将对其进行简要说明。

抽象模板。代码生成的图灵测试（参见第3章）是关键议题。为确保生成的代码获得开发者认可——尤其在仅能进行部分代码生成时——从具体参考示例中抽象代码生成模板已被证明是行之有效的方法。Acceleo支持将具体参考示例重构为模板。通过多种重构操作可将示例代码替换为标签。例如，可选取Java类的具体名称，将其重构为从模型元素查询名称值的表达式。借助此工具支持，可系统性地从示例代码中提取模板，确保开发人员在模板完成后能熟悉其生成的输出结果。

模板复用。当前M2T转换语言提供多种功能来结构化与复用转换逻辑。例如，模板可构建为继承树结构，从而实现多态模板调用——即对通用模板的调用将根据模型元素类型自动分派至最具体的模板。此特性尤为重要，因为元模型中广泛采用类继承机制来复用功能。因此，模板可被复用并扩展至先前为基类定义的子类，从而避免代码重复。M2T语言还支持其他特性：通过定义和编织横切关注点来生成代码，或通过覆盖模板（而非继承扩展）来完善完整的转换模块。

分步生成。当模型层与代码层存在显著差距时，通过串联转换将代码生成过程拆分为多个步骤尤为有效。这导致冗长的代码生成模板，同时掩盖了最终输出的结构。因此，通过再次运用转换链概念（参见第8.4节），采用混合M2M与M2T转换步骤的分治法开发代码生成器，可获得更易读、可复用且易维护的组件。例如，假设需要开发嵌套状态机的代码生成器。若已存在平面状态机生成器，只需提供从嵌套状态机到平面状态机的M2M转换，即可复用现有代码生成器。

将转换逻辑与文本分离。复杂计算（如输入模型的查询或字符串运算）应尽可能重构为查询或库，在模板中按需调用。由此，最终输出的结构在模板中更清晰可见，先前定义的代码也可在其他模板或代码生成器中复用。

掌握代码布局。代码布局由模板布局决定。例如，当模板包含多个循环和条件时，要精确生成预期布局往往颇具挑战。某些方案（如Xtend）允许将代码美化器作为代码生成器的后处理单元。除后处理外，为更精准控制输出布局，M2T语言提供多项特性：如忽略模板中换行符的运算符、通过循环生成特殊符号分隔元素等。

注意模型/代码同步问题。虽然在采用部分代码生成策略时，保护区域的概念非常有用，但可能存在手动添加的代码无法在下次生成器运行时置于新生成代码正确位置的情况。例如，假设示例中的Tutorial类被重命名为Talk。这意味着在下次生成器运行时，虽然会生成新的Java类，但手动添加到（现已过时的）Tutorial类的代码可能丢失。尤其当我们采用“类名+方法名”作为受保护区域ID时，若在模型层同时对类名和方法名进行重命名重构，将导致模型与代码无法同步。若采用此类重构操作，最终将生成包含“new”操作的新Java文件，此时需将该操作的实现代码从旧Java文件复制到新类中，并手动适配新命名。某些M2T转换框架（如Acceleo）至少会报告手动添加的代码无法与新生成代码合并的情况。此时可通过代码生成器生成的日志文件，查阅未被整合到新代码版本的行数汇总。

这个简单示例充分说明：当模型已应用部分代码生成时，实施重构操作必须格外谨慎。处理此类重构的可行方案包括：在模型层执行重构操作，在代码层执行对应重构，待重构传播完成后再运行代码生成器。另一种方案是直接采用模型元素的内部ID（该ID不可变且由建模工具自动分配）来定义受保护区域的ID。前一种方案需投入更多精力构建模型/代码同步支持机制，而后者则无需额外工作量。但前者具备强大适应性——可自动将先前手动添加的代码适配至新模型版本，而后者则无法实现此功能。

#### ▶[下一节](5.md)
