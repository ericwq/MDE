## 9.1 模型驱动代码生成的基础

#### ▶[上一节](0.md)

代码生成在软件工程中有着悠久的历史，可追溯至高级编程语言诞生的早期阶段——那时首批编译器应运而生。然而，编译器 [2](../bibliography.md#2) 中的代码生成目标与 MDE 存在本质差异：编译器将源代码转换为机器代码，而 MDE 则将模型转化为源代码。因此，MDE 代码生成技术是在现有编程语言的编译器基础上构建的。

开发基于模型的代码生成器时，以下三个问题至关重要：

- **生成多少内容？** 核心问题在于代码的哪些部分可从模型自动生成。是实现 *所有 (full)* 代码生成还是仅 *部分 (partial)* 生成？在此语境下，部分生成具有多重含义：首先，可能指应用程序某一层（横向或纵向）完全由代码生成，而另一层则完全由人工开发；此外，也可能指某一层仅部分生成，缺失部分需人工补全。部分代码生成也可指模型层级：仅对模型特定部分进行代码生成，其余部分则不受代码生成器影响，需手动实现。
- **生成什么？** 明确生成何种源代码至关重要。生成的代码应尽可能简洁，同时谨记第 [3](../ch3/0.md) 章提及的代码生成器图灵测试，强调生成的代码需具备可读性。因此在开发代码生成器时，应充分利用现有高级编程语言、API 及框架，避免重复造轮子。选择正确的编程范式是首要决策。此处的宗旨是：能够表示系统的生成的代码量越少越好。
- **如何生成？** 明确代码生成要求后，即代码生成器需实现的 *功能 (what)* ，如生成哪些部分及使用哪个目标语言，还需决定 *如何 (how)* 实现这些要求。正如本章后续所述，可采用多种语言从模型生成代码，涵盖 GPL 到 DSL。

代码生成可被描述为从高抽象层级模型向低层级产出物的垂直转换。MDE 的优势主要源于这种垂直转换。因此，代码生成器必须弥合抽象层级的鸿沟，实现方式可多样化。

### 弥合模型与代码的鸿沟

当使用建模语言构建模型时，通常无法完整表达底层技术的所有细节，因为 MDE 的核心目标正是抽象化技术细节。例如，假设你在特定领域定义 UML 类图时，需引入若干 String 类型的属性。若该类图需部署在数据存储空间受限的环境中，你可能需要为这些属性设定长度限制，而非采用最大可能的 String 长度。因此，正如 MDA 方法所示，后续可能需要附加信息，才能实现拥有可执行软件的目标。

信息必须通过以下方式之一提供：由建模者使用模型增强技术（如特定技术的 UML 配置文件）；在代码生成中应用约定优于配置 (convention-over-configuration) 原则；或在模型层保留规范开放性，在代码层填充细节。第一种方法需要投入更多精力为代码生成准备模型，允许你调整衍生实现的若干细节。第二种方法无需这种额外投入，但衍生实现的优化只能在代码层面直接进行。当然，采用混合策略，即先基于约定优于配置进行生成，再通过模型增强进行人工调整，也是一种可行方案。第三种方法仅生成部分实现，开发者需在代码层面完成补充。此处需特别注意：同时存在可修改的模型与代码会违背单一信息源 (single source of information) 原则。可采取的对策包括：在代码中设置所谓受保护区域 (protected area) ，代码中的特殊区域，该区域中需手工编写代码，或（引入）其他显式扩展点供开发者填充，例如：先生成基类，通过用户自定义类扩展基类，实现模型层级无法指定的功能。

#### ▶[下一节](2.md)
