## 10.4 模型版本控制

#### ▶[上一节](3.md)

版本控制系统（Version Control Systems, VCS）是软件开发基础设施的重要组成部分，其功能包括：(i) 存储软件工件的演变历史；(ii) 支持多开发者并行协作；(iii) 管理不同开发分支 [13](../bibliography.md#13) 。完成上述任务均需追踪受控工件的变更记录。针对第二、三项任务，还需检测同一工件并行演进版本间的冲突，并通过冲突解决机制获得最终整合版本。当合并软件工件的两个并行修改版本时，冲突往往难以避免。版本控制系统正是用于检测、管理和解决此类冲突的工具。

显然，程序员离不开 Subversion（SVN）或 Git 这类 VCS 系统。然而直到最近，建模者仍被迫忍受这种困境。如今形势正在改变，模型版本控制技术已开始涌现 [12](../bibliography.md#12) 。

传统的基于文本的版本控制系统将模型视为普通文本文件，因而忽视了模型的图结构本质。以下是一个简单示例，展示了在模型版本控制背景下，模型与其基于文本的表示形式 [52](../bibliography.md#52) 之间存在的阻抗失配现象：假设存在一个包含两个状态和一条转换的基本状态机图（参见 [Fig 10.2](#fig-102) 中的 V0）。当两名建模者同时编辑该模型时，将产生两个不同版本（参见 V1' 与 V1" ）。左侧版本中，仅保留第二个状态，表明第一个状态及转换已被删除；右侧版本中，则保留初始图的所有元素，并新增了一条转换。若采用基于 XMI 序列化层级的文本版本控制系统，此场景下会生成一个自动合并版本 V1，其将包含状态 B 及指向空处的悬空转换。

#### Fig 10.2
![Fig 10.2](../img/fig10.2.png)

*Fig 10.2: 状态机的基于文本的版本控制*

文本型 VCS 产生此合并结果的原因在于：在文本层面，该系统仅对被修改或删除的行进行推理。在本例中，文本比较算法通过将左侧版本（V1’）与原始版本对比，可能检测到首行与末行已被删除。同理，当右侧版本与原始版本比较时，新增行会被检测到。然而，当仅将模型解释为文本行以检测新增转换所引用的状态 A 已被同时删除时，系统不会提供任何支持，这种情况必然会导致冲突。


本例表明基于文本的模型的序列化可实现版本控制，但仍可能存在未检测到的隐患。因此需要针对模型的专门的版本控制支持，来识别潜在冲突。值得庆幸的是，已有若干优秀的模型版本控制工具问世（其中部分工具基于前文介绍的模型比较工具构建）。

- EMFStore 项目 <sup>[15](0.md#15)</sup> 是 Eclipse 官方项目，致力于提供能追踪所存储模型的版本历史的模型仓库。该项目遵循 SVN 中熟知的检出/更新/提交 (check-out/update/commit) 交互范式，并提供交互式模型合并界面，用于解决（两名用户对模型元素进行重叠修改时的）冲突。同时集成了模型迁移功能（在对元模型进行修改后更新其对应的模型）。
- AMOR（Adaptable Model Versioning）项目 <sup>[16](0.md#16)</sup> 提供针对 EMF 模型的版本控制方法与技术，提供了多种冲突检测、可视化与解决方案。特别是通过模型注释 (annotation) 技术，将合并冲突以图形化语法形式在模型中可视化呈现。
- CDO 模型仓库（参见第 [10.2](2.md) 节）在数据库层面上为模型提供了有限的分支与合并支持。
- Epsilon 合并语言 (Epsilon Merging Language) <sup>[17](0.md#17)</sup> 是一种用于合并同构或异构模型的基于规则的语言。通过关联的 Epsilon Comparison Language （参见第 [10.3](3.md) 节），可自动生成待合并模型间的对应关系。

需注意，上述工具仅对模型信息进行版本控制，通常不包含其图形表现形式（如图形布局）。一种可能性是同样对图形信息进行版本控制，这种信息在许多图形模型编辑器中也以模型的形式呈现。然而当不同建模者并行修改图形时，仍需探讨在此情境下何种操作应视为变更或冲突。例如：将类向右移动两英寸是否构成变更？这是否与另一项 "变更" （将该类向下略微移动）产生冲突？图版本控制仍是待解决问题。

#### ▶[下一节](5.md)
