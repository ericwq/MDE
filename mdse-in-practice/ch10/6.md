## 10.6 全局模型管理

#### ▶[上一节](5.md)

迄今为止，我们已探讨了多种技术与工具，用于在互联的 (connected) 建模生态系统中，管理模型生命周期的不同方面。<ins>管理此类生态系统的整体问题被称为全局模型管理（Global Model Management, GMM）。这也是国际倡议 “建模语言全局化，用于异构建模的一个语言工作台，以支持协同开发” 背后的核心挑战</ins>。<sup>[20](0.md#20)</sup>

<ins>管理生态系统（作为一个整体的）关键要素在于，将所有相关模型的信息及它们之间的关联关系，存放在一个位置（即模型）。该模型被称为 *超级模型 (megamodel* [23](../bibliography.md#23) 。超级模型不仅包含项目工件（如基于 MDSE 的模型，也可能包含配置文件等非 MDSE 工件），还包含其管理所需的关系及其他相关的元数据（如工件的实际类型、标识符、位置等）。从这个意义上说，超级模型可被视为元数据仓库，其中存储着模型及其关联关系的精确表示，并为用户提供多种用途的支持。</ins>

<ins>超级模型（本质上）是普通模型，其独特之处在于其模型元素本身即是其他模型。作为模型，超级模型必须符合 (conform to) 元模型。作为 Eclipse AM3（AtlanMod MegaModel Management）<sup>[21](0.md#21)</sup> 超级建模框架 (megamodeling framework) 的一部分，已实现了一个超级模型的具体元模型示例</ins>。 [Fig 10.4](#fig-104) 展示了该元模型的子集。如图所示，超级模型的元素类型可包含模型、元模型、转换以及与 MDSE 项目相关的任何其他建模元素。

#### Fig 10.4
![Fig 10.4](../img/fig10.4.png)

*Fig 10.4: 超级模型的元模型：AM3 案例*

<ins>其重要优势在于：作为模型，超级模型可使用与其他模型相同的工具进行操作</ins>。不过也存在专门的模型管理工具。<ins>特别值得一提的是 MoScript <sup>[22](0.md#22)</sup> ，一种文本 DSL，同时是超级模型无关平台，用于访问和操作超级模型中表示的建模工件</ins>。MoScript 支持编写查询语句从仓库检索模型、模型检查、调用模型服务（如转换），并能将新生成的模型注册进入仓库。MoScript 脚本可描述并自动化复杂建模任务，涉及若干对模型集的连续操作。<ins>因此 MoScript 语言可用于建模任务和/或工作流自动化，以及任何可想象的批量模型处理任务。MoScript 架构包含可扩展的元数据引擎，用于解析和访问建模工件，并调用不同转换工具的服务。</ins>

例如，假设需要用 .NET 重新生成我们的 Java 系统。若已存在 java2dNet 转换，我们就可将该转换应用于存储库中的所有 Java 模型以生成全部对应的 .NET 模型。以下代码片段展示了 MoScript 如何自主/自动完成此任务： 脚本首先从存储库中筛选出符合 Java 元模型的模型集，随后从存储库获取 java2dNet 转换，通过 *applyTo* 操作将该转换应用于每个 Java 模型。此示例的结果是一组 TransformationRecord 元素，其中包含新生成 .NET 模型。

```dotnet
let javaModels : Collection(Model) =
  Model::allInstances()->select(m | m.conformsTo.kind ='Java') in
let java2dNet : Transformation =
  Transformation::allInstances()->any(t | t.identifier ='java2dNet') in
javaModels->collect(jm | java2dNet.applyTo(Sequence{jm}))
```
在幕后，MoScript 会在待转换模型的元模型之间进行类型检查，并通过查询超级模型来验证元模型与转换的兼容性。通过相同方式，MoScript 确定应由哪个转换引擎执行转换。最终，MoScript 将模型、元模型及转换规则发送至转换引擎执行。生成的模型可持久化存储于模型仓库，供后续检视，甚至可通过串联 MoScript 脚本再次转换。

#### ▶[下一节](7.md)
