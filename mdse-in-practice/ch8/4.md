## 8.4 掌握模型转换

#### ▶[上一节](3.md)

本节介绍高级转换技术方面的概览和参考引用，这些技术特别适用于处理实际场景中模型转换的复杂性。

### 8.4.1 分而治之：模型转换链

转换过程可能极为复杂，需要将其本身建模并拆分为不同步骤，以避免形成单一庞大的转换流程。转换链是（建模）协调 (orchestration) 不同模型转换的首选技术。通过编排语言定义转换链，可实现建模转换步骤的顺序：这意味着定义首次转换的输入模型，选择初始转换，其输出模型随即成为后续转换的输入模型，如此循环往复。更复杂的转换链还可包含条件分支、循环及其他控制结构。

转换链不仅能将待开发的转换拆分为多个模块，还能基于已定义转换构建复杂模型转换。此外，聚焦特定方面的 小型转换可提升复用性。

模型转换链可在知名文本构建语言（如 ANT）中定义，ATL 同样支持此方式 <sup>[16](0.md#16)</sup> 。然而，也存在专门的语言，通过使用 UML 活动图语言的子集来图形化建模转换链此外，例如 Wires* <sup>[17](0.md#17)</sup> 方法可直观编排 ATL 转换。

转换的编排直接引向大规模建模的研究领域。我们在第 [10](ch10/0.md) 章讨论模型管理任务时将重返此议题，这些任务可被定义为转换链。

### 8.4.2 热点：万物皆模型，包括转换

迄今为止，我们一直将转换视为操作模型的手段，但实际上转换本身也可视为模型，因为它们是转换元模型的实例。例如，ATL 转换可被表达为 ATL 元模型（该元模型定义了 ATL 语言的抽象语法）的实例，因此本质上就是一种模型。

这种统一性可以让我们重用工具与方法，即创建模型的工具，同样可用于构建转换模型，并构建出理论上可递归应用的框架：转换的转换本身也能被进一步转换。此外，转换便于操作也至关重要。正如普通模型可通过转换进行创建、修改和扩展，转换模型本身也可通过所谓的 *高阶转换（Higher Order Transformation , HOT）* [67](../bibliography.md#67) 实现创建、修改等操作。这意味着我们可以编写以模型转换为输入、并/或生成模型转换为输出的转换。例如，可编写一个HOT自动重构一组转换以优化其内部结构。另一个示例是为转换添加日志方面（的功能）。

### 8.4.3 超越批处理：增量与延迟转换

迄今我们主要探讨了异位模型转换的一种执行策略：读取完整输入模型，通过应用所有匹配转换规则从零生成输出模型。此类执行常被称为 *批处理 (batch)* 转换。然而在两种场景下，替代执行策略更具优势：(i) 已存在前次转换生成的输出模型作为给定的输入模型；(ii) 消费者仅需输出模型的一部分，如后续转换或建模编辑器。针对前者可采用 *增量 (incremental)* 转换 [42](../bibliography.md#42)，而后者则需关注 *延迟 (lazy)* 转换 [68](../bibliography.md#68)。 *（译注：是不是两者的顺序放反了？）*

增量转换顾名思义，并非每次执行时都将完整的输入模型转换为全新创建的输出模型。相反，它仅关注当前输入模型与上次转换运行所用输入模型的差异，从而最小化输出模型的变更范围。例如，当输入模型新增元素时，仅执行匹配该新元素的规则来更新输出模型。这种转换策略具有双重优势：(i) 通常部分转换比完整转换模型状态更高效；(ii) 对输出模型所做的变更得以保留。

延迟转换由目标模型的访问操作驱动。正如采用延迟求值 (lazy evaluation) 的编程语言 —— 仅在特定时刻按需计算表达式 —— 所示，目标模型同样可能仅在请求时生成。例如，假设输出模型的唯一消费者是另一项转换。若第二个转换从未访问首个转换生成的目标模型中某些元素，那么，显然预先创建这些元素就是浪费时间，因为没人会读取它们。另一情形是模型元素的特定特征仅在第二次转换执行尾声才被访问。因此，用于（在第一次转换中）计算该特征的绑定评估可延迟至此时才执行，而非预先计算。这种转换策略具有双重优势：(i) 如同增量转换，在特定场景下能提升转换执行效率；(ii) 支持转换超大规模模型（甚至是无限模型）。

### 8.4.4 双向模型转换

迄今为止，我们所探讨的模型转换语言均为单向转换，除在提及 ATL 替代方案时短暂讨论过 QVT 和 TGG 外。近十年来，研究者致力于开发双向模型转换语言 [33](../bibliography.md#33) , [65](../bibliography.md#65)，这类语言具有两大特征：(i) 在指定转换时不强制限定转换方向；(ii) 支持多种执行模式，如 *转换 (transformation)* 、*集成 (integration)* 和 *同步 (synchroniaztion)* 。

转换模式进一步细分为正向转换与反向转换。正向转换实现源模型到目标模型的转换，反向转换则执行相反操作。此类转换也可通过两个单向转换实现，但使用双向转换的显著优势在于其构造（特性）确保了正/反向转换的一致性 [33](../bibliography.md#33) 。

集成模式假设源目标模型已存在，并计算模型元素间的对应关系 (correspondences) 。这意味着：不会为某一模型中匹配到的转换规则生成对应元素，集成模式检查目标模型中是否存在预期元素，该元素会在转换模式下应生成。若源模型中每个匹配项都能在目标模型中找到对应元素（反之亦然），则视为两模型完全集成。这充分说明双向转换可被视为模型对 (a pair of models) 必须满足的约束条件：当所有约束成立（即已建立所有对应关系）时，两模型即实现完全集成。

同步模式以源模型、目标模型为起点，并通过集成模式计算对应关系。更精确地说，当两个模型未完全集成时，同步模式旨在通过应用部分预定义转换规则实现完全集成。例如，当某个模型新增元素时，可能发现该元素存在额外的规则匹配。此时同步模式将执行这个额外的规则，在另一边创建相应的元素。另外一种情况是是：在某一模型中删除元素导致匹配失效，此时另一边的元素也需同步删除。

#### ▶[下一节](ch9/0.md)
