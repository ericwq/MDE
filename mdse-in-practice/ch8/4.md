## 8.4 掌握模型转换

#### ▶[上一节](3.md)

本节介绍高级转换技术方面的概览和参考引用，这些技术特别适用于处理实际场景中模型转换的复杂性。

### 8.4.1 分而治之：模型转换链

<ins>转换过程可能极为复杂，需要对其自身进行建模并拆分为不同步骤，以避免形成单一巨大 (monolithic) 的转换。转换链通过编排语言来定义，使我们能够对转换的顺序步骤进行建模</ins>。这意味着定义首次转换的输入模型，选择初始转换，其输出模型随即成为后续转换的输入模型，如此循环往复。更复杂的转换链还可包含条件分支、循环及其他控制结构。

转换链不仅能将待开发的转换拆分为多个模块，还能基于已定义转换构造复杂模型转换。此外，拥有聚焦特定方面的小型转换可提升复用性。

模型转换链可用知名文本构建语言（如 ANT）来定义，这对 ATL 来说也是可能的 <sup>[16](0.md#16)</sup> 。然而，也存在专门的语言，通过使用 UML 活动图语言的子集，来图形化建模转换链，例如 Wires* <sup>[17](0.md#17)</sup> 方法可图形化编排 ATL 转换。

转换的编排直接导致大规模建模的研究领域。我们在第 [10](ch10/0.md) 章会重返此议题，届时主要讨论模型管理任务，这些任务可被定义为转换链。

### 8.4.2 HOT：万物皆模型，包括转换

<ins>迄今为止，我们一直将转换视为操作模型的手段，但实际上，转换本身也可被视为模型，因为它们是转换元模型的实例</ins>。例如，ATL 转换可被表达为 ATL 元模型（该元模型定义了 ATL 语言的抽象语法）的实例，因此可被视为模型。

这种统一性使我们能够复用工具和方法，即用于创建模型的工具同样可用于创建转换模型，并由此构建出理论上可递归应用的框架，因为转换的转换本身也能被进一步转换。此外，转换便于操作也至关重要。正如普通模型可通过转换进行创建、修改和扩展，转换模型本身也可通过所谓的 *高阶转换（Higher Order Transformation , HOT）* [67](../bibliography.md#67) 实现创建、修改等操作。这意味着我们可以编写以模型转换为输入、并/或生成模型转换为输出的转换。例如，可编写一个HOT自动重构一组转换以优化其内部结构。另一个例子是为转换添加日志方面（的功能）。

### 8.4.3 超越批处理：增量与延迟转换

迄今我们主要探讨了异位模型转换的一种执行策略：读取完整的输入模型，通过应用所有匹配的转换规则，从零生成输出模型。此类执行常被称为 *批处理 (batch)* 转换。然而在两种场景下，替代执行策略更具优势：(i) 已存在前次转换运行生成的输出模型作为给定的输入模型；(ii) 消费者仅需输出模型的一部分，如后继转换或建模编辑器。针对前者可采用 *增量 (incremental)* 转换 [42](../bibliography.md#42)，而后者则需关注 *延迟 (lazy)* 转换 [68](../bibliography.md#68)。

<ins>增量转换顾名思义，并非每次执行时都将完整的输入模型转换为全新创建的输出模型。相反，它仅关注当前输入模型与上次转换运行所用输入模型的差异，从而最小化输出模型的变更</ins>。例如，当输入模型新增元素时，仅执行匹配该新元素的规则来更新输出模型。这种转换策略具有双重优势：(i) 通常变更的转换比模型完整状态的转换更高效；(ii) 对输出模型所做的变更得以保留。

<ins>延迟转换由对目标模型的访问操作驱动。正如采用延迟求值 (lazy evaluation) 的编程语言所示，延迟求值仅在仅在特定时间点计算所需的表达式，目标模型同样可仅在请求时生成</ins>。例如，假设输出模型的唯一消费者是另一项转换。若第二个转换从未访问首个转换生成的目标模型中的某些元素，那么，显然预先创建这些元素就是浪费时间，因为没人会读取它们。另一情形是模型元素的某些特征仅在第二次转换执行尾声才被访问。因此，用于（在第一次转换中）计算该特征的绑定评估可延迟至此时才执行，而非预先计算。这种转换策略具有双重优势：(i) 如同增量转换，在特定场景下能提升转换执行效率；(ii) 支持转换超大规模模型（甚至是无限模型）。

### 8.4.4 双向模型转换

迄今为止，我们所探讨的模型转换语言均为单向转换，除了在提及 ATL 替代方案时，短暂讨论过 QVT 和 TGG 外。近十年来，研究者致力于开发双向模型转换语言 [33](../bibliography.md#33) , [65](../bibliography.md#65)，这类语言具有两大特征：(i) 在指定转换时不强制限定转换方向；(ii) 支持多种执行模式，如 *转换 (transformation)* 、*集成 (integration)* 和 *同步 (synchronization)* 。

<ins>转换模式进一步细分为正向转换与反向转换。正向转换实现源模型到目标模型的转换，反向转换则执行相反操作</ins>。此类转换也可通过两个单向转换实现，但使用双向转换的显著优势在于，其正向与反向转换之间的一致性由构造本身所保证 [33](../bibliography.md#33) 。

<ins>集成模式假定源模型和目标模型已给定，并计算源模型与目标模型元素之间的对应关系</ins>。这意味着：不会为某一模型中匹配到的转换规则生成对应元素，集成模式检查目标模型中是否存在预期元素（该元素会在转换模式下应生成）。若源模型中每个匹配项都能在目标模型中找到对应元素（反之亦然），则视为两模型完全集成。这充分说明双向转换可被视为模型对 (a pair of models) 必须满足的约束条件：当所有约束成立（即已建立所有对应关系）时，两模型即实现完全集成。

<ins>同步模式以源模型、目标模型为起点，并通过集成模式计算对应关系。更精确地说，当两个模型未完全集成时，同步模式旨在通过应用部分预定义转换规则实现完全集成</ins>。例如，当某个模型新增元素时，可能发现该元素存在额外的规则匹配。此时同步模式将执行这个额外的规则，在另一边创建相应的元素。另外一种情况是是：在某一模型中删除元素导致匹配失效，此时另一边的相应元素也需同步删除。

#### ▶[下一节](../ch9/0.md)
