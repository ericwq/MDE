## 7.4 具体语法开发

#### ▶[上一节](3.md)

建模语言通常仅被视为图形化语言。然而，正如存在图形化编程语言一样，建模语言同样可以定义文本语法。因此，现有框架目前支持两种具体语法：图形化具体语法（Graphical Concrete Syntaxes, GCS）和文本化具体语法（Textual Concrete Syntaxes, TCS）。

如前所述，抽象语法开发过程由多项 OMG 标准提供支持。而针对具体语法定义，目前仅有一项 OMG 标准可供使用，即 Diagram Definition （DD）<sup>[14](0.md#14)</sup> ，该标准允许定义图形化具体语法。但在当前 UML 标准文档 [57](../bibliography.md#57) 中的 UML 元模型定义中，具体语法仅通过所谓的符号表（一列用于建模概念，一列用于其符号元素）及若干示例进行展示。UML 未提供更正式的具体语法定义。这与传统基于文本的语言工程方法形成鲜明对比 —— 后者通常采用 EBNF 语法等形式化手段定义具体语法。

<ins>正式定义具体语法将开启运用复杂技术的大门，例如自动生成编辑器，从而实现对具体语法中构件的操作</ins>。拥有此类编辑器是模型在实践中高效应用的必要条件。若缺乏具体语法的形式化定义，其编辑器只能通过手工实现，这需要投入大量精力，导致构建 MDE 环境的成本居高不下。

值得庆幸的是，现已出现若干新兴框架，它们不仅提供专门语言来形式化描述建模语言的具体语法，还包含生成组件，能够生成用于在具体语法中可视化与操作模型的编辑器。

#### Fig 7.9
![Fig 7.9](../img/fig7.9.png)

*Fig 7.9: 可视化符号表示法：引入建模概念的符号*

文本语言通过字符序列编码信息（如多数编程语言），而图形语言则利用图形（及文本）元素的空间布局编码信息 [51](../bibliography.md#51) 。因此文本表示是一维的，而多数图形语言支持二维表示。例如：在 UML 图中，每个模型元素都位于二维建模画布上。

无论具体语法如何设计，其定义是通过将元模型描述的建模概念映射至视觉表现形式 —— 换言之，可视化符号表示法 (visual notation) 为建模概念引入了符号（参见 [Fig 7.9](#fig-79) ）。<ins>本章使用 “可视化符号表示法” 一 词概括文本符号与图形符号</ins>。拥有建模概念的符号后，我们既可仅用文本，也可通过在图中排列图形元素来可视化模型。

下文将详细阐述为建模语言定义可视化符号表示法的不同方法，并演示如何为 sWML 开发 GCS 和 TCS。

### 7.4.1 图形化具体语法（GCS）
在深入探讨如何为元模型定义 GCS 之前，我们首先阐述 GCS 的构成要素。

**图形语言的构成要素** 。GCS 必须定义以下元素：

- *图形符号 (graphical symbols)* ，例如线条、区域、完整图形，如 SVG 图形，，以及用于表示文本信息的标签，如可视化建模元素名称；
- *组合规则 (compositional rules)* ，用于定义这些图形符号的嵌套与组合方式，如可视化模型元素名称的标签需居中显示于代表该模型元素的矩形区域内；
- 图形符号与抽象语法元素的 *映射 (mapping)* ，用于规定何种图形符号对应何种建模概念，如特定模型元素类型通过矩形可视化。

当前图形建模编辑器采用建模画布，支持在二维网格中定位模型元素。每个元素分配有 x,y 坐标，通常代表图形符号左上角的位置。模型元素主要以图的形式排列在建模画布中，该图称为图表 (diagram)，即模型的图形化视图。需注意并非所有模型信息都会实际显示在建模画布中，部分属性值仅在附加属性视图中可见且可编辑。此设计一方面允许访问和编辑模型元素的所有属性，另一方面避免因信息过载而影响图表的可读性。

[Fig 7.10](#fig-710) 展示了通用 GCS 元模型的局部片段。首先，该元模型规定图由节点、边、隔间 (compartment) 和标签四类元素构成。这些元素类型足以满足大多数建模语言需求。例如，节点与边是构成 *图 (graphs)* 的重要概念，分别通过形状 (shapes) 与线条表示。隔间通常以形状 (shapes) 表示，常用于嵌套元素，如图表是 *嵌套图 (nested graphs)* 。最后，标签用于为节点和边添加附加信息，如图表也是 *属性图 (attributed graphs)* 。

#### Fig 7.10
![Fig 7.10](../img/fig7.10.png)

*Fig 7.10: 通用 GCS 元模型*

为阐明建模概念与符号间的关联，我们建立了抽象语法与具体语法元素的映射关系。通常，抽象语法元素，如类、属性、关联，会被映射至具体语法元素 <sup>[15](-.md#15)</sup> 。对于图表本身，通常选取元模型的包含层次结构的根元素作为根节点，该节点可直接或间接容纳所有其他模型元素。其余元模型类通常映射为节点，关联则根据类型映射为：包含关联映射为隔间，非包含关联映射为边。属性映射为节点内部的标签，或位于节点/边附近的标签。某些情况下类也可映射为边。假设元模型中存在表示泛化关系的类。此时该类实例将以边的形式呈现，其类引用用于确定边的源节点与目标节点。

若重新审视 [Fig 7.7](3.md#fig-77)（第 [99](3.md#fig-77) 页）—— 该图展示了 sWML 具体语法中引用建模示例的抽象语法 —— 我们可发现建模概念与 sWML 符号间的映射关系。例如，我们立即看到 *link* 对象以边的形式呈现，而 *Page* 对象则作为节点显示，并根据类型附加特定图标。

**GCS 开发方法论** 。在演示如何为 sWML开发 GCS 之前，我们先概述三种主要 GCS 开发方法。

**映射为中心的 GCS** 。该类方法提供专用建模语言，来描述 GCS，以及从具体语法到抽象语法的映射。Graphical Modeling Framework（GMF）即采用此方法 <sup>[16](0.md#16)</sup> 。语言工程师需定义：(i) `.gmfgraph` 模型，用于定义可视化模型元素的图形元素（参见 [Fig 7.10](#fig-710) 中的 *Figure* 类与 *DiagramElement* 类）； (ii) `.gmftool` 模型，用于指定工具面板 <sup>[17](0.md#17)</sup> ，特别是哪些图标对应生成哪些模型元素；最后，(iii) `.gmfmap` 模型，实际定义元模型中定义的元素与 `.gmfgraph` 模型中定义的图形元素之间的映射关系（参见 [Fig 7.10](#fig-710) 中的 *Mapping* 类）。生成器将这三类模型转换为代码，从而实现功能完整的图形化建模编辑器。<ins>需注意 GMF 也可视为带代码生成组件的 DSML。因此，图形化建模编辑器的开发正是通过应用 MDE 技术实现的</ins>。

此外，OMG Diagram Definition（DD）也采用此方法，利用 MOF 和 QVT 技术；最后，Sirius <sup>[18](0.md#18)</sup> 同样在抽象语法元素与具体语法元素之间建立映射关系。

**注释为中心的 GCS** 。此类方法直接在元模型上标注元素可视化方式的相关信息。该方法由 EuGENia 支持 <sup>[19](0.md#19)</sup> 。 EuGENia 框架通过提供高级文本 DSML，使我们能够为基于 Ecore 的元模型添加注释 GCS 信息。这些注释信息由专用转换组件用于生成前述 GMF 模型。因此，EuGENia 本身采用模型驱动方法，通过复用 GMF 作为转换目标来生成图形化编辑器。EuGENia 提供的高级注释隐藏了 GMF 的复杂性，降低了创建基于 GMF 的编辑器初始版本的门槛。虽然 EuGENia 作为图形建模编辑器开发的启动器非常有用，但它的作用不仅限于此，还可一直应用到图形编辑器的最终完善版本。

**API 为中心的 GCS** 。另有一种方法是通过专用编程框架，直接在代码层面实现图形建模编辑器。

Graphiti 采用此方法 <sup>[20](0.md#20)</sup> ，为构建图形建模编辑器提供了强大的编程框架。语言工程师需扩展 Graphiti 提供的基类，来定义建模语言的具体语法。该框架特别提供了类集合：用于开发 *pictogram model*，描述可视化与具体语法元素层级（类似于 `.gmfgraph` 模型），以及用于建立抽象语法与具体语法元素映射关系的 *link model*（参见 GMF 的 `.gmfmap` 模型）。

另一主角是 Graphical Editing Framework （GEF）<sup>[21](0.md#21)</sup>，它为图形编辑器提供底层功能支持。因此 GEF 被视为其他 GCS 的基础架构，而非直接实现图形建模编辑器的框架。尽管后者是可行的，但需投入更多开发。

最后，GMF 还提供了强大的建模编辑器编程 API，但建议从 GMF 模型入手，仅在代码层面优化生成的编辑器。因此 GMF 被归类为映射中心的方法，尽管也可从零开始编程构建建模编辑器。

**用 EuGENia 为 sWML 定义 GCS** 。为向读者展示具体案例的 GCS 定义方法，我们采用 EuGENia 开发 sWML 的 GCS。选择 EuGENia 是因为它能在适当抽象层级引入 GCS 方法。EuGENia 中可提供多种注解机制，用于为基于 Ecore 的元模型指定 GCS。下文将首先列举主要注释，随后将其应用于 sWML：

- *图表 (Diagram)* ：作为抽象语法表示模型的根元素，即（直接或间接）包含所有其他元素的元素，完美契合建模画布的表示需求。EuGENia 通过 `Diagram` 注释在元模型中标记该类。
- *节点 (Node)* ：元模型类的实例通常以节点形式呈现于图中。因此 EuGENia 允许使用 `Node` 注解标记类。该注释具备多项特性：可选定被注释类的属性作为节点标签，配置边框样式、颜色等布局信息，并支持使用外部图形（如 SVG 格式）或用 EuGENia 预定义图形（如矩形/椭圆）渲染节点。
- *链接 (Link)* ：`Link` 注释适用于类，以及应以边形式呈现于图中的非包含引用。该注释提供设置链接样式的属性，如是否为虚线，以及链接端装饰属性（如是否链接端应该以箭头形式可视化）。对于添加 `Link` 注释的类，其作为链接端点的源引用和目标引用，必须从该类可用的引用中选择。
- *隔间 (Compartment)* ：包含引用可用此注解标记。它定义该包含引用将创建一个隔间，用于容纳符合引用类型的模型元素。
- *标签 (Label)* ：属性可添加 `Label` 注解，表示这些属性将作为节点或链接名称的补充标签显示。

我们现在讨论 sWML 的 GCS 定义中的两个片段（参见 [Fig 7.11](#fig-711) 和 [Fig 7.12](#fig-712) ）。对元模型进行注释，如图上方所示，使我们能够将模型呈现为图下方所示的示意图。

第二个片段（参见 [Fig 7.11](#fig-711) ）包含三处注释。首处注释用于选定表示图的元素，因此 *WebModel* 类（sWML 的根元素）添加了 `Diagram` 注释。此外，该图需支持在画布内放置超文本层，故必须添加 `Compartment` 注释以实现对 *hypertext* 的包含引用。该注释表明可在图中添加超文本层。最后，超文本层应以矩形节点形式呈现，故为 *HypertextLayer* 类添加 `Node` 注释并设置 *figure* 属性。若未指定标签，建模元素默认采用类型名称作为标签。

第二个片段（参见 [Fig 7.12](#fig-712) ）规定Page类的实例应以矩形22呈现，其中页面名称作为矩形标签显示。这通过与图7.11中HypertextLayer类的Node注释类似的方式实现。Link类的实例应作为连接页面节点间的边进行可视化。因此，Link类被添加了Link注释。为实现正确可视化需定义若干属性，例如链接目标的引用来源（默认链接源为其容器，本例适用此规则）以及链接的具体呈现形式。本例中，链接目标端的终点应以箭头形式呈现，以指示超链接的导航方向。请注意：若未定义特殊规则，GCS对超类的定义同样适用于其子类（即图7.12中也定义了上下文链接与非上下文链接的图形表示法）。

带 EuGENia 注释的元模型

#### Fig 7.11
![Fig 7.11](../img/fig7.11.png)

*Fig 7.11: GCS 摘录 1：图、隔间与节点注释*

带 EuGENia 注释的元模型

#### Fig 7.12
![Fig 7.12](../img/fig7.12.png)

*Fig 7.12: GCS 摘录 2：节点与链接注释*


#### ▶[下一节](5.md)
