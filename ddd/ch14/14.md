## 转变

#### ▶[上一节](13.md)

像建模和设计的其他方面一样，关于 [BOUNDED CONTEXTS](1.md) 的决策并非不可更改。不可避免地，你会遇到许多需要改变最初关于 [BOUNDED CONTEXTS](1.md) 之间边界和关系的决策的情况。一般来说，拆分`CONTEXTS`相对容易，但合并它们或改变它们之间的关系则具有挑战性。我将描述一些具有代表性的、虽困难但重要的变更。这些转变通常大到无法在一次重构甚至一次项目迭代中完成。因此，我概述了将这些转变分解为一系列可管理步骤的实施计划。当然，这些只是指导方针，你需要根据具体情况和事件进行调整。

### 合并`CONTEXTS`：[SEPARATE WAYS](9.md) → [SHARED KERNEL](5.md) 

翻译开销过高。重复过于明显。合并
 [BOUNDED CONTEXTS](1.md) 的动机众多。这并非易事。为时未晚，但需要耐心。

即使最终目标是通过 [CONTINUOUS INTEGRATION](2.md) 完全合并为单一 [CONTEXT](../glossary.md#context) ，也请先转向 [SHARED KERNEL](5.md) 模式。

1. 评估初始状态。在开始统一两个`CONTEXTS`之前，务必确保它们在内部已实现统一。

2. 建立流程规范。需明确代码共享机制及模块命名规则。 [SHARED KERNEL](5.md) 代码必须至少每周进行一次集成，且必须配备测试套件。在开发任何共享代码前，务必完成此项配置。（测试套件初始为空，因此应能轻松通过！）

3. 选择某个小型子领域作为起点，该子领域需同时存在于两个`CONTEXTS`中，但不属于 [CORE DOMAIN](../ch15/1.md) 。首次合并旨在建立流程规范，因此最好选用简单、通用性强且非关键性的对象。审查现有的集成与翻译内容。选择正在翻译的对象具有双重优势：既能基于经过验证的翻译版本起步，又能有效精简翻译层级。

此时，您拥有两个处理相同子领域的模型。合并主要有三种方法： 你可以选择其中一个模型，并将另一个 [CONTEXT](../glossary.md#context) 重构为兼容状态。这种决策可以整体实施，即系统性地替换某个 [CONTEXT](../glossary.md#context) 的模型，同时保持作为整体开发的模型的一致性。或者你可以逐个部分选择，最终可能融合两者的优势（但需注意避免最终变成一团乱麻）。

第三种选择是寻找一个新的模型，该模型可能比原有的任何一个都更深入，能够承担两者的职责。

4. 组建由两到四名开发人员组成的联合团队（成员来自两个团队），共同制定子领域的共享模型。无论模型如何推导，都必须详细敲定。这包括艰苦的工作：识别同义词，并映射任何尚未翻译的术语。该联合团队将为模型设计一套基础测试方案。

5. 来自任一团队的开发人员承担模型实现任务（或调整现有代码以供共享），具体落实细节并确保其正常运行。若开发人员在模型实施过程中遇到问题，则重新召集步骤 3 中的团队成员，共同参与概念层面的必要修订工作。

6. 各团队的开发人员承担与新 [SHARED KERNEL](5.md) 集成的任务。

7. 移除不再需要的翻译。

此时，您将拥有一个非常小的 [SHARED KERNEL](5.md) ，并已建立维护机制。在后续项目迭代中，重复步骤 3 至 7 以实现更多共享。随着流程逐步完善且团队信心增强，您可逐步处理更复杂的子领域，包括同时处理多个子领域，或涉及 [CORE DOMAIN](../ch15/1.md) 的子领域。

注：当您处理模型中更具领域特异性的部分时，可能会遇到两种模型分别遵循不同用户群体专业术语的情况。除非实现了深度模型的突破，使您能够运用一种超越两种专业术语的通用语言，否则明智的做法是暂缓将这些术语合并到 [SHARED KERNEL](5.md) 中。[SHARED KERNEL](5.md) 的优势在于：既能保留 [SEPARATE WAYS](9.md) 的部分优势，又能兼得 [CONTINUOUS INTEGRATION](2.md) 的部分益处。

以下是合并至 [SHARED KERNEL](5.md) 的指导原则。在实施前，请考虑一种替代方案，该方案可满足本次转换所涉及的部分需求。若明确偏好其中一种模型，可考虑在不进行集成的情况下向其迁移。无需共享公共子域，只需通过重构应用程序使其调用更优选 [CONTEXT](../glossary.md#context) 的模型，并按该模型需求进行增强，从而系统性地将子领域的全部责任从一个 [BOUNDED CONTEXT](1.md) 转移至另一个。如此既消除了冗余，又避免了持续集成的开销。更受青睐的 [BOUNDED CONTEXT](1.md) 最终可能（但非必然）完全接管，此时效果等同于合并。在过渡期（可能相当漫长或无限期），这种模式将呈现 [SEPARATE WAYS](9.md) 的常规优缺点，需权衡其与 [SHARED KERNEL](5.md) 方案的利弊。

### 合并`CONTEXTS`： [SHARED KERNEL](5.md) → [CONTINUOUS INTEGRATION](2.md)

若您的 [SHARED KERNEL](5.md) 正在扩展，您可能会被完全统一两个 [BOUNDED CONTEXTS](1.md) 的优势所吸引。这不仅是解决模型差异的问题，更将改变团队结构，最终影响团队成员的沟通语言。

请从人员和团队的准备工作开始着手。

1. 确保每个团队都独立建立了 [CONTINUOUS INTEGRATION](2.md) 所需的所有流程（如共享代码所有权、频繁集成等）。协调两个团队的集成流程，使所有成员采用统一的工作方式。

2. 开始在团队间轮换成员。这将形成一批通晓两种模型的储备人才，并逐步促进两个团队成员的融合。

3. 明确每个模型的独立提炼过程。（参见 [第 15 章](../ch15/0.md) ）

4. 此时应具备足够的信心，开始将核心领域合并到 [SHARED KERNEL](5.md) 中。此过程可能需要多次迭代，有时需要在新共享部分与尚未共享部分之间建立临时转换层。进入 [CORE DOMAIN](../ch15/1.md) 合并阶段后，应全力加速推进。这是个高开销且易出错的阶段，需尽可能缩短周期，优先于多数新开发任务。但切勿超负荷推进。

要合并`CORE`模型，您有几种选择。可以保留其中一个模型，并将另一个模型修改为与其兼容；或者创建子领域的全新模型，并让两个上下文都适应使用它。需注意：若两个模型原本针对不同的用户需求进行定制，您可能需要保留两个原始模型的专业功能。这种情况下，就需要开发更深层的模型来取代原有模型。开发深度统一模型难度极高，但若决心实现两个`CONTEXTS`的完全融合，则无法再保留多方言模式。此举将显著提升最终模型与代码的集成清晰度，但需警惕此举是否会损害满足用户特殊需求的能力。

5. 随着 [SHARED KERNEL](5.md) 的扩展，将集成频率逐步提升至每日，最终实现 [CONTINUOUS INTEGRATION](2.md) 。

6. 当 [SHARED KERNEL](5.md) 逐渐涵盖原有两个 [BOUNDED CONTEXTS](1.md) 时，团队将演变为：要么形成一个大型团队，要么拆分为两个小型团队。这些团队共享代码库并进行 [CONTINUOUS INTEGRATION](2.md) ，且成员间频繁流动。

### 淘汰旧系统

凡事都有终结之时，即便是老旧的计算机软件也不例外。但淘汰过程不会自动发生。这些旧系统往往与业务流程及其他系统深度交织，彻底剥离可能耗时数年。所幸，淘汰工作不必一蹴而就。

可能性实在太多，我在此只能略作探讨。但会讨论一个常见场景：某企业日常使用的旧系统近期新增了若干现代化系统，这些系统通过 [ANTICORRUPTION LAYER](8.md) 与旧系统进行通信。

首要步骤之一是制定测试策略。对于新系统中的新功能，应编写自动化单元测试；但淘汰旧系统会带来特殊的测试需求。部分组织会在一段时间内让新旧系统并行运行。

在任何给定的迭代周期中：

1. 识别遗留系统中特定功能模块，可在单次迭代周期内将其整合至首选系统之一。

2. 确定 [ANTICORRUPTION LAYER](8.md) 所需新增功能。

3. 实施开发。

4. 部署上线。

有时可能需要花费多次迭代来编写与一个可以逐步废弃的遗留单元等效的功能，但仍应将新功能规划为小的、迭代大小的单元，只是在部署时等待多次迭代。

部署是另一个存在过多变量而无法面面俱到的环节。若能将这些微小的渐进式变更直接推送至生产环境，对开发工作固然理想，但通常仍需组织大规模发布。用户必须接受新软件的使用培训，有时还需成功完成并行运行阶段，诸多后勤问题亟待解决。

当系统最终投入实际运行后：

5. 识别 [ANTICORRUPTION LAYER](8.md) 中任何多余的部分并予以移除。

6. 考虑剔除遗留系统中现已废弃的模块，尽管这可能难以实现。讽刺的是，遗留系统设计得越完善，越容易逐步淘汰。但设计糟糕的软件难以分阶段拆解。或许可以暂时忽略这些闲置部分，待后续系统完成淘汰后再整体关闭。

反复进行此操作。旧系统应逐步减少对业务的介入，最终将能看到隧道尽头的曙光，并彻底关闭旧系统。与此同时，随着不同组合方案增减系统间的相互依赖性，[ANTICORRUPTION LAYER](8.md) 将随之收缩或膨胀。在其他条件不变的情况下，应优先迁移那些能缩减 [ANTICORRUPTION LAYER](8.md) 规模的功能模块。但其他因素往往占据主导地位，某些过渡阶段可能不得不忍受复杂的转换过程。

### `OPEN HOST SERVICE` → `PUBLISHED LANGUAGE`

您一直通过一系列临时协议与其他系统进行集成，但随着更多系统需要接入，维护负担日益加重，或者交互关系变得难以理解。您需要通过 [PUBLISHED LANGUAGE](../ch14/11.md) 来规范系统间的交互关系。

1. 若存在行业标准语言，应进行评估并在可行时采用。

2. 若无现成标准或预发布语言可用，则需首先完善系统中将作为主机的 [CORE DOMAIN](../ch15/1.md) （参见 [第 15 章](../ch15/0.md) ）。

3. 尽可能以 [CORE DOMAIN](../ch15/1.md) 为基础构建交换语言，采用XML等标准交换范式。

4. 将新语言发布给所有协作参与方（至少）。

5. 若涉及新系统架构，亦需同步发布。

6. 为每个协作系统构建转换层。

7. 完成切换。

这时，额外的协作者应该能够以最小的干扰加入。

请记住，[PUBLISHED LANGUAGE](../ch14/11.md) 必须保持稳定，但随着你不断进行无休止的重构，你仍然需要有修改主机模型的自由。因此，不要将交换语言与主机模型等同起来。将它们保持在接近的状态可以减少翻译开销，你也可以选择让你的主机成为一个 [CONFORMIST](7.md)。但应保留增强翻译层并在成本效益权衡有利时进行分化的权利。

项目负责人应基于功能集成需求及开发团队间的关系来定义 [BOUNDED CONTEXTS](1.md) 。一旦明确界定并严格遵循 [BOUNDED CONTEXTS](1.md) 与 [CONTEXT MAP](3.md)，逻辑一致性便能得到保障。相关沟通问题至少会被暴露出来，从而得以解决。

然而，有时模型上下文，无论是人为划定的还是自然形成的，会被错误地应用于解决系统内部逻辑矛盾之外的问题。团队可能会发现，大型 [CONTEXT](../glossary.md#context) 的模型过于复杂，难以整体把握或彻底分析。无论是出于选择还是偶然，这往往导致将`CONTEXTS`拆解为更易管理的片段。这种碎片化会导致机遇的流失。此时值得审慎评估：在广阔 [CONTEXT](../glossary.md#context) 中建立大型模型的决策是否合理？若组织或政治层面无法维持整体性，若实际已呈现碎片化趋势，则应重绘蓝图，重新定义可维系的边界。但若大型 [BOUNDED CONTEXTS](1.md) 能有效满足紧迫的集成需求，且在模型自身复杂性之外仍具可行性，那么拆分 [CONTEXT](../glossary.md#context) 未必是最佳解。

在做出这种牺牲之前，还应考虑其他使大型模型可处理的方法。接下来的两章将聚焦于通过应用两个更广泛的原则，蒸馏与大规模结构，来管理大型模型内的复杂性。

#### ▶[下一节](../ch15/0.md)
