## 有界上下文：`BOUNDED CONTEXT`

#### ▶[上一节](0.md)

<img src="../img/part4.1.png" width="80%" />

*细胞之所以能够存在，是因为其细胞膜界定了内部与外部的边界，并决定了哪些物质能够通过。*</br>

在大型项目中，多种模型可以共存，在许多情况下这运行良好。不同的模型适用于不同的情境。例如，你可能需要将新软件与一个外部系统集成，而这个系统不受你的团队控制。这样的情况对于每个人来说可能都很清楚，因为它是一个模型不适用的独特情境，但其他情况可能会更加模糊和混乱。在本章开头的故事中，两个团队正在为同一个新系统开发不同的功能。他们是在处理同一个模型吗？他们的意图是至少共享他们所做的一部分，但没有明确的界限告诉他们哪些内容可以共享，哪些不能共享。他们也没有建立流程来维护共享模型或者快速发现差异。只有在系统行为突然变得不可预测之后，他们才意识到模型已经发生了偏离。

即使是单个团队也可能最终形成多种模型。沟通可能中断，导致对模型的理解产生微妙冲突。旧代码往往反映了早期对模型的构想，而这种构想与当前模型存在细微差异。

<ins>众所周知，不同系统的数据格式存在差异，需要进行数据转换，但这仅是问题的机械层面。更根本的是两个系统内在模型之间的差异。</ins>当差异并非来自外部系统，而是存在于同一代码库内部时，这种差异就更难被察觉。然而，这种情况在所有大型团队项目中都普遍存在。

<ins>**任何大型项目中都存在多种模型。然而当基于不同模型的代码被整合时，软件便会变得漏洞百出、不可靠且难以理解。团队成员间的沟通也随之混乱。人们常常无法明确某个模型在何种情境下 *不应* 被应用。**</ins>

当运行中的代码出现故障时，混乱的根源终将暴露无遗，但问题的症结其实始于团队的组织方式和成员的协作模式。因此，要厘清模型的上下文，必须同时审视项目本身及其最终产出物（代码、数据库结构等）。

一个模型适用于特定的 *上下文* 。上下文可能是代码的某一部分，或者某个特定团队的工作。对于在头脑风暴会议中发明的模型，其上下文可能仅限于那次特定的对话。本书中在示例中使用的模型的上下文，是该示例部分及其后的相关讨论。模型的上下文就是必须满足的一组条件，以便能够说模型中的术语具有特定的含义。

为着手解决多模型问题，我们需要明确定义特定模型的范围，即作为软件系统中一个有限部分，在此范围内单一模型将适用并尽可能保持统一。该定义必须与团队组织结构相协调。

因此：

<ins>**明确定义模型适用的上下文。在团队组织、应用特定部分的使用，以及代码库和数据库模式等物理表现方面明确设定边界。严格保持模型在这些边界内的一致性，但不要被边界之外的问题分散注意力或感到困惑。**</ins>

[BOUNDED CONTEXT](../glossary.md#bounded-context) 限定了特定模型的适用范围，使团队成员能够清楚地、共同地理解哪些内容必须保持一致，以及它与其他 [CONTEXTS](../glossary.md#bounded-context) 的关系。在该 [CONTEXT](../glossary.md#bounded-context) 中，应努力保持模型的逻辑统一，但无需担心其在该范围之外的适用性。在其他 [CONTEXTS](../glossary.md#bounded-context) 中，则使用其他模型，并在术语、概念和规则，以及 [UBIQUITOUS LANGUAGE](../ch2/1.md) 的方言上存在差异。通过明确划定边界，可以保持模型的纯洁性，从而在其适用范围内保持强大。同时，当关注点转向其他 [CONTEXTS](../glossary.md#bounded-context) 时，也能避免混淆。跨边界的集成必然涉及一定的转换，这可以通过明确分析来处理。

---
**[BOUNDED CONTEXTS](../glossary.md#bounded-context) 并非 [MODULES](../ch5/5.md)**

该问题有时会混淆，但这些是不同动机的不同模式。诚然，当两组对象被识别为构成不同模型时，它们几乎总是被放置在独立的 [MODULES](../ch5/5.md) 中。这样做确实提供了不同的命名空间（对不同 [CONTEXTS](../glossary.md#bounded-context) 至关重要）以及某种界定。

但 [MODULES](../ch5/5.md) 同样用于组织单一模型内的元素，并不必然意味着要分离 [CONTEXTS](../glossary.md#bounded-context) 。[MODULES](../ch5/5.md) 在 [BOUNDED CONTEXT](../glossary.md#bounded-context) 中创建的独立命名空间，反而会增加识别意外模型碎片化的难度。

---

#### 示例：预订上下文

某航运公司正在开展内部项目，旨在开发一款用于货物预订的新应用程序。该应用程序将基于对象模型构建。请问该模型适用的 [BOUNDED CONTEXT](../glossary.md#bounded-context) 是什么？要回答这个问题，我们必须审视项目当前的实际状况。请注意，此处考察的是项目 *现状* ，而非理想状态。

一个项目团队正在开发预订应用程序本身。他们无需修改模型对象，但所构建的应用程序必须能够显示和操作这些对象。该团队是模型的消费者。模型在应用程序（其主要消费者）内部是有效的，因此预订应用程序处于有效范围内。

已完成的预订必须传递至旧版货物追踪系统。前期已决定新模型将脱离旧版架构，因此旧版货物追踪系统位于边界之外。新模型与旧版系统间的必要转换工作应由旧版维护团队负责。该转换机制不受模型驱动，不属于 [BOUNDED CONTEXT](../glossary.md#bounded-context) 范畴（实为边界本身组成部分，将在 [CONTEXT MAPS](3.md) 中详述）。将转换机制置于 [CONTEXT](../glossary.md#bounded-context) 之外（不基于模型）是合理的。要求旧系统团队实际使用模型并不现实，因其核心工作本就超出当前 [CONTEXT](../glossary.md#bounded-context) 范围。

负责该模型的团队处理每个对象的整个生命周期，包括持久化。由于该团队掌控着数据库方案 (schema)，他们刻意保持对象关系映射的简单性。换言之，模式 (schema) 由模型驱动，因此始终处于可控范围内。

另一支团队正在开发货轮航程调度模型及应用程序。调度团队与预订团队最初是同步组建的，两者都曾计划构建统一的系统。虽然两支团队偶尔会进行非正式协调并共享对象，但缺乏系统性协作机制。他们 *并未* 在相同的 [BOUNDED CONTEXT](../glossary.md#bounded-context) 中工作。这种情况存在风险，因为双方并未意识到各自构建的是独立模型。除非建立管理流程，否则整合过程中必将出现问题（本章后文将讨论的 [SHARED KERNEL](5.md) 可能是理想方案）。但首要之务是认清现状：两组人员处于不同 [CONTEXT](../glossary.md#bounded-context) 中，在调整完成前应停止代码共享尝试。

<ins>这个 [BOUNDED CONTEXT](../glossary.md#bounded-context) 由系统中所有受此特定模型驱动的组件构成：模型对象、持久化模型对象的数据库方案 (schema) 以及预订应用程序。</ins>主要在此 [CONTEXT](../glossary.md#bounded-context) 中工作的有两个团队：建模团队和应用程序团队。需要与遗留追踪系统交换信息，遗留系统团队在建模团队的配合下，主要负责此边界处的数据转换工作。预订模型与航程调度模型之间尚无明确定义的关系，建立这种关系应成为团队的首要任务之一。在此期间，双方需格外谨慎地共享代码或数据。

那么，定义这个 [BOUNDED CONTEXT](../glossary.md#bounded-context) 究竟带来了什么？对于在 [CONTEXT](../glossary.md#bounded-context) 内工作的团队而言：清晰度。这两个团队清楚必须遵循同一模型，他们在这种认知下做出设计决策，并注意可能出现的裂痕。对于外部团队而言：自由度。他们无需在灰色地带徘徊，既不用遵循同一模型，却又隐约感到应当如此。但在此案例中最具体的收获，或许是意识到预订模型团队与航程调度团队之间非正式数据共享的风险。为规避问题，他们必须认真权衡共享的成本效益，并建立保障机制。除非所有人都明确模型边界的界限，否则这些措施难以落实。

🌼🌼🌼

当然，边界是特殊的存在。[BOUNDED CONTEXT](../glossary.md#bounded-context) 与其邻域之间的关系需要精心维护。[CONTEXT MAPS](3.md) 勾勒出整个疆域，呈现 [CONTEXTS](../glossary.md#bounded-context) 及其关联的全局视图，而若干模式则定义了 [CONTEXTS](../glossary.md#bounded-context) 间不同关系的本质。通过 [CONTINUOUS INTEGRATION](2.md) 流程，可在 [BOUNDED CONTEXT](../glossary.md#bounded-context) 内保持模型的统一性。

但在深入探讨这些问题之前，模型统一性被破坏时会呈现何种景象？如何识别概念分歧 (splinters)？

### 识别 [BOUNDED CONTEXT](../glossary.md#bounded-context) 中的分歧

<ins>诸多迹象可能预示着未被察觉的模型差异。最明显的莫过于代码接口不匹配的情况。更微妙的是，异常行为往往是潜在问题的征兆。</ins>通过自动化测试的 [CONTINUOUS INTEGRATION](2.md) 流程能有效捕捉此类问题。但早期预警信号通常表现为语言表述的混乱。

将不同模型的元素组合会引发两类问题： *概念重复 (duplicate concepts)* 与 *假同源词 (false cognates)* 。<ins>概念重复意味着存在两个模型元素（及相应的实现）实际代表相同概念。</ins>每当信息变更时，都需在两处进行转换更新。当新知识导致其中一个对象发生变更时，另一个对象也必须重新分析并同步修改。但现实中这种重新分析往往缺失，最终形成遵循不同规则、甚至包含不同数据的两个概念版本。更糟糕的是，团队成员不仅要掌握两种实现相同功能的方式，还需理解它们之间的所有同步机制。

<ins>假同源词虽稍显罕见，却更具隐蔽危害性。当两人使用相同术语（或实现对象）时，他们以为在讨论同一事物，实则不然。</ins>本章开篇的例子（两种不同业务活动都称为`Charge`）是典型案例，但冲突可能更为微妙，当两个定义实际上关联领域中同一方面，却被略微不同地概念化时。假同源词会导致开发团队互相踩踏代码、数据库出现奇怪矛盾，以及团队内部沟通混乱。 *假同源词* 一词通常用于自然语言领域。例如英语学习者掌握西班牙语时常误用 *embarazada* 一词，它并非表示 “尴尬”，而是指 “怀孕”。哎呀。

当你发现这些问题时，你的团队将需要做出决策。你可能希望将模型重新整合并优化流程，以防止分化。或者，这种分化可能是因为一些团队出于正当原因想将模型朝不同方向发展，而你可能决定让他们独立发展。如何处理这些问题是本章剩余模式所讨论的内容。

#### ▶[下一节](2.md)
