## 如何建模不那么显而易见的概念类型

#### ▶[上一节](1.md)

面向对象范式引导我们寻找并创造特定类型的概念。事物，即使是诸如 “应计 (accruals)” 这般抽象的概念，构成了大多数对象模型的核心，而这些事物所执行的操作则构成另一部分。这些正是入门级面向对象设计书籍所提到的 “名词与动词”。但模型中同样可以明确呈现其他重要概念类别。

在开始接触对象时，有三个类别对我而言并不明显。随着对每个类别的理解加深，我的设计也变得愈发精炼。

### 显式约束

约束构成了模型概念中特别重要的类别。它们往往隐含地出现，而将其显式表达出来能极大提升设计质量。

有时约束条件会在对象或方法中找到天然的归宿。一个`Bucket`对象必须保证其不变量：其容纳的元素数量不得超过其容量。

#### Figure 9.10
![Figure 9.10](../img/fig9.10.png)

像这样的简单不变量可以通过在每个可能改变内容的操作中使用条件逻辑来强制实现。
```java
class Bucket {
  private float capacity;
  private float contents;

  public void pourIn(float addedVolume) {
    if (contents + addedVolume > capacity) {
      contents = capacity;
    } else {
      contents = contents + addedVolume;
    }
  }
}
```
这种逻辑如此简单，规则显而易见。但你很容易想象，在更复杂的类中，这个约束条件可能会被忽略。让我们将其提取为一个独立的方法，并赋予一个清晰明确地表达约束意义的名称。
```java
class Bucket {
  private float capacity;
  private float contents;

  public void pourIn(float addedVolume) {
    float volumePresent = contents + addedVolume;
    contents = constrainedToCapacity(volumePresent);
  }

  private float constrainedToCapacity(float volumePlacedIn) {
    if (volumePlacedIn > capacity) return capacity;
      return volumePlacedIn;
  }
}
```
这两种代码版本都实现了约束，但第二种与模型之间的关联更为明确（这正是 [MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design) 的基本要求）。这条极其简单的规则在原始形式下尚可理解，但当需要执行的规则变得复杂时，它们就会像任何隐含概念那样，开始淹没其所适用的对象或操作。将约束拆解为独立方法后，我们得以赋予其揭示意图的名称，使约束在设计中显性化。此刻它已成为可供讨论的名词实体。此方法还为约束预留了扩展空间——若规则更复杂，其方法体长度极易超过调用方（此处为`pourIn()`方法）。如此既能保持调用方的简洁专注，又允许约束在必要时提升复杂度。

这种独立的方法为约束提供了成长空间，但许多情况下约束根本无法舒适地容纳于单一方法中。即便方法保持简洁，它也可能调用对象核心职责所不需要的信息。这条规则或许在现有对象中根本找不到合适的归宿。

以下是一些表明约束正在扭曲其宿主对象设计的警示信号：
1. 评估约束需要不符合对象定义的数据。
2. 相关规则出现在多个对象中，迫使非同源对象之间进行重复或继承。
3. 大量设计与需求讨论围绕约束展开，但在实现过程中，这些约束却被隐藏在过程化代码中。

当约束模糊了对象的基本职责，或当约束在领域中显著存在却未在模型中突出体现时，可将其提取为显式对象，甚至建模为一组对象及其关联关系。（关于此主题的深入，半正式探讨，可参阅 *The Object Constraint Language: Precise Modeling with UML* [Warmer and Kleppe 1999](../references.md#warmer-1999) ）

### 示例：审查：超额预订政策

在 [第 1 章](../ch1/0.md) 中，我们探讨了航运业的常见做法：预订量比运输能力超出 10%。（经验表明，这种超额预订能弥补最后一刻的取消，确保船舶几乎满载启航。）

在图表和代码中，通过添加一个代表该约束的新类，明确了`Voyage`与`Cargo`之间关联的约束。

#### Figure 9.11
![Figure 9.11](../img/fig9.11.png)
*Figure 9.11：为显性策略而重构的模型*

要查看完整示例中的代码及推导过程，请参见第 17 页。*TODO linke to where?*

### 流程作为领域对象

首先明确一点：我们 *不* 希望将过程 (procedures) 作为模型的核心要素。对象的本质在于封装过程 (procedures)，使我们能够专注于其目标或意图。

此处所指的是领域中存在的流程 (processes)，这些流程必须在模型中得到体现。当这类流程出现时，往往会导致对象设计显得笨拙。

本章第一个示例描述了一个负责货物路由的航运系统。这种路由流程具有业务意义。[SERVICE](../glossary.md#service) 正是将此类流程显式表达的一种方式，同时仍能封装极其复杂的算法。

当存在多种执行流程的方式时，另一种方法是将算法本身或其关键部分独立封装为对象。流程的选择便转化为这些对象之间的选择，每个对象代表一种不同的`STRATEGY`。（ [第 12 章](../ch12/0.md) 将深入探讨领域中`STRATEGIES`的使用。）

区分哪些流程应当显式化、哪些流程应当隐藏的关键很简单：这是领域专家会讨论的内容，还是仅仅属于计算机程序的机制组成部分？

<ins>约束与流程是模型概念中的两大范畴，在面向对象语言编程时往往不易被察觉，但一旦将其视为模型元素加以考量，便能显著优化设计方案。</ins>

<ins>某些有用的概念类别范围更为狭窄。本章将以一个更为具体却相当常见的概念收尾。`SPECIFICATION`提供了一种简洁的表达方式，能够将特定类型的规则从条件逻辑中抽离出来，使其在模型中明确呈现。</ins>

我与 Martin Fowler 合作开发了 `SPECIFICATION`（ [Evans and Fowler 1997](..//references.md#fowler-1997) ）。这个概念看似简单，但在应用和实现上却非常微妙，因此本节包含了大量细节。在 [第 10 章](../ch10/0.md) 中会有更多讨论，届时该模式将得到扩展。在阅读接下来的模式初步解释后，你可能会想先浏览 [应用和实现`SPECIFICATIONS`](#应用和实现specifications) 一节，直到你真正尝试应用该模式时再仔细阅读。

### `SPECIFICATION`

![Figure 9.11b](../img/fig9.11b.png)

在各类应用中，布尔测试方法往往是微小规则的组成部分。只要它们足够简单，我们便能通过测试方法处理，例如`anIterator.hasNext()`或`anInvoice.isOverdue()`。在`Invoice`类中，`isOverdue()`中的代码本质上是评估规则的算法。例如：
```java
public boolean isOverdue() {
  Date currentDate = new Date();
  return currentDate.after(dueDate);
}
```
但并非所有规则都如此简单。在同一个`Invoice`类中，另一条规则`anInvoice.isDelinquent()`可能首先需要检测该`Invoice`是否逾期，但这仅仅是开始。关于宽限期的政策可能取决于客户账户的状态。部分逾期 (delinquent) 发票需发送二次催缴通知，另一些则应移交催收机构。客户付款记录、不同产品线的内部政策……当海量规则评估代码涌现时，`Invoice`作为付款请求的本质将迅速被淹没。该类还将衍生出各种依赖关系，牵扯到那些根本不支持其基本含义的领域类和子系统。

此时，为挽救`Invoice`类，开发者常会将规则评估代码重构到应用层（本例中为账单催收应用）。如今规则已完全脱离领域层，留下一个无法体现业务模型内在规则的僵化数据对象。这些规则本应驻留在领域层，却无法融入被评估的对象（此处即`Invoice`）。更糟的是，评估方法因充斥条件语句而臃肿不堪，导致规则难以理解。

采用逻辑编程范式的开发者会以不同方式处理这种情况。此类规则将被表达为 *谓词*。谓词是评估结果为 “true” 或 “false” 的函数，可通过 “AND” 和 “OR” 等运算符组合以表达更复杂的规则。借助谓词，我们能显式声明规则并将其应用于`Invoice`。可惜我们并非身处逻辑范式之中。

目睹此景，人们尝试以对象形式实现逻辑规则。其中有些尝试极为精妙，有些则显稚嫩；有些雄心勃勃，有些则务实稳健；有些最终价值非凡，有些则被弃如敝屣，沦为失败的实验。少数尝试最终导致项目脱轨。有一点很明确：尽管这个想法极具吸引力，但在对象中完全实现逻辑仍是一项艰巨的任务。（毕竟，逻辑编程本身就是一种完整的建模与设计范式。）

<ins>**业务规则往往难以归属于任何显而易见的`ENTITIES`或`VALUE OBJECTS`，其多样性与组合方式更可能淹没领域对象的基本含义。但将规则移出领域层则更为糟糕，因为此时领域代码将不再表达模型本身。**</ins>

<ins>**逻辑编程提供了称为“谓词”的独立可组合规则对象概念，但通过对象完整实现该概念较为繁琐。该概念过于通用，其传达的意图不如更专业的设计明确。**</ins>

幸运的是，我们无需完全实现逻辑编程就能获得显著效益。大多数规则都属于少数特殊情况。我们可以借鉴谓词 (predicates) 的概念，创建专门用于评估布尔值的对象。那些失控的测试方法将自然地扩展为独立对象——它们本质上是微型真值测试，可被提取为独立的 [VALUE OBJECT](../glossary.md#value-object) 。这种新对象能评估其他对象，判断谓词对该对象是否成立。

#### Figure 9.12
![Figure 9.12](../img/fig9.12.png)

换言之，新对象是一种 *规范 (specification)* 。`SPECIFICATION` 对另一个对象的状态施加约束，该对象可能存在也可能不存在。它有多种用途，但最能体现其基本概念的是：`SPECIFICATION` 可用于检测任何对象是否满足指定条件。

因此：

<ins> **为特殊用途创建显式的谓词式`VALUE OBJECTS`。`SPECIFICATION`是一种谓词，用于判定对象是否满足某些条件。** </ins>

许多`SPECIFICATIONS`都是简单的专用测试，如逾期发票示例所示。当规则复杂时，该概念可扩展为允许组合简单规格说明，如同谓词通过逻辑运算符组合一样。（此技术将在下一章讨论。）基本模式保持不变，并为从简单模型向复杂模型演进提供了路径。

逾期发票的情况可通过`SPECIFICATION`进行建模，该规范定义了逾期的含义，并能评估任何`Invoice`实例以作出判定。

#### Figure 9.13
![Figure 9.13](../img/fig9.13.png)
*Figure 9.13：作为`SPECIFICATION`提取出的更复杂的违约规则*

`SPECIFICATION` 将规则保留在领域层。由于规则本身是完整的对象，这种设计能更明确地反映模型结构。[FACTORY](../glossary.md#factory) 可利用其他来源的信息（如客户账户或企业策略数据库）配置`SPECIFICATION`。若直接在`Invoice`中访问这些来源，将导致对象间产生与付款请求（`Invoice`的基本职责）无关的耦合。在此场景中，`Delinquent Invoice Specification`需创建后用于评估若干`发票`，随后即被废弃，因此直接内置了特定评估日期 —— 这实现了巧妙的简化。`SPECIFICATION`可通过简单直接的方式获取执行任务所需的信息。

🌼🌼🌼

### 应用和实现`SPECIFICATIONS`

#### ▶[下一节](../ch10/0.md)
