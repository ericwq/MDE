##  第三章 绑定模型与实现

#### ▶[上一节](../ch2/5.md)

推门而入时，首先映入眼帘的是整面墙上张贴着巨幅纸张印制的完整类图。这是我加入项目的首日，目睹了才华横溢的团队耗费数月精心研究并构建的领域模型。模型中的典型对象与三四个其他对象存在复杂关联，这张关联网络几乎没有天然边界。从这个角度看，分析师们确实忠实呈现了该领域的本质特征。

尽管这幅墙面大小的示意图令人望而生畏，模型确实捕捉到了某些知识。经过适度研读，我确实学到了不少东西（尽管这种学习难以有效引导，就像随意浏览网页一样）。更令我困扰的是，我的研究未能揭示该应用程序的代码和设计原理。

当开发人员开始实现该应用程序时，他们很快发现：尽管人类分析师能够理清错综复杂的关联关系，但这些关联无法转化为可存储、可检索且能保持事务完整性的操作单元。请注意，该项目使用的是对象数据库，因此开发人员甚至无需面对将对象映射到关系表的挑战。从根本上说，该模型并未为实现提供指导。

由于该模型是技术分析师与业务专家广泛协作的 “正确” 成果，开发人员得出结论：基于概念的对象无法成为其设计的基础。于是他们着手开发了一套临时设计方案。该方案虽沿用了若干相同的类名和数据存储属性，但并未基于现有模型或任何其他模型。

<ins>该项目拥有一个领域模型，但纸上谈兵的模型若不能直接助力软件开发，又有何用？</ins>

几年后，我目睹了截然不同的开发流程却得出了相同的结果。该项目旨在用 Java 实现的新设计替换现有 C++应用程序。旧应用程序是拼凑而成，完全不考虑对象建模。其设计（如果算设计的话）是通过在现有代码上不断堆砌功能模块形成的，没有任何明显的泛化或抽象。

诡异的是，两种开发过程的最终产物竟惊人地相似！它们都具备功能性，却都臃肿不堪、难以理解，最终变得无法维护。尽管某些实现处显露着某种直接性，但通过阅读代码却难以窥见系统设计的初衷。两种过程都未能充分利用开发环境中可用的面向对象范式，仅将其当作花哨的数据结构使用。

模型种类繁多且功能各异，即便在软件开发项目中也存在诸多限制。<ins>领域驱动设计要求模型不仅要辅助前期分析，更要成为设计的基础。这种方法对代码具有重要影响。但较少被提及的是，领域驱动设计需要采用不同的建模方法……</ins>

#### ▶[下一节](1.md)
