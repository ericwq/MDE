## 文档与图表

#### ▶[上一节](3.md)

每当我在会议中讨论软件设计时，若不借助白板或草稿本绘图，便难以正常工作。我绘制的内容多为 UML 图，主要是类图或对象交互图。

有些人天生擅长视觉化思维，图表能帮助人们理解特定类型的信息。UML 图在传达对象间关系方面相当出色，在展示交互方面也表现不俗。但它们无法传递这些对象的概念定义。在会议中，我会一边绘制图表一边用语言阐释这些含义，或者这些概念会在与其他参与者的对话中自然浮现。

简洁的非正式 UML 图能为讨论提供锚点。勾勒出三到五个与当前议题核心相关的对象图示，就能让所有人保持专注。通过图表，所有人能共享对象间关系视图，尤其是关于对象名称的统一理解。借助这种可视化工具，口头讨论将更具成效。当参与者尝试不同思维实验时，图表可随时调整，使其如口语般灵活流转，真正成为讨论的有机组成部分。毕竟，UML 的本意正是统一建模语言。

当人们觉得必须通过 UML 来完整呈现整个模型或设计时，麻烦就来了。许多对象模型图既过于详尽，又遗漏太多内容。之所以详尽过度，是因为人们总觉得必须把所有即将编码的对象都塞进建模工具。当细节堆砌到这种程度时，人们便会陷入只见树木不见森林的境地。

然而尽管细节如此丰富，属性与关系仅是对象模型的一半内容。对象的行为及其约束关系难以直观呈现。对象交互图虽能揭示设计中的某些关键难点，但绝大多数交互关系无法通过这种方式展现，无论是绘制还是解读都过于耗时费力。况且交互图仍只能暗示模型的设计意图。<ins>为纳入约束条件和断言，UML 最终仍需借助文本说明：这些文字被置于小括号中，嵌入到图表之中。</ins>

对象的行为职责可通过操作名称暗示，也可通过对象交互（或序列）图隐含展示，但无法明确表述。因此，这项任务需要借助补充文本或对话来完成。<ins>换言之，UML 图无法传达模型的两大核心要素：其所表征概念的内涵，以及对象应执行的功能。不过这不会困扰我们，因为精确运用英语（或西班牙语等任何语言）便能很好地承担这一角色。</ins>

<ins>UML 作为编程语言也并不尽如人意。我所见过的所有尝试利用建模工具代码生成功能的做法都适得其反。若受限于 UML 的功能，你往往不得不舍弃模型中最关键的部分，因为某些规则无法被框线图所承载</ins>。当然，代码生成器也无法利用那些文本注释。<ins>若采用允许用 UML 类图语言编写可执行程序的技术，UML 图便沦为程序的另一种呈现形式，“模型” 的本质意义就此丧失。即便将 UML 作为实现语言，仍需借助其他方式传达简洁的模型概念。</ins> *(译注： 这是站在 2003 年对 MDE 的理解，20 年后会有变化。)*

<ins>图表是沟通与阐释的工具，能有效促进头脑风暴。简洁的图表最能达成这些目的</ins>。涵盖整个对象模型的全面图表既无法传达信息也无法解释概念，它们用细节淹没读者且缺乏实质意义。这促使我们远离包罗万象的对象模型图，甚至远离 UML 的全面数据库仓库。相反，我们应转向简化图表，聚焦于理解设计时至关重要的概念性核心部分。本书所示图表正是我在项目中惯用的范例，它们既能简化复杂性又能阐明要点，甚至为清晰表达偶尔采用非标准记法。这些图表呈现设计约束，却非事无巨细的设计规范，而是构思框架的骨架。

设计的关键细节都体现在代码中。优秀的实现应具有透明性，揭示其底层模型。（确保实现透明性是下一章及本书后续内容的核心议题。）补充性图表和文档可引导人们关注核心要点。自然语言讨论能填补语义的细微差别。<ins>正因如此，我倾向于颠覆典型 UML 图的处理方式。不采用文字注释的图表，而是撰写配以精选简化图示的文本文档。</ins>

<ins>请始终牢记：模型并非图示。图示的目的是帮助传达和解释模型</ins>。代码可以作为设计细节的存储库。精心编写的 Java 代码以其独特的方式与 UML 同样富有表现力。精心挑选和构造的图示能够聚焦注意力并辅助导航，前提是它们不被强迫性地完整呈现模型或设计的冲动所遮蔽。

### 书面设计文档

口头交流能为代码的严谨性与细节补充语义内涵。尽管口头沟通对让所有人理解模型至关重要，但无论团队规模大小，都可能需要具备稳定性和可共享性的书面文档。然而，要制作出真正能帮助团队产出优质软件的书面文档，实属不易。

一旦文档形成固定形态，往往便与项目进展脱节。它会被代码演进所抛弃，或被项目语言的演变所淘汰。

诸多方法皆可奏效。本书 [第四部分](../part4.md) 将针对特定需求提出若干具体文档建议，但笔者无意规定项目必须采用的文档体系。<ins>相反，我将提供两条评估文档的通用准则。</ins>

#### 文档应与代码和语言相辅相成

每种敏捷流程对文档都有其独特理念。极限编程主张完全不使用额外设计文档，让代码自我阐释。运行中的代码不会说谎，不像其他文档可能存在虚假陈述。运行代码的行为具有明确性。

极限编程专注于程序的活跃元素和可执行测试。即便是添加到代码中的注释也不会影响程序行为，因此它们总是与活跃代码及其驱动模型脱节。<ins>外部文档和图表不会影响程序行为，因此会逐渐脱节</ins>。相反，口头交流和白板上的临时图表不会长期存在造成混淆。<ins>这种将代码作为沟通媒介的特性，激励开发者保持代码的简洁与透明。</ins>

<ins>但代码作为设计文档确实存在局限性。它可能因细节过多而令读者难以消化。尽管其行为明确无误，却未必显而易见</ins>。行为背后的深层含义也往往难以传达。换言之，仅通过代码进行文档化与使用全面的 UML 图存在相同的基本问题。当然，团队内部的大量口头交流能为代码提供上下文和指导，但这种交流具有短暂性和局限性。而且需要理解该模型的人不仅限于开发人员。

<ins>*文档不应试图重复代码已完成的工作*</ins>。代码本身已提供了细节，它是程序行为的精确规范。

其他文档则需阐释含义，揭示大规模结构的本质，并聚焦核心要素。当编程语言无法直接实现某个概念时，文档可阐明设计意图。书面文档应与代码及口头说明相辅相成。

#### 文档应当发挥作用并保持时效性

当我以书面形式记录模型时，会将模型精心挑选的小型子集绘制成图，并辅以文字说明。我用语言定义类及其职责，并将其置于只有自然语言才能赋予的语义语境中。但图示揭示了将概念形式化并精简为对象模型过程中做出的某些选择。这些图示可以相当随意，甚至手绘而成。手绘图示不仅节省精力，更因其随性与临时性而具有独特优势。这些特质恰恰值得传达，因为它们通常真实反映着我们的模型构想。

设计文档的最大价值在于阐释模型的概念，帮助理解代码细节，并或许能揭示模型预期的使用方式。根据团队理念的不同，整份设计文档可以简单到仅是贴在墙上的一组草图，也可以相当详尽。

<ins>*文档必须参与项目活动*</ins> 。判断此点的最简便方式是观察文档与 [UBIQUITOUS LANGUAGE](1.md) 的交互：该文档是否采用项目成员当前使用的语言编写？是否采用代码中嵌入的语言编写？

倾听 [UBIQUITOUS LANGUAGE](1.md) 及其演变。若设计文档中阐释的术语未能出现在日常对话和代码中，则该文档未能达成其目的。或许文档篇幅过长或过于复杂，或许其聚焦的主题不够重要。人们要么不愿阅读，要么觉得缺乏吸引力。若文档对 [UBIQUITOUS LANGUAGE](1.md) 毫无影响，则说明存在问题。

相反，当某份文档被弃置时，你可能会听到 [UBIQUITOUS LANGUAGE](1.md) 自然发生变化。显然这份文档对人们似乎无关紧要，或不够重要以至于无需更新。它完全可以安全地归档为历史资料，但若继续保留则可能造成混乱并损害项目。若文档未发挥重要作用，仅凭意志和纪律强行保持其更新实属徒劳。

 [UBIQUITOUS LANGUAGE](1.md) 使其他文档（如需求规格说明书）能够更简洁且更少歧义。随着领域模型逐渐反映业务的核心知识，应用需求便转化为该模型中的场景。此时， [UBIQUITOUS LANGUAGE](1.md) 可用于描述此类场景，其表述方式能直接关联 [MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design) （参见 [第 3 章](../ch3/0.md) ）。因此，规范文档得以简化编写，因为它们无需再传达模型背后的业务知识。

<ins>通过精简文档并使其专注于辅助代码与交流，文档才能始终与项目保持紧密联系。让 [UBIQUITOUS LANGUAGE](1.md) 及其演进成为你的指南，选择那些能够融入项目活动并持续发展的文档。</ins>

### 可执行的基石

现在让我们审视 XP 社区及其他一些群体几乎完全依赖可执行代码及其测试的做法。本书大部分内容探讨了如何通过模型驱动设计（参见 [第 3 章](../ch3/0.md) ）使代码传达意义。精心编写的代码确实能有效传递信息，但其传达的内容未必准确。哦，代码片段引发的 *行为* 本质是无法回避的。然而方法名可能存在歧义、误导性，或与方法内部实现脱节。测试中的断言虽严谨，但变量命名和代码组织所讲述的故事却未必如此。良好的编程风格能最大限度保持这种关联的直接性，但这终究是自我约束的实践。要编写出不仅 *做* 对事、更 *说* 对事的代码，需要极致的严谨。

<ins>消除这些差异是声明式设计（详见 [第 10 章](../ch10/0.md) ）等方法的核心优势所在，该方法通过声明程序元素的目的来决定其在程序中的实际行为。从 UML 生成程序的尝试部分源于此动机，尽管迄今为止成效并不显著。</ins>

尽管如此，即便代码也可能产生误导，但它比其他文档更贴近实际。运用当前标准技术使代码的行为、意图和信息保持一致，需要严谨的纪律和特定的设计思维方式（详见 [第三部分](../part3.md) ）。<ins>要实现有效沟通，代码必须基于与需求文档相同的语言，这正是开发者之间以及开发者与领域专家交流时使用的语言。</ins>

#### ▶[下一节](5.md)
