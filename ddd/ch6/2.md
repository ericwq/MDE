## 工厂

#### ▶[上一节](0.md)

![part 2.7](../img/part2.7.png)

当对象或整个 [AGGREGATE](../glossary.md#aggregate) 的创建变得复杂，或者暴露了过多内部结构时，`FACTORIES`提供了封装。

🌼🌼🌼

对象的大部分力量源于其内部结构的复杂配置及其关联性。一个对象应该被提炼到只保留与其意义相关或支持其交互角色的部分。在其生命周期的中期，这样的责任已经足够。问题出现在给一个复杂对象过多职责，使其必须负责自身的创建。

汽车发动机是精密的机械装置，数十个部件协同运作以完成其核心使命：驱动曲轴转动。试想设计一个能主动抓取活塞组并将其装入气缸的缸体，或是能自行定位并旋入插座的火花塞，但如此复杂的装置，其可靠性与效率恐怕难以匹敌常规引擎。因此我们接受由其他主体完成组装，可能是人类技师，也可能是工业机器人。无论是机器人还是人类，其复杂程度都远超所组装的引擎。零件组装工作与转轴运转功能本就毫无关联。装配者仅在汽车制造过程中发挥作用 —— 驾驶时你无需机器人或技师相伴。正因汽车绝不会在组装与行驶中同时进行，将这两项功能整合于同一机制毫无价值。同样地，组装复杂复合物体的工作，最好与该物体完成后需承担的任务相互分离。

但将责任转移给另一个相关方，应用程序中的客户端对象，会导致更严重的问题。客户端知道需要完成什么任务，并依赖领域对象执行必要的计算。如果要求客户端自行组装所需的领域对象，它就必须了解对象的内部结构。为确保领域对象内部关系的所有不变量成立，客户端必须掌握部分对象规则。即便调用构造函数也会使客户端与其构建对象的具体类产生耦合。此时领域对象的任何实现变更都将引发客户端修改，从而增加重构难度。

客户端承担对象创建职责会导致不必要的复杂性，模糊其职责边界。这破坏了领域对象与正在创建的`AGGREGATES`的封装性。更糟糕的是，若该客户端属于应用层，则职责已完全溢出领域层。这种将应用与具体实现紧密耦合的做法，剥夺了领域层抽象带来的多数优势，并使后续变更成本持续攀升。

<ins>**对象的创建本身可能是一项重大操作，但复杂的组装操作并不属于被创建对象的职责范围。将这些职责混为一谈会导致设计臃肿且难以理解。让客户端直接控制构造过程会模糊客户端的设计，破坏组装对象或 [AGGREGATE](../glossary.md#aggregate) 的封装性，并使客户端过度耦合于被创建对象的实现细节。**</ins>

复杂对象的创建属于领域层的职责，但该任务不应由表达模型的对象承担。某些情况下，对象的创建与组合对应着领域中的重要里程碑，例如 “开设银行账户”。然而对象创建与组合通常在领域中不具实质意义，它们仅是实现层面的必要操作。为解决此问题，我们需在领域设计中引入非`ENTITIES`、非`VALUE OBJECTS`、非`SERVICES`的构造。这与前章理念有所不同，<ins>需明确强调：我们添加的设计元素虽不对应模型中的任何内容，但它们依然属于领域层的职责范畴。</ins>

每种面向对象语言都提供了创建对象的机制（例如 Java 和 C++ 中的构造函数，Smalltalk 中的实例创建类方法），但我们需要更抽象的构造机制，使其与其他对象解耦。负责创建其他对象的程序元素被称为 [FACTORY](../glossary.md#factory) 。

#### Figure 6.12
![Figure 6.12](../img/fig6.12.png)
*Figure 6.12：与 [FACTORY](../glossary.md#factory) 的基本交互*

正如对象的接口应封装其实现，从而允许客户端在不知晓工作原理的情况下使用对象的行为， [FACTORY](../glossary.md#factory) 同样封装了创建复杂对象或 [AGGREGATE](../glossary.md#aggregate) 所需的知识。它提供了一个反映客户端目标的接口，并呈现被创建对象的抽象视图。

因此：

#### ▶[下一节](2.md)
