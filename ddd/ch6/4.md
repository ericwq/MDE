## 为关系数据库设计对象

#### ▶[上一节](3.md)

在以面向对象为主的软件系统中，最常见的非对象组件是关系数据库。这种现实带来了混合范式通常存在的问题（参见 [第 5 章](../ch5/0.md) ）。但数据库与对象模型的关联远比其他组件更为紧密，它不仅与对象交互，更存储着构成对象本身的持久化数据形式。关于对象映射到关系表的技术挑战，以及如何高效存储和检索对象，已有大量文献探讨。近期可参考 [Fowler 2003](../references.md#fowler-2003) 的论述。目前已有相当成熟的工具用于创建和管理二者之间的映射关系。除技术层面的考量外，这种不匹配现象还会对对象模型产生显著影响。

有三种常见情况：
1. 数据库主要作为对象的存储库。
2. 该数据库是为其他系统设计的。
3. 该数据库虽为本系统设计，但承担着除对象存储之外的其他角色。

当数据库模式专门作为对象存储库创建时，为保持映射极简，值得接受某些模型限制。若无其他模式设计要求，可通过数据库结构设计使聚合完整性在更新过程中更安全高效。从技术角度而言，关系表设计不必完全映射领域模型。映射工具已足够强大，能弥合显著差异。问题在于多重重叠模型过于复杂。许多用于论证 [MODEL-DRIVEN DESIGN](../ch3/1.md) （避免分析与设计模型分离）的观点同样适用于此类映射错位。这确实需要牺牲部分对象模型的丰富性，有时还需在数据库设计中做出妥协（如选择性反规范化），但若不如此便可能导致模型与实现的紧密耦合关系丧失。此方法并非要求简单粗暴的 “一对象对一表” 映射。根据映射工具的强大程度，可能实现对象的聚合或组合。但关键在于映射必须透明，通过检查代码或阅读映射工具条目即可轻松理解。

- 当将数据库视为对象存储时，无论映射工具多么强大，都应避免数据模型与对象模型产生过大偏差。为贴近关系模型，可适当牺牲对象关系的丰富性；若有助于简化对象映射，可对规范化等正式关系标准作出妥协。
- 对象系统外的进程不应访问此类对象存储库。它们可能破坏对象强制执行的不变性。此外，此类访问会锁定数据模型，导致对象重构时难以变更。

另一方面，许多情况下数据源自遗留系统或外部系统，这些系统原本并非作为对象存储而设计。在这种情形下，实际上存在两个领域模型在同一系统中共存。[第 14 章](../ch14/0.md) "维护模型完整性" 对此问题进行了深入探讨。有时遵循另一系统隐含的模型是合理的，有时则更宜构建完全独立的模型。

例外情况的另一个原因是性能。为解决执行速度问题，可能需要引入特殊的设计变更。

但在关系数据库作为面向对象领域持久化形式的重要通用场景中，简单直接的映射最为理想。表行应包含一个对象，必要时可通过 [AGGREGATE](1.md) 关联附属对象。表中的外键应映射为对另一个 [ENTITY](../ch5/2.md) 的引用。偶尔偏离这种简单直接性的必要性，不应导致彻底放弃简单映射原则。

[UBIQUITOUS LANGUAGE](../ch2/1.md) 能将对象与关系组件整合为单一模型。对象中元素的名称与关联关系应与关系表中的对应项严丝合缝。尽管某些映射工具的强大功能可能使此步骤看似多余，但关系中的细微差异将引发诸多混乱。

在对象世界中日益盛行的重构传统，对关系型数据库设计的影响其实有限。更重要的是，严峻的数据迁移问题阻碍了频繁变更。这或许会拖累对象模型的重构进程，但若对象模型与数据库模型开始出现分歧，透明性便可能迅速丧失。

最后，即使数据库是专门为您的系统创建的，也存在一些理由选择与对象模型截然不同的模式。该数据库可能被其他不会实例化对象的软件使用。即使对象的行为快速变化或演进，数据库也可能只需很少的修改。将二者割裂开来看似诱人，但往往是团队未能及时更新数据库模型时无意间走上的歧途。若刻意选择分离，反而能获得简洁的数据库模式 —— 而非为迎合去年过时的对象模型而充满妥协的笨拙设计。

#### ▶[下一节](../ch7/0.md)


