## 逐步验证场景

#### ▶[上一节](6.md)

为交叉核对所有决策，我们必须持续逐步验证各类场景，确保能有效解决应用问题。

### 应用功能示例：更改货物目的地

偶尔会有`Customer`致电表示：“糟糕！我们要求将货物发往 Hackensack，但实际需要运抵 Hoboken。” 服务至上，系统必须支持此类变更。

由于`Delivery Specification`属于 [VALUE OBJECT](../ch5/3.md) ，最简洁的处理方式是直接丢弃旧规范并创建新规范，随后通过`Cargo`的设置方法将新规范替换旧规范。

### 应用功能示例：重复业务

用户反馈称来自同一`Customers`的重复订单往往具有相似性，因此希望将旧`Cargoes`作为新订单的模板。该应用将允许用户在 [REPOSITORY](../glossary.md#repository) 中查找`Cargo`，然后选择命令基于所选`Cargo`创建新`Cargo`。我们将采用`PROTOTYPE`模式（ [Gamma et al. 1995](../references.md#gamma-1995) ）进行设计。

`Cargo`是一个 [ENTITY](../ch5/2.md) ，也是 [AGGREGATE](../glossary.md#aggregate) 的根节点。因此，必须谨慎复制货物；我们需要考虑其 [AGGREGATE](../glossary.md#aggregate) 边界内包含的每个对象或属性应如何处理。让我们逐一分析：

- `Delivery History`：我们应创建一个全新的空记录，因为旧记录的历史记录不适用。这是 [AGGREGATE](../glossary.md#aggregate) 边界内实体的常规情况。
- `Customer Roles`：我们应复制包含`Customers`键值引用的`Map`（或其他集合），包括键值本身，因为他们在新货运中可能承担相同角色。但需注意 *不要* 复制`Customer`对象本体。最终必须保留与旧`Cargo`对象引用的`Customer`对象相同的引用关系，因为这些客户对象作为 [ENTITIES](../ch5/2.md) 存在于 [AGGREGATE](../glossary.md#aggregate) 边界之外。
- `Tracking ID`：我们必须提供一个新的`Tracking ID`，其来源应与创建全新`Cargo`时所用的来源一致。

请注意，我们已复制了`Cargo` [AGGREGATE](../glossary.md#aggregate) 边界内的所有内容，并对副本进行了部分修改，但完全 *未影响* [AGGREGATE](../glossary.md#aggregate)  *边界外的任何内容* 。

#### ▶[下一节](8.md)
