## 建模范式

#### ▶[上一节](5.md)

[MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design) 要求采用与所应用特定建模范式相契合的实现技术。许多此类范式曾被尝试，但实际应用中仅少数得到广泛采用。当前主流范式是面向对象设计，如今大多数复杂项目都以对象为基础展开。这种主导地位源于多重因素：既有对象本身的内在特性，也有环境因素的影响，更得益于广泛应用本身带来的优势。

### 为何对象范式占据主导地位

团队选择对象范式的原因往往并非技术因素，甚至与对象本身无关。但从一开始，对象建模就巧妙地平衡了简单性与复杂性。

<ins>若建模范式过于晦涩，掌握它的开发者将寥寥无几，且应用效果不佳。若团队中非技术成员连范式基础都无法理解，他们便无法看懂模型，[UBIQUITOUS LANGUAGE](../ch2/1.md) 也将失效。面向对象设计的基本原理似乎对大多数人来说是自然而然的。尽管有些开发者会忽略建模的微妙之处，但即使是非技术人员也能理解对象模型的图示。</ins>

然而，<ins>尽管对象建模的概念看似简单，它却已证明可以捕捉重要的领域知识。从一开始，它就得到了开发工具的支持，这些工具使得模型能够通过软件来表达。</ins>

如今，面向对象范式还因其成熟度和广泛采用而具备若干显著的环境优势。若缺乏成熟的基础设施和工具支持，项目可能陷入技术研发的歧途，导致应用开发资源被延误和转移，并引入技术风险。某些技术难以与其他技术协同工作，甚至无法与行业标准解决方案集成，迫使团队重新发明通用工具。但多年来，面向对象技术已解决诸多此类问题，或因广泛应用而使这些问题变得无关紧要（如今其他技术方案反而需要主动适配主流面向对象技术）。多数新兴技术都提供了与主流面向对象平台的集成手段，这不仅简化了集成过程，甚至允许混合使用基于其他建模范式的子系统（本章后文将详述）。

同样重要的是 *开发者社区的成熟度以及设计文化本身* 。采用新颖范式的项目可能难以找到精通该技术或具备在所选范式中创建有效模型经验的开发者。由于充分利用该范式和技术的模式尚未成熟，在合理时间内培养开发者可能并不现实。或许该领域的先驱者虽成效卓著，却尚未以通俗形式发表其洞见。

面向对象概念已被数千名开发者、项目经理及所有参与项目工作的专业人士所理解。

一个仅发生于十年前的面向对象项目案例，生动揭示了在不成熟范式下工作的风险。20 世纪 90 年代初，该项目致力于采用多项尖端技术，包括大规模部署面向对象数据库。这令人振奋不已。团队成员常自豪地向访客宣称：我们正在部署该技术有史以来支持的最大型数据库。当我加入项目时，各团队正轻松地设计出面向对象的方案，并将对象存储在数据库中。但渐渐地，我们意识到一个令人不安的事实：测试数据就已占用了数据库相当大的容量！而实际数据库的规模将是测试数据的数十倍，实际交易量更是测试数据的数十倍。难道这项技术根本不适用于这个应用场景？还是我们使用方式有误？我们显然力不从心。

幸运的是，我们成功邀请到全球屈指可数、具备解决此类难题能力的人才加入团队。他开出了价码，我们付出了代价。问题根源有三：首先，数据库配套的现成基础设施根本无法满足我们的扩展需求；其次，精细化对象的存储成本远超预期；最后，对象模型部分模块的相互依赖关系过于复杂，导致并发事务量稍增便引发竞争问题。

在聘请的专家协助下，我们强化了基础设施。团队意识到精细化对象的影响后，开始寻找更契合该技术的模型方案。我们全体成员都深化了对模型中关系网限制重要性的认识，并开始运用这一新认知来构建更优质的模型，在紧密关联的聚合体之间实现更充分的解耦。

在这次恢复过程中又耗费了数月光阴，此前还曾因走错方向而浪费了数月时间。这并非团队首次因所选技术不够成熟、自身缺乏相关技术学习经验而遭遇挫折。遗憾的是，该项目最终被迫收缩规模，变得相当保守。时至今日，他们仍在使用那些前沿技术，但仅限于谨慎规划的应用场景，这些场景或许根本无法真正受益于这些技术。

十年后，面向对象技术已相对成熟。大多数常见的基础设施需求都能通过现成的解决方案满足，这些方案已在实际应用中得到验证。关键任务工具通常来自主流供应商（往往是多家供应商）或稳定的开源项目。许多基础设施组件本身已被广泛采用，因此存在理解它们的用户基础，以及相关技术书籍等配套资源。这些成熟技术的局限性已被充分认知，因此经验丰富的团队较少会过度扩张。

其他有趣的建模范式尚未达到这种成熟度。有些过于艰深难以掌握，永远只能局限于小众领域；有些虽具潜力，但技术基础设施仍显零散或脆弱，且鲜有人能领会为其构建优质模型的精妙之处。这些范式或许终将成熟，但目前尚不适用于多数项目。

<ins>正因如此，当前尝试 [MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design) 的大多数项目都明智地选择以面向对象技术作为系统核心。它们不会被锁定在纯对象系统中 —— 由于对象技术已成为行业主流，现有的集成工具几乎能与当前使用的任何其他技术实现互联互通。</ins>

### 对象世界中的非对象

领域模型不必是对象模型。例如，Prolog中 就实现了 [MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design) ，其模型由逻辑规则和事实构成。<ins>模型范式旨在满足人们对领域建模的特定思维方式，进而由该范式塑造领域模型形态。最终形成的模型既符合范式要求，又能高效适配支持该建模风格的工具。</ins>

无论项目中占主导地位的模型范式是什么，领域中总会有某些部分更适合用其他范式来表达。当某个范式在处理领域时表现良好，仅存在少数异常元素时，开发者可以容忍模型中出现几个不协调的对象。（反之，若问题领域的大部分内容在另一特定范式下更自然地表达，则彻底转换范式并选择不同的实现平台或许更为合理。）但当领域的主要部分似乎属于不同范式时，采用混合工具集支持实现，分别用适配的范式建模各部分的做法在理论上更具吸引力。当相互依赖性较弱时，可将另一范式中的子系统封装起来，例如仅需被对象调用的复杂数学运算。而在对象交互依赖数学关系等场景中，不同方面往往更紧密地交织在一起。

这正是推动业务规则引擎和工作流引擎等非对象组件融入对象系统的动因。混合范式使开发人员能够采用最契合的方式建模特定概念。此外，多数系统必须采用某些非对象技术基础设施，最常见的是关系型数据库。但构建跨越范式的统一模型难度极大，使支持工具共存更是复杂。当开发者无法清晰看到软件中体现的统一模型时，[MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design) 便可能付诸东流，尽管这种混合模式恰恰增加了对它的需求。

### 在混合范式时坚持 [MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design)

规则引擎可作为技术融合的典型案例，这类技术常被引入面向对象的应用开发项目。知识密集型领域模型可能包含显式规则，但面向对象范式缺乏表述规则及其交互的特定语义。尽管规则可被建模为对象（且常取得成功），但对象封装特性使得跨系统全局规则的应用显得笨拙。规则引擎技术之所以具有吸引力，在于它承诺提供更自然、更声明式的规则定义方式，从而有效地将规则范式融入对象范式。逻辑范式已发展成熟且功能强大，似乎能很好地弥补对象范式的优势与不足。

但人们并不总能从规则引擎中获得期望的结果。有些产品效果欠佳，有些则缺乏无缝视图来展示两个实施环境间运行的模型概念之间的关联性。常见的结果是应用程序分裂为两部分：一个使用对象的静态数据存储系统，以及一个几乎与对象模型失去所有联系的临时规则处理应用程序。

在处理规则时，持续以模型思维进行思考至关重要。团队必须找到一个能同时适配两种实现范式的统一模型。这并非易事，但若规则引擎支持表达性实现，则应可实现。否则数据与规则将脱节。引擎中的规则最终更像独立程序，而非领域模型中的概念性规则。唯有建立规则与对象间紧密清晰的关联，才能同时保留两者的本质意义。

若缺乏无缝衔接的环境，开发者便需提炼出由清晰基本概念构成的模型，以维系整体设计。

最有效的整合工具是贯穿整个异构模型的强大 [UBIQUITOUS LANGUAGE](../ch2/1.md) 。在两个环境中保持名称一致性，并运用 [UBIQUITOUS LANGUAGE](../ch2/1.md) 实践这些名称，有助于弥合差距。

这个话题值得单独撰写专著探讨。本节仅旨在说明：我们无需放弃 [MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design)，坚持这一理念是值得付出的努力。

尽管 [MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design) 不必采用面向对象方式，但它 *确实* 依赖于模型构造（无论是对象、规则还是工作流）的表达性实现。若现有工具无法实现这种表达性，则需重新考虑工具选择。缺乏表达性的实现将抵消额外范式带来的优势。

<ins>以下是将非对象元素融入以面向对象为主导的系统时需遵循的四条经验法则：</ins>

- *不要抗拒实现范式。* 领域总有其他思考方式，寻找契合范式的模型概念。
- *依托通用语言。* 即使工具间缺乏严谨关联，语言的高度一致性也能防止设计各部分产生分歧。
- *不要拘泥于 UML。* 有时对工具的执着，比如 UML 绘图，会导致人们扭曲模型以迎合易于绘制的形式。例如，UML 确实具备表示约束的关系，但这些功能往往不够完善。相较于为适应特定对象视图而进行的曲折调整，采用其他绘图风格（或许是其他范式下的常规方式）或简单的英文描述反而更为有效。
- *保持怀疑态度。* 这个工具真的物有所值吗？仅仅因为你制定了一些规则，并不意味着你需要规则引擎带来的额外负担。规则可以以对象的形式表达，虽然可能稍显凌乱；而多范式则会让事情变得极其复杂。

在承担混合范式带来的负担之前，应先穷尽主导范式内的所有选项。尽管某些领域概念并非显而易见的对象，但它们通常仍可在该范式内建模。[第 9 章](../ch9/0.md) 将探讨运用对象技术对非常规类型概念进行建模的方法。

关系范式是范式混合的一种特殊形式。作为最常见的非对象技术，关系数据库与对象模型之间的联系也比其他组件更为紧密，因为它充当着构成对象本身的数据的持久存储库。关于在关系数据库中存储对象数据的问题，将在 [第 6 章](../ch6/0.md) 中与对象生命周期的诸多其他挑战一同探讨。

#### ▶[下一节](../ch6/0.md)
