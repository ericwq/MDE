## 模块（又称包）：`MODULES`

#### ▶[上一节](4.md)

`MODULES`是历史悠久且成熟的设计元素。虽然存在技术上的考量，但认知负荷过载 (cognitive overload) 才是模块化的核心动因。`MODULES`为人们提供了两种模型视角：既能聚焦`MODULE`内部细节而不被整体所淹没，又能通过排除内部细节的视图观察`MODULES`间的关联关系。

领域层中的`MODULES`应作为模型中具有重要意义的部分呈现，在更宏大的尺度上讲述领域的故事。

🌼🌼🌼

<ins>**人人都在使用`MODULES`，却鲜少将其视为模型中不可或缺的组成部分。代码被拆解成各种类别，从技术架构的各个方面到开发人员的工作分配。即便是频繁重构的开发者，也往往满足于项目初期设计的`MODULES`。**</ins>

<ins>**`MODULES`之间应保持低耦合，内部则需高内聚，这本是老生常谈。关于耦合与内聚的解释往往将其视为技术指标，似乎只需机械地根据关联与交互的分布来评判。然而被划分为`MODULES`的不仅是代码，更是概念。人类同时思考的事物数量存在上限（故需低耦合）。零散的想法片段和未分化的想法大杂烩一样难以理解（故需高内聚）。**</ins>

低耦合与高内聚是普遍适用的设计原则，既适用于单个对象也适用于`MODULES`，但在这种更宏观的建模与设计层面尤为重要。这些概念由来已久，其中一种模式风格的说明可见于 [Larman 1998](references.md#larman-1998) 的著作。

当两个模型元素被拆分到不同模块时，它们之间的关联性会变得不如原先直接，这增加了理解其在设计中定位的认知成本。`MODULES`间的低耦合性能最大限度降低这种成本，使我们能够在最小化引用其他交互`MODULES`的前提下，分析单个`MODULE`的内容。

<ins>同时，优秀模型的各个元素具有协同效应，精心选择的`MODULES`将模型中概念关联性特别丰富的元素整合在一起。这种具有相关职责的高凝聚性对象集合，使得建模与设计工作能够集中于单个`MODULE`内，这种复杂度级别恰好是人类思维能够轻松驾驭的尺度。</ins>

`MODULES`与较小的元素本应协同演化，但通常并非如此。
`MODULES`被选定用于组织对象的初始形态，此后对象往往以维持现有`MODULE`定义边界的方式发生变化。
重构`MODULES`比重构类更费时且更具破坏性，且可能无法频繁进行。
<ins>但正如模型对象往往从朴素具体起步，逐步演变以展现更深层的洞察力，`MODULES`也能变得精妙抽象。
让`MODULES`反映领域认知的变化，也将为其中的对象提供更大的进化自由度。</ins>

如同领域驱动设计中的其他元素，`MODULES`是一种通信机制。
被划分的对象所承载的意义，应当决定`MODULES`的选择。
当你将某些类归入同一个`MODULE`时，就是在告诉后续审阅设计的开发者：这些类应当被视为整体来考量。
<ins>若将模型比作故事，`MODULES`便是章节。
`MODULE`名称承载其内涵，这些名称将融入 [UBIQUITOUS LANGUAGE](../ch2/1.md) 体系。</ins>
当你对业务专家说 “现在我们来讨论 customer `MODULE`" 时，对话的语境便自然确立。

因此：

<ins>**选择能够阐释系统故事且包含一组凝聚概念的`MODULES`。这通常能降低`MODULES`间的耦合度，若未能实现，则需调整模型以解耦概念，或寻找被忽略的概念，它可能成为`MODULE`的基础，从而将元素以有意义的方式整合起来。追求低耦合应体现在概念可独立理解与推理的层面。持续优化模型，直至其依据高阶领域概念进行划分，对应的代码也随之解耦。**</ins>

<ins>**为`MODULES`命名时，应采用成为 [UBIQUITOUS LANGUAGE](../ch2/1.md) 组成部分的名称。`MODULES`及其名称应体现对该领域的深刻理解。**</ins>

考察概念关系并非替代技术措施的方案。它们是同一问题的不同层面，两者都必须实现。但以模型为中心的思维能产生更深层的解决方案，而非偶然的权宜之计。当必须权衡取舍时，应优先选择概念清晰度，即便这意味着`MODULES`间需增加更多引用关系，或某`MODULE`变更时可能引发连锁效应。只要开发者理解模型传递的核心逻辑，这些问题皆可迎刃而解。

🌼🌼🌼

### 敏捷`MODULES`

<ins>`MODULES`需要与模型的其余部分协同演进。
这意味着必须在模型和代码重构的同时对`MODULES`进行重构。
但这种重构往往未能实现。修改`MODULES`通常需要对代码进行广泛更新。</ins>
此类变更可能干扰团队沟通，甚至会破坏开发工具（如源代码控制系统）的正常运作。
因此，`MODULE`的结构和命名往往比类更早地反映出模型早期形态。

<ins>`MODULE`选择阶段不可避免的早期错误会导致高耦合性，从而使重构变得困难。
重构缺失只会不断加剧这种惯性。
唯有咬紧牙关，根据对问题点的经验判断来重组`MODULES`，才能突破这一困境。</ins>

某些开发工具和编程系统加剧了这个问题。无论实现将基于何种开发技术，我们都需要寻找方法来最大限度地减少`MODULES`重构的工作量，并减少与其他开发人员沟通时的冗余信息。

#### 示例：Java 中的包命名约定

在 Java 中，导入语句（依赖关系）必须声明在某个独立类中。建模者可能将包视为依赖于其他包，但 Java 无法直接表达这种关系。常见的编码规范鼓励导入特定类，因此代码通常如下所示：
```java
ClassA1
import packageB.ClassB1;
import packageB.ClassB2;
import packageB.ClassB3;
import packageC.ClassC1;
import packageC.ClassC2;
import packageC.ClassC3;
. . .
```
<ins>遗憾的是，在 Java 中无法避免向单个类 *导入* 内容，但至少可以一次性导入整个包，这既体现了包作为高度凝聚单元的设计初衷，同时又减少了更改包名的工作量。</ins>
```java
ClassA1
import packageB.*;
import packageC.*;
. . .
```
<ins>诚然，这种技术意味着混合两种规模（类依赖于包），但它传达的信息比之前冗长的类列表更丰富 —— 它传达了对特定`MODULES`创建依赖的意图。</ins>

<ins>如果某个类确实依赖于其他包中的特定类，而本地`MODULE`似乎与该`MODULE`不存在概念上的依赖关系，那么或许应该考虑移动该类，或者重新审视`MODULES`本身的设计。</ins>

### 基础设施驱动的打包陷阱

技术框架对我们的打包决策产生着强大影响。其中有些影响是有益的，而另一些则需要加以抵制。

<ins>一个非常实用的框架标准示例是，通过将基础设施和用户界面代码分别归入不同的包组来强制执行 [LAYERED ARCHITECTURES](../ch4/1.md) ，同时将领域层物理分离至其专属的包组中。</ins>

另一方面，分层架构可能导致模型对象的实现碎片化。某些框架通过将单个领域对象的职责分散到多个对象中，再将这些对象置于不同包内来构建分层结构。例如在 J2EE 中，常见做法是将数据与数据访问功能封装到 “entity bean” 中，而将关联的业务逻辑置于 “session bean” 内。除了增加每个组件的实现复杂度外，这种分离会立即削弱对象模型的内聚性。对象最基本的概念之一就是将数据与其操作逻辑封装在一起。这种分层实现并非致命缺陷，因为两个组件可视为共同构成单一模型元素的实现。但更糟糕的是，entity bean 与 session bean 往往被拆分到不同包中。此时要将各类对象在脑海中重新整合为单一概念 [ENTITY](2.md) ，所需认知成本过高。模型与设计间的关联就此断裂。最佳实践是采用粒度大于 [ENTITY](2.md) 对象的 EJB，以降低分层带来的弊端。然而细粒度对象也常被拆分到不同层级。

例如，我在一个设计相当精妙的项目中遇到了这些问题，该项目将每个概念对象实际拆分为四个层级。每个分层都有充分的依据：第一层是数据持久化层，负责映射和访问关系数据库；第二层处理对象在所有场景下的固有行为；第三层用于叠加应用程序特有的功能。第四层作为公共接口层，与下方所有实现完全解耦。这种架构略显复杂，但各层定义清晰，关注点分离也保持着某种整洁度。我们本可通过在脑海中将构成单个概念对象的所有物理对象关联起来来适应这种设计。这种面向方面的分离有时甚至有所助益，特别是将持久化代码移出后，消除了大量冗余代码。

但除此之外，该框架还要求每个层级都位于独立的包集中，并按标识层级的约定进行命名。这耗尽了所有用于划分的思维空间。结果是，领域开发者往往避免创建过多`MODULES`（每个模块又需乘以四），且极少修改现有模块，因为重构`MODULE`的成本高得令人望而却步。更糟的是，追踪定义单个概念类的所有数据和行为极其困难（加之分层的间接性），导致开发者几乎没有余力思考模型设计。应用程序虽得以交付，但其领域模型却形同虚设，仅勉强满足数据库访问需求，行为逻辑则由少量 [SERVICES](4.md) 提供。本应由 [MODEL-DRIVEN DESIGN](../ch3/1.md) 带来的杠杆效应大打折扣，因为代码未能清晰呈现模型结构，开发者无法基于模型开展工作。

这种框架设计试图解决两个合理的问题。其一是关注点的逻辑划分：一个对象负责数据库访问，另一个负责业务逻辑，以此类推。这种划分使得各层的功能（在技术层面）更易理解，也便于替换层级。问题在于人们往往忽视了它对应用程序开发的代价。本书并非框架设计专著，故不深入探讨替代方案，但这些方案确实存在。即便没有替代方案，也应权衡取舍：与其追求这些优势，不如打造更具凝聚力的领域层。

这些打包方案的另一动机在于分层部署。若代码确实部署在不同服务器上，这或许是强有力的理由。但通常并非如此。这种灵活性仅是为应对潜在需求而保留。对于期望借助 [MODEL-DRIVEN DESIGN](../ch3/1.md) 优势的项目而言，除非能解决迫在眉睫的紧迫问题，否则这种牺牲代价过高。

<ins>技术驱动的复杂打包方案会带来双重成本：</ins>

- <ins>若框架的分区规范将实现概念对象的元素拆分开来，代码便无法再揭示模型。</ins>
- <ins>人脑能重新整合的分割程度是有限的，若框架耗尽所有整合能力，领域开发者便丧失将模型拆解为有意义片段的能力。</ins>

<ins>保持简单最为可取。应选择最少的、对技术环境至关重要或切实有助于开发的分割规则。例如，将复杂的数据持久化代码与对象的行为层面解耦，可能使重构更容易。</ins>

<ins>**除非确实有意在不同服务器上分发代码，否则应将实现单一概念对象的所有代码保留在同一个`MODULE`中，即使不是同一个对象。**</ins>

我们本可援引经典原则 “高内聚/低耦合” 得出相同结论。实现业务逻辑的 “对象” 与负责数据库访问的对象之间存在大量关联，导致耦合度极高。

框架设计或公司/项目的惯例还存在其他陷阱，它们可能通过模糊领域对象的自然内聚性来削弱 [MODEL-DRIVEN DESIGN](../ch3/1.md) ，但本质问题如出一辙：这些限制（或仅仅是庞大的必需包数量）排除了采用其他更契合领域模型需求的封装方案的可能性。

<ins>**使用包 (packaging) 将领域层与其他代码分离。否则，尽可能为领域开发者保留自由度，使其能够以支持其模型和设计选择的方式封装领域对象。**</ins>

有一个例外情况是当代码是基于声明性设计生成的（ [第 10 章](../ch10/0.md) 讨论）。在这种情况下，开发人员不需要阅读代码，最好将其放入一个单独的包中，这样可以避免干扰，不会使开发人员实际需要处理的设计元素变得杂乱。

<ins>随着设计变得更大、更复杂，模块化变得更加关键。
本节介绍了基本的考虑因素。[第四部分：战略设计](../part4.md) 提供打包和分解大型模型和设计的方法，以及为人们提供焦点以引导理解的方式。</ins>

领域模型中的每一个概念都应在实现元素中得到体现。[ENTITIES](2.md) 、[VALUE OBJECTS](3.md) 及其关联关系，以及少数领域 [SERVICES](4.md) 和组织`MODULES`，都是实现与模型之间直接对应的点。实现中的对象、指针和检索机制必须直接、明显地映射到模型元素。如果没有做到，应清理代码，回去修改模型，或两者兼顾。

抵制在领域对象中添加与它们所代表的概念关系不大的任何内容的诱惑。这些设计元素有其应尽的职责：它们表达模型。为了让系统正常运行，还有其他与领域相关的职责需要执行，以及其他数据需要管理，但它们不属于这些对象。在 [第 6 章](../ch6/0.md)，我将讨论一些支持性对象，它们承担领域层的技术职责，例如定义数据库搜索和封装复杂的对象创建。

本章中的四种模式为对象模型提供了构建模块。但 [MODEL-DRIVEN DESIGN](../ch3/1.md) 并不意味着必须将所有内容都强行套入对象模型。还有其他工具支持的模型范式，例如规则引擎。项目必须在它们之间做出务实的权衡。这些其他工具和技术是实现 [MODEL-DRIVEN DESIGN](../ch3/1.md) 的补充手段，而不是替代方法。

#### ▶[下一节](6.md)
