## 服务：`SERVICES`

#### ▶[上一节](3.md)

![part 2.5](../img/part2.5.png)

有时，它根本不存在。

在某些情况下，最清晰务实的设计包含着概念上不属于任何对象的操作。与其强行处理，不如顺应问题空间的自然轮廓，在模型中明确纳入`SERVICES`。

🌼🌼🌼

某些重要的领域操作无法自然地归属于 [ENTITY](2.md) 或 [VALUE OBJECT](../glossary.md#value-object) 。其中部分操作本质上属于活动或行为，而非实体，但由于我们的建模范式基于对象，我们仍试图将它们纳入对象范畴。

如今更常见的错误是过早放弃将行为适配到合适对象的尝试，逐渐滑向过程式编程。但当我们强行将操作塞入不符合对象定义的实体时，该对象便会丧失概念清晰度，变得难以理解或重构。复杂操作极易淹没简单对象，使其角色模糊不清。由于这类操作往往需要整合多个领域对象，协调它们并付诸行动，新增的职责将导致所有对象间产生依赖关系，使本可独立理解的概念相互纠缠。

有时服务会伪装成模型对象，表现为仅执行特定操作而毫无意义的实体。这类 “执行者” 最终往往冠以 “Manager” 之类的名称。它们既无自身状态，在领域中也仅承载操作功能而无其他意义。不过，至少这种方案能为这些独立行为提供归宿，同时避免破坏真正的模型对象。

<ins>**某些领域概念并不适合以对象形式建模。若强行要求领域功能由 [ENTITY](2.md) 或`VALUE`承担，要么会扭曲基于模型的对象定义，要么会添加毫无意义的人为对象。**</ins>

[SERVICE](../glossary.md#service) 是一种作为接口提供的操作，在模型中独立存在，不包含状态，这与 [ENTITIES](2.md) 和`VALUE OBJECTS`不同。`SERVICES`是技术框架中的常见模式，但也可应用于领域层。

名称 *服务* 强调与其他对象的关系。<ins>不同于 [ENTITIES](2.md) 和`VALUE OBJECTS`，它完全基于能为客户端提供何种功能来定义。[SERVICE](../glossary.md#service) 通常以活动而非实体命名 —— 动词而非名词。[SERVICE](../glossary.md#service) 仍可具有抽象的、意图性的定义，只是其定义风格与对象定义不同。[SERVICE](../glossary.md#service) 仍需明确职责范围，其职责及实现接口应作为领域模型组成部分进行定义。操作名称应源自 [UBIQUITOUS LANGUAGE](../ch2/1.md) 或被引入其中。参数与结果均应为领域对象。</ins>

[SERVICE](../glossary.md#service) 应审慎使用，不可剥夺 [ENTITIES](2.md) 和`VALUE OBJECTS`拥有的行为。但当某项操作实为重要领域概念时，[SERVICE](../glossary.md#service) 便成为 [MODEL-DRIVEN DESIGN](../ch3/1.md) 中自然的组成部分。在模型中将其声明为 [SERVICE](../glossary.md#service) 而非虚假对象 (phony object)，后者实际上不代表任何实体，独立操作便不会误导任何人。

<ins>优质的 [SERVICE](../glossary.md#service) 具备三个特征：</ins>
1. <ins>该操作涉及领域概念，且该概念并非 [ENTITY](2.md) 或 [VALUE OBJECT](../glossary.md#value-object) 的天然组成部分。</ins>
2. <ins>接口通过领域模型中的其他元素进行定义。</ins>
3. <ins>该操作是无状态的。</ins>

无状态在此指的是，任何客户端均可使用特定 [SERVICE](../glossary.md#service) 的任意实例，而无需考虑该实例的个体历史。 [SERVICE](../glossary.md#service) 执行时将使用全局可访问的信息，甚至可能改变该全局信息（即可能产生副作用）。但该 [SERVICE](../glossary.md#service) 本身并不持有影响其自身行为的状态，这与大多数领域对象的行为不同。

<ins>**当领域中某项重要流程或转换不属于 [ENTITY](2.md) 或 [VALUE OBJECT](../glossary.md#value-object) 的天然职责时，应向模型添加操作，将其作为独立接口声明为 [SERVICE](../glossary.md#service) 。使用模型语言定义该接口，并确保操作名称属于 [UBIQUITOUS LANGUAGE](../ch2/1.md) 范畴。该 [SERVICE](../glossary.md#service) 应为无状态服务。**</ins>

🌼🌼🌼

### 服务与隔离领域层

<ins>**该模式聚焦于那些在领域中具有独立重要意义的`SERVICES`，当然`SERVICES`并非仅用于领域层。需小心区分属于领域层的`SERVICES`与其他层的`SERVICES`，并通过职责分解来保持这种区分的清晰。**</ins>

<ins>**文献中讨论的大多数`SERVICES`纯粹属于技术范畴，归属于基础设施层。领域和应用`SERVICES`与这些基础设施`SERVICES`协同工作。例如，某银行可能部署了这样一个应用程序：当客户账户余额低于特定阈值时，该程序会向客户发送电子邮件。封装电子邮件系统（以及可能的其他通知方式）的接口，即属于基础设施层的`SERVICES`。**</ins>

<ins>**区分应用`SERVICES`与领域`SERVICES`往往更为困难。应用层负责通知的排序，领域层则负责判定阈值是否达到 —— 尽管这项任务可能无需调用 [SERVICE](../glossary.md#service) ，因为它更符合 “账户” 对象的职责范畴。该银行应用程序可承担资金转账功能。若设计 [SERVICE](../glossary.md#service) 来执行资金转账的借贷操作，该功能应归属于领域层。资金转账在银行业领域语言中具有明确含义，涉及核心业务逻辑。技术`SERVICES`则应完全脱离业务含义。**</ins>

许多领域或应用`SERVICES`都是基于 [ENTITIES](2.md) 和`VALUES`构建的，它们如同脚本般组织领域潜力以实现具体功能。[ENTITIES](2.md) 和`VALUE OBJECTS`往往过于精细化，难以便捷地调用领域层的能力。此时我们面临领域层与应用层的微妙界限。例如，当银行应用能将交易数据转换为电子表格文件供分析时，该导出功能即属于应用 [SERVICE](../glossary.md#service) 服务。银行领域本身并不涉及 “文件格式” 概念，且此类操作不包含业务规则。

另一方面，能够在账户间转移资金的功能属于领域 [SERVICE](../glossary.md#service) ，因为它包含重要的业务规则（例如对相应账户进行借记和贷记），且“资金转移”本身是具有明确含义的银行术语。在此情境下，该 [SERVICE](../glossary.md#service) 本身并无实质操作，主要会调用两个`Account`对象完成核心工作。但若将 “转账” 操作直接赋予`Account`对象则显得不妥，因为该操作涉及两个账户及若干全局规则。

我们或许希望创建一个`Funds Transfer`对象，用来表示两个条目以及转账相关的规则和历史记录。但跨行网络中仍需调用`SERVICES`接口。更何况，在大多数开发系统中，直接在领域对象与外部资源之间建立接口并不妥当。我们可以为这类外部`SERVICES`设计一个`FACADE`，使其接受模型形式的输入，并可能返回`Funds Transfer`对象作为结果。但无论存在何种中间环节，即使它们不属于我们，这些`SERVICES`都在执行资金转账这一领域职责。

**将服务分层**
- 应用层
  * Funds Transfer App Service
    - 处理输入（例如XML请求）。
    - 将消息发送至领域服务进行处理。
    - 等待确认响应。
    - 决定是否通过基础设施服务发送通知。
- 领域层
  * Funds Transfer Domain Service
    - 与必要的`Account`和`Ledger`对象交互，执行相应的借方和贷方记账。
    - 提供结果确认（转账是否允许等）。
- 基础设施层
  * Send Notification Service
    - 根据应用程序的指示发送电子邮件、信函及其他通讯方式。

### 粒度

尽管本模式讨论着重强调了将概念建模为 [SERVICE](../glossary.md#service) 所具备的表达力，但该模式同样具有重要价值，它既能控制领域层接口的粒度，又能实现客户端与 [ENTITIES](2.md) 和`VALUE OBJECTS`对象的解耦。

中等粒度、无状态的`SERVICES`在大型系统中更易复用，因为它们能将重要功能封装在简洁的接口背后。此外，在分布式系统中，过细粒度的对象可能导致消息传递效率低下。

如前所述，精细化的领域对象可能导致知识从领域层向应用层泄露，应用层正是协调领域对象行为的场所。高度细化的交互复杂性最终需由应用层处理，这使得领域知识逐渐渗透到应用程序或用户界面代码中，从而从领域层中消失。审慎引入领域服务有助于维持各层之间的清晰界限。

该模式优先考虑接口简洁性，而非客户端控制与多功能性。它提供中等粒度功能，在封装大型或分布式系统的组件时极为实用。有时，[SERVICE](../glossary.md#service) 正是表达领域概念最自然的方式。

### 服务访问

分布式系统架构（如 J2EE 和 CORBA ）为`SERVICES`提供了特殊的发布机制及其使用规范，并增强了分布式处理与访问能力。但此类框架并非总能在项目中应用，即便采用，当需求仅限于逻辑关注点分离时，它们往往显得过度复杂。

提供 [SERVICE](../glossary.md#service) 访问的手段并不如划分具体职责的设计决策重要。作为 [SERVICE](../glossary.md#service) 接口的实现，一个 “执行者” 对象可能已足够。通过简单的`SINGLETON`模式（ [Gamma等，1995](../references.md#gamma-1995) ）即可轻松实现访问功能。编码规范应明确指出此类对象仅作为 [SERVICE](../glossary.md#service) 接口的交付机制，而非具有业务意义的领域对象。复杂架构的应用，仅在存在真实的系统分布需求，或需调用框架功能时采用。

#### ▶[下一节](5.md)
