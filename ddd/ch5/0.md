## 第 5 章 软件表达的模型

#### ▶[上一节](../ch4/4.md)

要在实现过程中做出妥协，同时又不削弱 [MODEL-DRIVEN DESIGN](../ch3/1.md) 的核心价值，就需要重新构建基础。模型与实现的连接必须在细节层面完成。本章聚焦于这些独立的模型元素，使其具备支撑后续章节活动的形态。

本次讨论将从设计和优化关联关系入手。对象间的关联关系在构思和绘制时看似简单，但实际实现却可能陷入泥潭。关联关系充分说明了细节实现决策对  [MODEL-DRIVEN DESIGN](../ch3/1.md) 可行性的关键作用。

转向对象本身，但继续审视详细模型选择与实现关切之间的关系，我们将重点区分表达模型的三种模型元素的模式：[ENTITIES](../ch5/2.md) 、[VALUE OBJECTS](3.md) 和`SERVICES`。

定义能够捕捉领域概念的对象，表面上看似直观易懂，但语义的细微差别中却潜藏着严峻挑战。某些关键区分的出现，既厘清了模型元素的含义，又与一系列设计实践相衔接，从而能够精准塑造特定类型的对象。

<ins>对象是否代表具有连续性和身份特征的事物 —— 即能够在不同状态甚至不同实现中被追踪的事物？抑或它只是描述其他事物状态的属性？这正是`ENTITY`与 [VALUE OBJECT](3.md) 之间的根本区别</ins>。定义遵循其中一种模式的对象，能降低对象的模糊性，并为实现稳健设计铺就明确的决策路径。

<ins>领域中还有些方面更适合用动作或操作来表达，而非对象。尽管这略有偏离面向对象建模的传统，但通常最好将这些表达为服务`SERVICES`，而非强行将操作的责任强加给某个`ENTITY`或 [VALUE OBJECTS](3.md) </ins>。`SERVICE` 是应客户端请求执行的操作。在软件的技术层中存在大量 `SERVICES`，当领域中建模出某些活动时，这些服务也会自然出现，这些活动对应着软件必须完成的任务，但与状态无关。

在某些不可避免的情况下，对象模型的纯粹性必须做出妥协，例如存储在关系数据库中时。本章将提出一些指导原则，帮助你在被迫应对这些复杂现实时保持方向。

最后，关于`MODULES`的讨论将强调一个核心观点：每个设计决策都应基于对领域本身的深刻理解。高内聚与低耦合这些常被视为技术指标的概念，同样适用于概念本身。在 [MODEL-DRIVEN DESIGN](../ch3/1.md) 中，`MODULES`作为模型的一部分，应当反映领域中的概念本质。

本章整合了所有这些构成模块，它们在软件中体现了该模型。这些理念属于传统范畴，由此衍生的建模与设计偏好此前已有论述。但在本语境下重新梳理这些理念，将有助于开发者创建满足领域驱动设计优先级需求的精细化组件，从而应对更宏大的模型与设计问题。同时，对基本原则的把握能帮助开发者在不可避免的权衡取舍中保持方向。

#### ▶[下一节](1.md)
