## 演进的秩序：`EVOLVING ORDER`

#### ▶[上一节](0.md)

许多开发者都曾体会过无结构设计的代价。为避免混乱，项目往往强加各种架构来限制开发。某些技术架构确实能解决技术问题，例如网络通信或数据持久化，但当架构开始涉足应用程序和领域模型领域时，它们本身就会引发问题。这些架构常常阻碍开发者创建契合具体问题特性的设计与模型。最激进的架构甚至剥夺了应用开发者对编程语言本身的熟练运用与技术掌控力。无论技术导向还是领域导向，那些预先冻结大量设计决策的架构，在需求变化和认知深化时，终将沦为束缚创新的枷锁。

尽管某些技术架构（如 J2EE ）在过去几年中日益突出，但领域层的大规模结构尚未得到充分探索。不同应用程序的需求差异极大。

在前期强行采用大规模架构很可能代价高昂。随着开发推进，你几乎肯定会找到更合适的架构，甚至可能发现预设架构限制了你选择能大幅简化应用的设计路径。虽然部分架构或许可用，但你正在错失机遇。当你忙于寻找变通方案或与架构师协商时，工作进度必然放缓。但管理者认为架构已然完成。既然它本应让应用开发更轻松，为何你还在处理架构问题而非专注开发？管理者和架构团队或许愿意听取意见，但若每次变更都需经历艰苦卓绝的斗争，终将令人精疲力竭。

<ins>**设计自由放任会产生无人能理解整体的系统，且极难维护。但架构又可能用预设的设计假设束缚项目，过度剥夺应用程序各部分开发者/设计者的自主权。很快，开发者要么降低应用程序复杂度以适应结构，要么直接破坏结构导致彻底失序，最终重蹈开发失调的覆辙。**</ins>

问题不在于指导规则的存在，而在于这些规则的僵化程度及其来源。如果设计规则真正契合实际情况，它们不仅不会成为阻碍，反而能推动开发朝着有益的方向前进，同时确保一致性。

因此：

<ins>**让这个概念性的大型结构随应用发展而演变，过程中可能转变为完全不同的结构类型。不要过度限制那些必须基于详细知识才能做出的具体设计和模型决策。**</ins>

各个部分存在自然或实用的组织与表达方式，这些方式未必适用于整体，因此强行套用全局规则会降低这些部分的理想性。选择采用大规模结构时，更注重整体模型的可管理性而非单个部分的最优结构。因此，统一结构与自由表达组件自然特性的需求之间必然存在权衡。可通过基于领域实际经验与知识选择结构，并避免过度约束的结构来缓解此矛盾。当结构与领域及需求高度契合时，反而能通过快速排除大量选项，使细节建模与设计更为简便。

该结构还能为设计决策提供捷径，这些决策原则上可通过逐个对象层级的工作获得，但在实践中耗时过长且结果不尽一致。当然，持续重构依然必要，但这将使该过程更易于管理，并有助于不同人员得出一致的解决方案。

大规模结构通常需要适用于多个 [BOUNDED CONTEXT](../ch14/1.md) 。通过在实际项目中的迭代演进，架构将逐步剥离与特定模型紧密耦合的特性，并发展出与领域 [CONCEPTUAL CONTOURS](../ch10/4.md) 相契合的功能。这并非意味着架构对模型毫无假设，而是避免将针对局部场景的定制化方案强加于整个项目。它必须为不同`CONTEXTS`中的开发团队保留自由度，使其能够根据本地化需求灵活调整模型。

此外，大型结构必须适应开发过程中的实际限制。例如，设计者可能无法控制系统某些部分的模型，尤其当涉及外部或遗留子系统时。对此可通过调整结构以更好地适应特定外部元素来处理；也可通过明确应用程序与外部系统的交互方式来处理；还可通过使结构足够松散，使其能够灵活应对棘手的现实情况来处理。

与 [CONTEXT MAP](../ch14/3.md) 不同，大规模结构是可选的。当成本效益分析支持采用该结构且找到合适的结构时，应予以实施。事实上，对于分解为 [MODULES](../ch5/5.md) 后仍能被理解的简单系统，该结构并非必需。<ins>**当能找到既能显著澄清系统结构，又不强加于模型开发不自然约束的框架时，应应用大规模结构。由于不合适的结构比没有结构更糟糕，因此最好不要追求全面性，而应寻找能解决已出现问题的最小化框架。少即是多。**</ins>

大规模结构在保持有效性的同时仍可容纳少量例外，但这些例外必须以某种方式标记出来，以便开发者在未特别说明的情况下默认遵循该结构。若例外情况开始增多，则需调整或废弃该结构体系。

🌼🌼🌼

如前所述，构建既能赋予开发者必要自由度又能避免混乱的架构绝非易事。尽管软件系统的技术架构已取得诸多进展，但关于领域层结构化的研究却鲜有问世。某些方法削弱了面向对象范式，例如按应用任务或用例分解领域的做法。这一领域仍处于未开发状态。我在多个项目中观察到若干大型结构的通用模式，本章将探讨其中四种。其中或许有适合您需求的方案，或能激发您设计项目专属结构的灵感。

#### ▶[下一节](2.md)
