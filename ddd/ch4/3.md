## 智能 UI 的 “反模式”

#### ▶[上一节](2.md)

……这概括了广为接受的面向对象应用程序 [LAYERED ARCHITECTURES](../glossary.md#layered-architecture) 模式。但这种将用户界面、应用程序和领域分离的做法屡屡尝试却鲜有成功，其反面现象本身就值得单独探讨。

许多软件项目确实采用且应当继续采用一种更为简化的设计方法，我称之为 `SMART UI`。但 `SMART UI` 是另一条互斥的分岔路，与领域驱动设计的方法不相容。若选择这条道路，本书大部分内容便不再适用。我关注的是 `SMART UI` 无法适用的场景，因此我戏称其为 “反模式”。在此讨论它能形成有益对照，并有助于厘清本书后续章节所采取更艰难路径的合理情境。

🌼🌼🌼

该项目需实现基础功能，以数据录入和显示为主，业务规则较少。团队成员并非专业的对象建模人员。

<ins>**若一个经验不足的团队决定在一个简单项目中用 [LAYERED ARCHITECTURES](../glossary.md#layered-architecture) 尝试 [MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design) ，他们将面临陡峭的学习曲线。团队成员必须掌握复杂的新技术，并在对象建模的学习过程中跌跌撞撞（即便借助本书指导，这仍充满挑战！）。管理基础设施和架构层级的开销，会让简单任务耗时倍增。而简单项目往往时间紧迫且期望值不高。在团队完成既定任务之前，还没来得及展示其方法的令人心动的潜力时，项目很可能早已被取消。**</ins>

<ins>**即使给予团队更多时间，成员们在缺乏专家指导的情况下仍难以掌握相关技术。即便最终克服了这些挑战，他们所构建的系统也只会是简单版本。因为丰富功能从未被纳入需求范围。**</ins>

经验更丰富的团队不会面临同样的取舍困境。资深开发者能够降低学习成本，压缩管理各层所需的时间。领域驱动设计在雄心勃勃的项目中能发挥最大效益，但确实需要扎实的技术功底。并非所有项目都雄心勃勃，也并非所有项目团队都能具备这些技能。

因此，当情况允许时：

<ins>**将所有业务逻辑置于用户界面中。将应用程序拆解为小型功能模块，并将其实现为独立的用户界面，同时将业务规则嵌入其中。采用关系型数据库作为数据共享存储库。使用现有的最自动化用户界面构建工具和可视化编程工具。**</ins>

异端邪说！普遍公认的正道（包括本书其他章节所倡导的）是领域与用户界面应当分离。事实上，若不进行这种分离，本书后文讨论的任何方法都难以实施，因此在领域驱动设计背景下，这种 `SMART UI` 可视为 “反模式”。但在其他情境中，它却是有效的模式。诚然，`SMART UI` 具备独特优势，在特定场景下能发挥最佳效能，这正是其广泛流行的部分原因。<ins>在此探讨该模式有助于我们理解：为何需要将应用层与领域层分离，以及更关键的是，何时不应进行分离。</ins>

### 优势
- 简单应用程序可立即实现高生产力。
- 能力较弱的开发人员经过少量培训即可采用此方式工作。
- 即使需求分析存在缺陷，也可通过向用户发布原型，再快速调整产品以满足其需求来弥补。
- 应用程序彼此解耦，因此小型模块的交付进度可相对精确规划。通过添加简单功能扩展系统变得容易。
- 关系型数据库运行良好，可在数据层实现集成。
- 四代语言工具运行高效。
- 应用移交时，维护程序员能快速重构无法理解的部分，因变更影响仅局限于特定用户界面。

### 缺点
- 除通过数据库外，应用程序集成困难。
- 行为无法复用，业务问题缺乏抽象化处理。业务规则必须在每个适用操作中重复实现。
- 快速原型开发与迭代面临天然瓶颈，因抽象层缺失限制了重构选项。
- 复杂性会迅速吞噬开发效率，导致增长路径仅限于添加简单应用程序，无法优雅地实现行为丰富化。

若能有意识地应用这种模式，团队便可避免承担其他方法所需的大量开销。常见的错误是采用复杂的设计方法，却未能坚持贯彻到底。另一种常见且代价高昂的错误，是为根本不需要的项目构建复杂的基础设施并使用工业级工具。

对于这类应用，大多数灵活的语言（如 Java ）都属于过度设计，将带来高昂代价。采用四代语言风格的工具才是明智之选。

<ins>请记住，这种模式的后果之一是：除非替换整个应用程序，否则无法迁移到其他设计方案</ins>。仅使用 Java 这类通用语言并不能让你日后真正摆脱 `SMART UI` 的束缚，因此若已选择此路径，就应选用与其配套的开发工具。不必试图规避风险。仅使用灵活的语言并不能创造出灵活的系统，反而可能导致系统成本高昂。

同样地，致力于 [MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design) 的团队必须从一开始就采用这种设计方式。当然，即便是雄心勃勃的资深项目团队，也必须从基础功能起步，通过持续迭代逐步完善。但这些初步探索必须采用 `MODEL-DRIVEN` 的方式，建立独立的领域层，否则项目很可能永远停留在 `SMART UI` 阶段。<ins>我们讨论 `SMART UI`，正是为了阐明为何及何时需要 [LAYERED ARCHITECTURES](../glossary.md#layered-architecture) 等模式来实现领域层的隔离。</ins>

🌼🌼🌼

在 `SMART UI` 和 [LAYERED ARCHITECTURES](../glossary.md#layered-architecture) 之间还存在其他解决方案。例如，[Fowler（2002）](../references.md#fowler-2003)提出的 `TRANSACTION SCRIPT` 将用户界面与应用程序分离，但未提供对象模型。核心要义在于： *若架构能将领域相关代码隔离，使领域设计保持凝聚力且与系统其余部分松散耦合，那么该架构通常可支持领域驱动设计* 。

其他开发风格各有其用武之地，但你必须接受它们在复杂性和灵活性方面存在不同程度的限制。在某些场景下，若未能解耦领域设计，后果可能极其严重。若你正在开发复杂应用且决心采用 [MODEL-DRIVEN DESIGN](../glossary.md#model-driven-design) ，请咬紧牙关，聘请必要专家，并 *避免* 使用 `SMART UI`。

#### ▶[下一节](4.md)
