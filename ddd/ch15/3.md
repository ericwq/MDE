## 通用子领域：`GENERIC SUBDOMAINS`

#### ▶[上一节](2.md)


<ins>**模型中的某些部分增加了复杂性，却未能捕捉或传达专业知识。任何多余的内容都会使 [CORE DOMAIN](1.md) 更难辨识和理解。模型被充斥着人人皆知的通用原则，或是属于非核心领域但具有辅助作用的细节。然而，无论多么通用，这些其他元素对系统的运行和模型的完整表达都至关重要。**</ins>

你的模型中有个部分你希望将其视为理所当然。它无疑属于领域模型的一部分，但它抽象出的概念很可能被众多企业所需要。例如，从航运、银行到制造业等不同行业的企业，都以某种形式需要组织架构图。再比如，许多应用程序会追踪应收账款、费用账簿及其他财务事项，这些都可通过通用会计模型来处理。

在该领域中，人们常常将大量精力耗费在次要问题上。我亲眼目睹过两个独立项目，各自耗费数周时间让顶尖开发者重新设计带时区的日期和时间功能。虽然这类组件必须正常运作，但它们并非系统的核心概念。

即使此类通用模型元素被视为关键，整体领域模型仍需突出系统最具价值和独特的方面，并通过结构设计赋予该部分最大能力。当 [CORE](1.md) 与所有相关因素混杂时，实现这一点将变得困难。

因此：

<ins>**识别出那些不属于项目动机的内聚性子领域。将这些子领域的通用模型提取出来，置于独立的 [MODULES](../ch5/5.md) 中。确保其中不留有任何专有特性的痕迹。**</ins>

<ins>**一旦完成分离，应降低这些领域的持续开发优先级，使其低于 [CORE DOMAIN](1.md) ，并避免安排核心开发人员参与相关任务（因其难以从中获取领域知识）。同时可考虑为这些`GENERIC SUBDOMAINS`采用现成解决方案或已发布的模型。**</ins>

🌼🌼🌼

在开发这些软件包时，您可能会有一些额外的选项。

#### 选项 1：现成解决方案

有时您可以购买现成的实现方案或使用开源代码。

优势
- 开发代码量更少。
- 维护负担外部化。
- 代码可能更成熟，被多处采用，因此比自研代码更稳健且更完善。

缺点
- 使用前仍需花费时间评估和理解其功能。
- 鉴于我们行业质量控制的现状，无法保证其正确性和稳定性。
- 可能存在过度设计的情况；集成工作量可能超过采用极简自研方案所需。
- 外部元素通常难以无缝集成。可能存在独立的 [BOUNDED CONTEXT](../ch14/1.md) 。即使不存在，也可能难以从其他包中顺畅引用 [ENTITIES](../ch5/2.md) 。
- 可能引入平台依赖、编译器版本依赖等因素。

现成的子领域解决方案值得研究，但通常不值得费心。我见过一些成功案例：在具有极其复杂工作流需求的应用中，通过 API 钩子使用市售的外部工作流系统取得了成效。我也见过将错误日志包深度集成到应用中的成功案例。有时`GENERIC SUBDOMAINS`解决方案会以框架形式打包，它们实现高度抽象的模型，可与应用集成并进行定制化适配。子组件越通用，其模型越精炼，就越有可能真正发挥价值。

#### 选项 2：公开的设计或模型

优势
- 比自建模型更成熟，凝聚了众多用户的洞见
- 即时获取高质量文档

缺点
- 可能无法完全契合需求，或存在过度设计的情况

Tom Lehrer（1950 至 1960 年代的喜剧歌曲作家）曾说数学成功的秘诀是：“剽窃！剽窃！让任何人的成果都逃不过你的眼睛……但务必记得称之为 *研究* 。” 这在领域建模中是条好建议，尤其当你想解决`GENERIC SUBDOMAINS`时。

这种方法在存在广泛分布的模型时效果最佳，例如 *《Analysis Patterns》* （ [Fowler 1997](../references.md#fowler-1997) ）中所述的模型。（参见 [第 11 章](../ch11/0.md) 。）

当某个领域已存在高度形式化且严谨的模型时，请直接采用。会计学和物理学便是两个典型的例子。这些模型不仅结构稳健、流程精简，更被全球各地人士广泛理解，从而减轻你当前及未来的培训负担。（详见 [第 10 章](../ch10/0.md) 关于运用成熟形式化的内容。）

不必勉强实现已发布模型的所有方面，只要你能识别出一个简化子集，该子集既自洽又满足你的需求即可。但当存在一个成熟可靠且文档完善 ——更理想的是经过形式化定义—— 的模型时，重新发明轮子就毫无意义。

#### 选项 3：外包实现

优势
- 让核心团队能够专注于 [CORE DOMAIN](1.md) ，这里是知识最需要积累的地方。
- 可以在不永久扩大团队的情况下完成更多开发，同时不会分散对 [CORE DOMAIN](1.md) 的知识。
- 强制接口导向设计，并有助于保持子领域的通用性，因为规范 (specification) 是传递到外部的。

缺点
- 仍需核心团队投入时间，因为接口、编码规范及其他重要事项需要沟通。
- 代码所有权回传内部会产生显著开销，因为需要理解代码。（不过开销仍低于专业子领域，因为通用模型理解起来通常无需特殊背景。）
- 代码质量可能参差不齐。这可能有利也有弊，具体取决于两个团队的相对实力。

自动化测试在外包过程中可发挥重要作用。实施方应被要求为交付的代码提供单元测试。一种真正强大的方法是为外包组件指定甚至编写自动化验收测试。（既能保障质量水平、明确规格要求，又能促进重新集成）此外，[外包实现](#选项-3外包实现) 与 [公开的设计或模型](#选项-2公开的设计或模型) 相结合，可形成绝佳的组合方案。

#### 选项 4：内部实现

优势
- 集成便捷。
- 完全按需定制，无冗余功能。
- 可灵活调配临时承包商。

劣势
- 持续维护与培训负担。
- 易低估此类软件包的开发时长与成本。

当然，此方案同样可与 [公开的设计或模型](#选项-2公开的设计或模型) 方案结合使用。

`GENERIC SUBDOMAINS`是尝试应用外部设计专家的地方，因为它们不需要对你的专业 [CORE DOMAIN](1.md) 有深入的理解，也不会提供学习该领域的重大机会。保密性问题较小，因为这些模块涉及的专有信息或业务实践很少。对于那些不致力于深入了解该领域的人来说，`GENERIC SUBDOMAINS`可以减轻培训负担。

随着时间的推移，我相信我们对什么构成 [CORE](1.md) 模型的概念会变得更加狭窄，并且会有越来越多的通用模型可作为实施框架提供，或者至少作为已发布的模型或分析模式。目前，我们仍然需要自己开发大部分这些模型，但将它们与 [CORE DOMAIN](1.md) 模型区分开来具有很大的价值。

#### 示例：两个时区的故事

我曾两次目睹项目中最优秀的开发者耗费数周时间解决时区时间存储与转换的问题。虽然我对此类工作始终心存疑虑，但有时确实不可避免，这两个项目恰好形成了近乎完美的对比。

最初的尝试是设计用于航运调度的软件。要安排国际运输，精确的时间计算至关重要，而由于所有运输计划都以当地时间为准，若不进行时区转换就无法协调运输。

在明确确认该功能需求后，团队利用现有时间类和部分虚拟数据，着手开发 [CORE DOMAIN](1.md) 及应用程序的早期版本。随着应用程序逐渐成熟，现有时间分类体系明显不足的问题显现出来。由于各国时区差异及国际日期变更线的复杂性，该问题变得极其棘手。此时需求已愈发清晰，团队尝试寻找现成解决方案却无果而终，最终只能选择自主开发。

这项任务需要研究和精密工程技术，因此团队负责人指派了他们最优秀的程序员之一。但该任务并不需要任何航运方面的专业知识，也不会培养这方面的知识，所以他们最终选定了一位以临时合同形式参与项目的程序员。

这位程序员并非从零开始。他研究了多个现有的时区实现方案，其中多数未能满足需求，最终决定采用 BSD Unix 的公共领域解决方案，该方案拥有完善的数据库及 C 语言实现。他通过逆向工程解析其逻辑，并编写了数据库导入程序。

问题最终比预期的更为棘手（如涉及特殊案例数据库的导入），但代码最终完成编写并集成到 [CORE](1.md) 中，产品如期交付。

另一个项目的情况则截然不同。某保险公司正在开发一套新的理赔处理系统，计划采集各类事件发生的时间（如车祸时间、冰雹灾害时间等）。由于这些数据将以本地时间记录，因此需要实现时区功能。

当我抵达时，他们已指派了一位资历尚浅但非常聪明的开发者负责此任务，尽管应用程序的具体需求仍在讨论中，甚至尚未尝试过初始迭代。他已尽职尽责地着手构建一个先验时区模型。

由于不清楚具体需求，人们认为代码必须足够灵活以应对任何情况。负责该任务的程序员面对如此棘手的问题需要支援，于是又指派了一位资深开发者参与。他们编写了复杂的代码，但由于没有具体应用程序在使用它，因此始终无法确认代码是否运行正确。

该项目因种种原因搁浅，时区代码最终未被采用。但若当时启用该方案，仅需存储标注时区的本地时间便已足够，即便不进行转换也无妨，因为这些数据主要用于参考而非计算基础。即便最终需要转换，所有数据都将来自北美地区，该区域的时区转换相对简单。

对时区问题的过度关注，其主要代价在于忽视了 [CORE DOMAIN](1.md) 模型。若将同等精力投入该领域，他们本可产出自身应用程序的可运行原型，并初步构建出可运作的领域模型。此外，长期参与该项目的开发人员本应深入保险领域，在团队内部积累关键知识。

这两个项目都做对了一点：将`GENERIC`时区模型与 [CORE DOMAIN](1.md) 彻底分离。若采用运输业专用或保险业专用的时区模型，就会将该模型与通用支持模型耦合，导致 [CORE](1.md) 模型更难理解（因为它会包含无关的时区细节）。这将导致时区的 [MODULE](../ch5/5.md) 更难维护（因为维护者必须理解 [CORE](1.md) 及其与时区的关联关系）。

|航运项目策略| 保险项目策略|
|----|----|
|优势|优势|
|- `GENERIC`模型与`CORE`模型解耦。|- `GENERIC`模型与`CORE`模型解耦。|
|- `CORE`模型成熟，可调配资源而不影响其发展。| |
|- 需求明确。| |
|- 具备国际调度关键支持功能。| |
|- 采用短期合同制程序员处理通用任务。| |
|劣势|劣势|
|- 核心项目调离顶尖程序员。|- `CORE`模型开发不足，导致其他问题持续分散关注。|
| |- 需求不明导致追求完全通用性，而仅需针对北美地区的简单转换方案即可满足。|
| |- 长期编程人员被调离岗位，他们本可成为领域知识的宝库。|

我们技术人员往往喜欢处理时区转换这类可定义的问题，并能轻松为投入时间辩护。但严谨地审视优先级时，通常会指向 [CORE DOMAIN](1.md) 。

### 通用性不等于可复用性

请注意，虽然我强调了这些子领域的通用性，但并未提及代码的可复用性。现成解决方案在特定场景下可能适用也可能不适用，但若你正自行实现代码（无论内部开发或外包），则不应刻意关注代码的复用性。这违背了提炼法的基本宗旨：应尽可能将精力投入 [CORE DOMAIN](1.md) ，仅在必要时为`GENERIC SUBDOMAINS`提供支持。

<ins>复用确实存在，但并非总是代码复用。</ins>模型复用往往是更高级别的复用，例如使用已发布的设计或模型。即使需要创建自有模型，它也可能在后续相关项目中发挥价值。尽管此类模型的概念可能适用于多种场景，但无需开发完全通用的模型，只需针对业务需求建模并实现所需部分即可。

<ins>*虽然你很少需要为可复用性而设计，但必须严格遵循通用概念。* 引入行业特定的模型元素将带来双重代价。首先，它会阻碍未来发展。</ins>尽管当前仅需子领域模型的局部功能，但需求终将增长。任何超出概念范畴的设计引入，都会使系统扩展变得极其困难，若要实现干净利落的扩展，往往需要彻底重建旧有部分，并重新设计所有依赖它的模块。

<ins>第二个，也是更重要的原因在于，这些行业特定概念应当归属于 [CORE DOMAIN](1.md) 或其各自更专业的子领域，而这些专业模型比通用模型更为珍贵。</ins>

### 项目风险管理

敏捷流程通常要求通过提前处理风险最高的任务来管理风险。极限编程（XP）特别强调立即建立并运行端到端的系统。这个初始系统往往用于验证技术架构，人们容易被诱惑去构建处理某些辅助性`GENERIC SUBDOMAINS`的外围系统，因为这些领域通常更容易分析。但需谨慎：此举可能适得其反，反而违背了风险管理的初衷。

项目面临双重风险：部分项目技术风险突出，另一些则存在更显著的领域建模风险。端到端系统仅能通过其作为实际系统关键部分的雏形版本来缓解风险。领域建模风险极易被低估，其表现形式可能包括：未预见的复杂性、业务专家资源不足，或开发人员关键技能缺失。

因此，除非团队拥有成熟技能且领域极为熟悉，初始系统设计应基于 [CORE DOMAIN](1.md) 的某个部分，无论其多么简单。

这一原则同样适用于任何试图推进高风险任务的流程：[CORE DOMAIN](1.md) 之所以高风险，在于其往往存在意料之外的复杂性，且若缺乏该领域支撑，项目便无法成功。

本章中大多数提炼模式展示了如何调整模型和代码以提炼 [CORE DOMAIN](1.md) 。然而接下来的两个模式，[DOMAIN VISION STATEMENT](4.md) 和 [HIGHLIGHTED CORE](5.md) ，则说明了如何通过补充文档，以极小的投入提升对 [CORE](1.md) 的认知与沟通效果，并聚焦开发工作。……

#### ▶[下一节](4.md)
