## 抽象核心：`ABSTRACT CORE`

#### ▶[上一节](7.md)

<img src="../img/part4.12.png" width="70%" /></br>

即使是 [CORE DOMAIN](1.md) 模型，通常也包含大量细节，导致难以传递整体概览 (big picture)。

🌼🌼🌼

我们通常通过将大型模型拆解为可理解的细分子域，并将其封装在独立的 [MODULES](../ch5/5.md) 中来处理。这种简化式封装往往能使复杂模型变得可控。但有时创建独立 [MODULE](../ch5/5.md) 反而会模糊甚至复杂化子域间的交互关系。

<ins>**当不同 [MODULES](../ch5/5.md) 中的子域之间存在大量交互时，要么需要在 [MODULES](../ch5/5.md) 之间创建大量引用，这将削弱分区 (partitioning) 的价值；要么必须采用间接交互方式，但这会使得模型变得晦涩难懂。**</ins>

考虑采用水平切分而非垂直切分。多态性赋予我们忽略抽象类型实例间诸多细节差异的能力。<ins>若 [MODULES](../ch5/5.md) 间的多数交互可通过多态接口 (polymorphic interfaces) 层级表达，则将这些类型重构为专用的`CORE MODULE`或许更为合理。</ins>

我们这里并不是在寻找技术上的小技巧。只有当多态接口 (polymorphic interfaces) 能对应上领域中的基本概念时，这才是一种有价值的技术。在这种情况下，分离这些抽象可以在精炼出更小、更有凝聚力的 [CORE DOMAIN](1.md) 的同时，使 [MODULES](../ch5/5.md) 实现解耦。

因此：

<ins>**识别模型中最基本的概念，并将它们归入不同的类、抽象类或接口。设计这个抽象模型，使其表达大部分重要组件之间的交互。将这个抽象的整体模型放在其自身的 [MODULES](../ch5/5.md) 中，而具体的的、详细的实现类则留在由子域定义的各自 [MODULES](../ch5/5.md) 中。**</ins>

大多数具体的类现在将引用`ABSTRACT CORE MODULE`，而不会引用其他具体的 [MODULES](../ch5/5.md) 。`ABSTRACT CORE`提供了对主要概念及其交互的简明视图。

提取`ABSTRACT CORE`的过程并非机械操作。例如，若将所有在 [MODULES](../ch5/5.md) 间频繁引用的类自动移入独立 [MODULE](../ch5/5.md) ，很可能导致毫无意义的混乱。建模`ABSTRACT CORE`需要深刻理解关键概念，及其在系统核心交互中的作用。换言之，这是通过重构获得更深层洞察的典范，通常需要进行大量重新设计。

<ins>`ABSTRACT CORE`最终呈现的效果应与提炼文档高度相似（若两者均应用于同一项目，且提炼文档随应用程序发展及洞察加深而不断演进）。当然，`ABSTRACT CORE`将以代码形式编写，因而更严谨、更完整。</ins>

🌼🌼🌼

#### ▶[下一节](9.md)
