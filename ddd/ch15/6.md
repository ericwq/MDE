## 内聚机制：`COHESIVE MECHANISM`

#### ▶[上一节](5.md)

封装机制是面向对象设计的基本原则。将复杂的算法隐藏在具有意图明确名称的方法中，实现了 “做什么” 与 “如何做” 的分离。这种技术使设计更易于理解和使用，但它也存在天然的局限性。

<ins>**计算有时会达到某种复杂程度，开始使设计臃肿。概念性的 “做什么” 被机械性的 “如何做” 所淹没。大量提供问题解决算法的方法，反而模糊了表达问题本身的方法。**</ins>

<ins>这种程序的激增是模型存在问题的一个症状。</ins>通过重构以获得更深入的洞察，可以产生一个模型和设计，其元素更适合解决问题。首先要寻求的解决方案是使计算机制简单的模型。但时不时地，会出现这样的洞察：有些计算机制的本身在概念上是内聚的 (coherent)。这种概念性的计算可能不会涵盖你所需的所有杂乱计算。我们不是在谈论某种包罗万象的 “计算器”。但提取出连贯的部分应当使剩余的机制更易于理解。

因此：

<ins>**将概念上具有`COHESIVE MECHANISM`的组件拆分为一个独立的轻量级框架。尤其要关注形式化表达或有完善文档的算法范畴。通过 [INTENTION-REVEALING INTERFACE](../ch10/1.md) 暴露框架功能。此时领域中的其他元素可专注于表达问题（ “做什么” ），将解决方案的复杂细节（ “如何做” ）委托给框架处理。**</ins>

这些独立的机制随后被置于各自的辅助角色中，从而形成一个更小、更具表达力的 [CORE DOMAIN](1.md) ，该领域通过接口以更声明式的风格使用这些机制。

识别标准算法或形式化方法，能将设计中的部分复杂性转移到一套经过研究的概念集中。有了这样的指南，我们就能充满信心地实现解决方案，且无需反复试错。我们可以确信其他开发者了解该规范，或至少能查阅相关资料。这类似于已发布的 [GENERIC SUBDOMAINS](3.md) 模型的好处，但已经被记录的算法或正式计算可能更容易找到，因为这一层次的计算机科学研究得更多。尽管如此，大多数情况下你仍然需要创造一些新的东西。请确保其聚焦于计算本身，避免混入表达性领域模型。职责存在分离：[CORE DOMAIN](1.md) 或 [GENERIC SUBDOMAINS](3.md) 的模型用于定义事实、规则或问题；而`COHESIVE MECHANISM`则负责解析规则或完成模型指定的计算。

#### 示例：组织结构图中的机制

我在一个需要相当复杂的组织结构图模型的项目中经历了这个过程。该模型体现了某人向另一人汇报工作的事实，在组织的哪些分支中，并提供了一个可供提出和解答相关问题的界面。由于多数问题都围绕 “在这条指挥链中，谁有权批准此事？” 或 “本部门中谁能处理此类问题？” 展开，团队意识到核心复杂性在于遍历组织树的特定分支，搜索特定人员或关系。这恰恰是 *图论 (graph)* ，成熟的形式化方法所擅长的问题，一堆节点，通过节点间弧线（ *边 (edges)* ）的连接，配合遍历图的规则与算法。

某分包商实现了一个图遍历框架作为`COHESIVE MECHANISM`。该框架采用标准图术语及算法，这些概念对多数计算机科学家而言耳熟能详，且在教科书中已有详尽记载。他绝非实现了完全通用的图结构，而是构建了该概念框架的一个子集，仅涵盖我们组织模型所需的功能特性。而借助 [INTENTION-REVEALING INTERFACE](../ch10/1.md) ，获取答案的具体方式并非首要考量。

现在，组织模型可以简单地来描述，采用标准图论术语：每个人都是一个节点，而人与人之间的每种关系都是连接这些节点的边（弧）。在此基础上，图论框架内的机制理应能够找出任意两人之间的关联关系。

<ins>若将该机制纳入领域模型，将带来双重代价：模型将与特定问题解决方法耦合，限制未来选项；更重要的是，组织模型将变得极其复杂且模糊。</ins>将机制和模型分开，使我们能够以一种声明式的方式描述组织，这种方式更加清晰。而用于图操作的复杂代码则被隔离在一个纯粹的机械化框架中，基于经过验证的算法，可以单独进行维护和单元测试。

<ins>另一个`COHESIVE MECHANISM`的示例是构建 [SPECIFICATIONS](../ch9/2.md#specification) 对象的框架</ins>，该框架支持这些对象应具备的基本比较和组合操作。通过采用此类框架，[CORE DOMAIN](1.md) 和 [GENERIC SUBDOMAINS](3.md) 能够使用该模式中描述的清晰易懂的语言明确声明其 [SPECIFICATIONS](../ch9/2.md#specification) （参见 [第 10 章](../ch10/0.md) ）。而执行比较与组合涉及的复杂操作，则可交由框架处理。

🌼🌼🌼

### [GENERIC SUBDOMAINS](3.md) 与`COHESIVE MECHANISM`

[GENERIC SUBDOMAINS](3.md) 和`COHESIVE MECHANISMS`都源于减轻 [CORE DOMAIN](1.md) 负担的共同诉求。二者的区别在于承担责任的性质。[GENERIC SUBDOMAIN](3.md) 基于一种表达模型，该模型体现了团队对领域认知的某个维度。这与 [CORE DOMAIN](1.md) 并无本质区别，只是地位更次要、重要性更低、专业化程度更弱。而`COHESIVE MECHANISM`并非领域表达，而是为解决表达模型引发的棘手计算问题而存在。

<ins>模型提议；`COHESIVE MECHANISM`实现。</ins>

实践中，除非你识别出已正式发布的计算方法，这种区分通常并非绝对，至少初始阶段如此。在持续重构过程中，它可能被提炼为更纯粹的机制，或转化为包含某些先前未被认知的模型概念的 [GENERIC SUBDOMAIN](3.md) ，从而使机制变得简洁。

### 当`MECHANISM`是 [CORE DOMAIN](1.md) 的一部分时

<ins>您几乎总是希望将`MECHANISMS`从 [CORE DOMAIN](1.md) 中移除。唯一的例外是当某个`MECHANISM`本身具有专有性，且构成软件价值的关键部分时。高度专业化的算法有时就属于这种情况。</ins>例如，若某物流运输应用的核心优势在于高效的调度算法，该`MECHANISM`可视为概念性 [CORE](1.md) 的组成部分。我曾在投资银行参与的项目中，那些用于风险评级的高度专有算法就明确属于 [CORE DOMAIN](1.md) 。（事实上这些算法被严密保护，连多数 [CORE](1.md) 开发人员都无权查阅。）当然，这些算法很可能只是风险预测规则集的具体实现形式。更深入的分析或许能构建更深层的模型，使规则显性化并封装为可执行的求解机制。

但这将是设计上的又一次渐进式改进，留待日后再议。是否迈出下一步的决定将基于成本效益分析：新设计方案的实现难度如何？现有设计方案的理解与修改难度如何？对于预期执行该工作的人员而言，更先进的设计能带来多大程度的便利？当然，更关键的是，是否有人能预见新模型的具体形态？

#### 示例：完整循环：组织结构图重新吸收其`MECHANISM`

实际上，在上例完成组织模型一年后，其他开发者对其进行了重构，取消了图框架的分离。他们认为增加对象数量以及将`MECHANISM`拆分到独立包中的复杂性并不合理。取而代之的是，他们将节点行为添加到组织 [ENTITIES](../ch5/2.md) 的父类中。不过，他们保留了组织模型的声明式公共接口，甚至将`MECHANISM`封装在组织 [ENTITIES](../ch5/2.md) 内部。

这些完整的循环很常见，但它们不会回到起点。最终结果通常是更深入的模型，能更清晰地区分事实、目标和`MECHANISMS`。务实重构在保留中间阶段重要特质的同时，去除了不必要的复杂性。

### 提炼为声明式风格

声明式设计和 “声明式风格” 是 [第 10 章](../ch10/0.md) 的主题，但这种设计风格在本章关于战略提炼中也值得特别提及。提炼的价值在于能够清晰地看到你所做的事情：去除不相关的细节，直击本质。当支持性设计提供了一种经济的语言来表达 [CORE](1.md) 的概念和规则，同时封装了计算或执行这些规则的方法时，[CORE DOMAIN](1.md) 的重要部分可能能够遵循声明式风格。

`COHESIVE MECHANISMS`最有用的时候，是当它们通过一个 [INTENTION-REVEALING INTERFACE](../ch10/1.md) 提供访问，并且具有概念上连贯一致的 [ASSERTIONS](../ch10/3.md) 和 [SIDE-EFFECT-FREE FUNCTIONS](../ch10/2.md) 。`MECHANISMS` 和灵活的设计使得 [CORE DOMAIN](1.md) 能够做出有意义的陈述，而不是调用晦涩的函数。但当 [CORE DOMAIN](1.md) 的自身部分突破到深层模型，并开始作为一种语言工作，可以灵活/简洁地表达最重要的应用场景时，回报将是非凡的。

深度模型往往伴随着相应的灵活设计。当灵活设计达到成熟阶段时，它便能提供一套易于理解的元素集，这些元素可被明确组合以完成复杂任务或表达复杂信息，正如单词组合成句子一般。此时，客户端代码将呈现声明式风格，并能实现更高度的精炼。

提取 [GENERIC SUBDOMAINS](3.md) 可减少冗余，而`COHESIVE MECHANISMS`则用于封装复杂操作。由此形成的模型更具聚焦性，减少了对用户活动流程无实质价值的干扰。但领域模型中所有非 [CORE](1.md) *部分* ，你可能永远找不到理想的归宿。[SEGREGATED CORE](7.md) 采用直接方式在结构上划定 [CORE DOMAIN](1.md) 的边界......

#### ▶[下一节](7.md)
