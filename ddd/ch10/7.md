## 声明式设计

#### ▶[上一节](6.md)

`ASSERTIONS断言`可以带来更好的设计，即使我们只是相对非正式地进行测试。但在手写软件中，无法提供真正的保证。举一个规避`ASSERTIONS`的例子，代码可能有一些额外的副作用，而这些副作用并没有被明确排除。不管我们的设计多么`MODEL-DRIVEN`，我们最终仍然需要编写过程来实现概念交互的效果。而且我们花了大量时间编写那些并不真正增加含义或行为的样板代码。这既乏味又容易出错，而且大部分代码掩盖了我们模型的意义。（某些语言比其他语言更好，但所有语言都要求我们做大量繁琐的工作。）[INTENTION-REVEALING INTERFACES](1.md) 及本章中的其他模式有所帮助，但它们永远无法赋予传统面向对象程序形式上的严格性。

这些是 *声明式设计* 背后的部分动机。这个术语对不同人有着不同的含义，但通常指将程序（或程序的某个部分）作为可执行的规范来编写的方式。对属性的精确描述实际上控制着软件运行。通过多种形式实现时，这既可借助反射机制完成，也可在编译时通过代码生成实现（即根据声明自动生成常规代码）。这种方法使其他开发者能直接采用声明的字面含义，提供绝对的保障。

从模型属性的声明生成可运行的程序，堪称 [MODEL-DRIVEN DESIGN](../ch3/1.md) 的圣杯，但在实践中确实存在陷阱。例如，以下是我多次遇到的两个具体问题：

- 一种表达能力不足以完成所有必要任务的声明语言，但其框架使得软件难以在自动化部分之外进行扩展
- 代码生成技术通过将生成的代码与手写代码合并，破坏了迭代循环，这种合并方式使得代码再生过程极具破坏性

许多尝试使用声明式设计的意外结果是模型和应用程序的简化，因为开发者受到框架限制的约束，不得不进行设计取舍以完成交付 *内容* 。

基于规则的编程，通过推理引擎与规则库，是声明式设计的另一种有前景的方法。遗憾的是，细节问题可能破坏这种设计初衷。

尽管基于规则的程序在原理上属于声明式，但大多数系统都添加了 “控制谓词” 以实现性能调优。这种控制代码引入了副作用，使得行为不再完全由声明的规则决定。添加、删除或重新排列规则都可能导致意外的错误结果。因此，逻辑程序员必须像面向对象程序员那样谨慎行事，确保代码效果清晰可辨。

许多声明式方法都可能因开发者有意或无意地绕过它们而失效。当系统难以使用或过度限制时，这种情况就容易发生。要享受声明式程序的优势，每个人都必须遵循框架的规则。

我所见过的最大价值，莫过于当一个范围狭窄的框架能够自动化处理设计中那些特别繁琐且易出错的环节时，例如持久化处理和对象关系映射。最优秀的框架既能让开发者摆脱重复性劳动的束缚，又能赋予他们完全的设计自由。

### 领域特定语言

领域特定语言是一种有趣的方法，有时具有声明式特征。在此风格中，客户端代码采用针对特定领域特定模型定制的编程语言编写。例如，运输系统语言可能包含货物、航线等术语，以及关联它们的语法。程序编译后通常会转换为常规面向对象语言，其中类库为语言术语提供具体实现。

在这样的语言中，程序能够极具表现力，并与 [UBIQUITOUS LANGUAGE](../ch2/1.md) 建立最紧密的联系。这固然是个令人振奋的概念，但在基于面向对象技术的方案中，领域特定语言也存在其局限性。

要完善模型，开发人员需要能够修改语言。这可能涉及修改语法声明和其他语言解释功能，以及修改底层类库。我完全支持学习先进技术和设计理念，但必须清醒评估当前团队的技术能力，以及未来维护团队可能具备的技能水平。此外，应用程序与模型采用同种语言实现的无缝衔接具有显著价值。另一缺点在于：客户端代码难以重构以适应修订后的模型及其关联的领域特定语言。当然，技术层面或许能找到解决重构难题的方案。

---
<p align="center">从基础开始</p>

另一种范式或许比面向对象更能胜任领域特定语言的处理。在 Scheme 编程语言中，作为 “函数式编程” 家族的代表，类似机制已成为标准编程风格的一部分，从而能在不分裂系统的情况下实现领域特定语言的表达力。

---

这种技术对非常成熟的模型可能最为有用，尤其当客户端代码由不同团队编写时。通常，此类架构会导致技术娴熟的框架构建者与技术欠佳的应用构建者之间产生有害的分化，但情况未必如此。

在Scheme编程语言中，类似机制是标准编程风格的一部分，从而能在不分裂系统的情况下实现领域特定语言的表达能力。

#### ▶[下一节](8.md)
