## 声明式设计风格

#### ▶[上一节](7.md)

一旦你的设计具备了`INTENTION-REVEALING INTERFACES`、`SIDE-EFFECT-FREE FUNCTIONS`以及`ASSERTIONS`，你就已经接近声明式领域了。一旦你拥有可组合的元素，这些元素能够传达它们的意义，并且具有特征化或显而易见的效果，或者根本没有可观察的效果，声明式设计的许多好处便会体现出来。

灵活的设计能够使客户端代码采用声明式设计 *风格* 。为说明此点，下一节将整合本章中的若干模式，使`SPECIFICATION`更具灵活性与声明性。

### 以声明式风格扩展`SPECIFICATIONS`

[第 9 章](../ch9/0.md) 介绍了`SPECIFICATION`的基本概念、其在程序中的作用，以及实现过程中的若干要点。现在让我们探讨几种在处理复杂规则时非常实用的扩展功能。

`SPECIFICATION`是对既定形式化方法，谓词的改编。谓词还具备其他实用特性，我们可以有选择地加以利用。

#### 使用逻辑运算符组合`SPECIFICATIONS`

在使用`SPECIFICATIONS`时，您很快会遇到需要组合它们的情况。正如前文所述，`SPECIFICATION`是谓词的实例，谓词可通过 “AND”、“OR” 和 “NOT” 运算进行组合与修改。这些逻辑运算在谓词范围内具有闭包性，因此`SPECIFICATION`组合将展现`CLOSURE OF OPERATIONS`特性。

由于`SPECIFICATIONS`中已构建了重要的通用能力，创建一个可用于各类`SPECIFICATIONS`的抽象类或接口变得非常有用。这意味着将参数类型化为某种高级抽象类。
```java
public interface Specification {
  boolean isSatisfiedBy(Object candidate);
}
```
该抽象要求在方法开头添加一个守护子句，但除此之外不会影响功能。例如，`Container Specification`（来自 [第 9 章](../ch9/0.md) 第 236 页的示例）将按以下方式修改： *(TODO page navigation)*
```java
public class ContainerSpecification implements Specification {
  private ContainerFeature requiredFeature;
  
  public ContainerSpecification(ContainerFeature required) {
    requiredFeature = required;
  }

  boolean isSatisfiedBy(Object candidate) {
    if (!candidate instanceof Container) 
      return false;
    return (Container)aContainer.getFeatures().contains(requiredFeature);
  }
}
```
现在，让我们通过添加三个新操作来扩展`Specification`接口：
```java
public interface Specification {
  boolean isSatisfiedBy(Object candidate);

  Specification and(Specification other);
  Specification or(Specification other);
  Specification not();
}
```
请注意，某些`Container Specifications`被配置为要求通风`Containers`，而另一些则要求装甲`Containers`。一种既易挥发 *又* 易爆的化学品，理应同时满足这 *两* 项`SPECIFICATIONS`。借助新方法，这很容易实现。
```java
Specification ventilated = new ContainerSpecification(VENTILATED);
Specification armored = new ContainerSpecification(ARMORED);

Specification both = ventilated.and(armored);
```
该声明定义了一个具有预期属性的新`Specification`对象。这种组合原本需要更复杂的`Container Specification`，且仍将属于特殊用途。

假设我们有多种通风的`Container`。对于某些物品而言，它们被装入哪种类型的容器可能并不重要，可以放入任意一种类型。
```java
Specification ventilatedType1 =
  new ContainerSpecification(VENTILATED_TYPE_1);
Specification ventilatedType2 =
  new ContainerSpecification(VENTILATED_TYPE_2);
Specification either = ventilatedType1.or(ventilatedType2);
```
若将沙子储存在专用容器中被视为浪费，我们可通过`SPECIFYING`一个无特殊功能的“廉价”容器来禁止此行为。
```java
Specification cheap = (ventilated.not()).and(armored.not());
```
该约束本可避免 [第 9 章](../ch9/0.md) 所述原型仓库打包器中某些次优行为的发生。

通过简单元素构建复杂规范的能力增强了代码的表达力。这些组合以声明式风格编写。

根据`SPECIFICATIONS`的具体实现方式，这些运算符的提供可能简单也可能困难。以下是一个极其简单的实现方案，在某些情况下效率低下，而在其他情况下却相当实用。它仅作为*说明性示例*，如同任何模式一样，存在多种实现方式。
```java
public abstract class AbstractSpecification implements Specification {
  public Specification and(Specification other) {
    return new AndSpecification(this, other);
  }
  public Specification or(Specification other) {
    return new OrSpecification(this, other);
  }
  public Specification not() {
    return new NotSpecification(this);
  }
}

public class AndSpecification extends AbstractSpecification {
  Specification one;
  Specification other;
  public AndSpecification(Specification x, Specification y) {
    one = x;
    other = y;
  }
  public boolean isSatisfiedBy(Object candidate) {
    return one.isSatisfiedBy(candidate) &&
      other.isSatisfiedBy(candidate);
  }
}

public class OrSpecification extends AbstractSpecification {
  Specification one;
  Specification other;
  public OrSpecification(Specification x, Specification y) {
    one = x;
    other = y;
  }
  public boolean isSatisfiedBy(Object candidate) {
    return one.isSatisfiedBy(candidate) ||
      other.isSatisfiedBy(candidate);
  }
}

public class NotSpecification extends AbstractSpecification {
  Specification wrapped;
  public NotSpecification(Specification x) {
    wrapped = x;
  }
  public boolean isSatisfiedBy(Object candidate) {
    return !wrapped.isSatisfiedBy(candidate);
  }
}
```

#### Figure 10.14
![Figure 10.14](../img/fig10.14.png)
*`SPECIFICATION`的`COMPOSITE`设计*

这段代码旨在尽可能便于在书籍中阅读。正如我所说，某些情况下它可能不够高效。不过，我们仍可采用其他实现方案来减少对象数量、提升运行速度，或适配某些项目中特有的技术规范。关键在于构建能准确捕捉领域核心概念的模型，并确保实现过程忠实于该模型。这为解决性能问题留下了充分的空间。

此外，这种完全的通用性在许多情况下并非必要。特别是，与其他运算相比，AND 运算的使用频率往往更高，且其实现复杂度也更低。若仅需实现 AND 功能，请不必犹豫，直接实现即可。

早在 [第 2 章](../ch2/0.md) 第 30 页的示例对话框中，开发者显然尚未实现其`SPECIFICATION`的 “satisfied by” 行为。在此之前，该`SPECIFICATION`仅用于按需构建。即便如此，抽象层依然完整，后续功能的添加也相对容易。使用模式并不意味着必须构建不需要的功能。只要概念不被混淆，这些功能随时可以后期添加。 *(TODO page navigation)*

### 示例：`COMPOSITE` `SPECIFICATION` 的一个替代实现方案

#### ▶[下一节](9.md)
