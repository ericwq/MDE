## 独立类：`STANDALONE CLASS`

#### ▶[上一节](3.md)

相互依赖关系使模型和设计难以理解，也使其难以测试和维护。而且相互依赖关系很容易堆积如山。

当然，每种关联都是一种依赖关系，理解一个类需要理解它所关联的对象。这些关联对象又会关联到更多对象，这些对象也需要被理解。每个方法的每个参数类型也是一种依赖关系，每个返回值同样如此。

当存在一个依赖关系时，你必须同时考虑两个类及其关系性质。当存在两个依赖关系时，你必须考虑三个类各自的情况、每个类与其他两个类的关系性质，以及它们之间可能存在的关联。若这些类又存在其他依赖关系，你同样需要警惕。当依赖关系达到三个时……问题就会像滚雪球般越滚越大。

[MODULES](../ch5/5.md) 与 [AGGREGATES](../ch6/1.md) 均旨在限制相互依赖关系网络。当高度凝聚的子领域被划分为 [MODULE](../ch5/5.md) 时，一组对象便与系统其余部分解耦，从而形成有限数量的关联概念。但即便是一个 [MODULE](../ch5/5.md) ，若缺乏近乎狂热的决心来控制其内部依赖关系，仍会带来大量需要考虑的问题。

<ins>**即使在 [MODULE](../ch5/5.md) 内部，随着依赖关系的增加，设计解读的难度也会急剧上升。这加剧了认知负荷，限制了开发者能够处理的设计复杂度。隐含概念带来的认知负担甚至比显式引用更为沉重。**</ins>

经过提炼的模型会被不断精简，直至概念间的所有关联都体现出该概念的核心本质。在重要子集领域，依赖关系数量可降至零，从而形成仅凭自身即可被完全理解的类，只需辅以若干基本原语和基础库概念即可。

在任何编程环境中，总有若干基础概念如此普遍，以至于时刻萦绕于心。例如在 Java 开发中，基本数据类型和若干标准库提供了数字、字符串及集合等基础功能。实际上，“整数” 这类概念并不会增加认知负担。但除此之外，为理解某个对象而必须牢记的每个额外概念，都会加剧思维负担。

隐含概念，无论是否被明确认知，与显式引用同样重要。虽然我们通常可以忽略对整数、字符串等原始值的依赖，但绝不能忽视 *它们所代表的含义* 。例如在最初的颜料混合示例中，`Paint`对象持有三个公共整数，分别代表红、黄、蓝三原色值。创建`Pigment Color`对象并未增加涉及的概念数量或依赖关系，却使原有概念更显性化且易于理解。反观`Collection`的`size()`操作，其返回的`int`类型仅表示计数，这恰是整数的基本含义，因此并未隐含任何新概念。

每个依赖关系都应被视为可疑，除非能证明其对对象背后的核心概念至关重要。这种审查始于模型概念本身的分解，随后需要关注每个关联关系和操作细节。通过模型与设计选择，依赖关系往往能被逐步削减，甚至最终消除。

<ins>**低耦合是面向对象设计的基础。只要有可能，就彻底贯彻这一原则。将所有其他概念从画面中剔除。这样类就能完全自包含，可独立研究和理解。每个这样的自包含类都能显著减轻理解 [MODULES](../ch5/5.md) 的负担。**</ins>

同一模块内对其他类的依赖比跨模块依赖危害更小。同样地，当两个对象天然紧密耦合时，涉及同一对象对的多重操作反而能厘清其关系本质。目标并非消除所有依赖，而是剔除所有非必要的依赖。若无法消除所有依赖，则每次移除依赖都能让开发者更专注于剩余的概念性依赖。

尝试将最复杂的计算分解为 [STANDALONE CLASSES](../glossary.md#standalone-class) ，或许可通过建模由关联更紧密的类所持有的`VALUE OBJECTS`来实现。

颜料的概念本质上与色彩的概念密切相关。但色彩，即使是颜料的色彩，也可以脱离颜料而存在。通过明确区分这两个概念并提炼其关系，剩余的单向关联便揭示了重要信息，而承载大部分计算复杂度的`Pigment Color`类，便可独立进行研究与 *测试* 。

🌼🌼🌼

低耦合是减轻概念负担的基本方法。[STANDALONE CLASS](../glossary.md#standalone-class) 是低耦合的极端形式。

消除依赖不应意味着通过将一切任意简化为基本元素来降低模型复杂度。本章最后介绍的模式`CLOSURE OF OPERATIONS`，正是既能减少依赖又能保持丰富接口的技术范例……

#### ▶[下一节](6.md)
