## 断言：`ASSERTIONS`

#### ▶[上一节](2.md)

将复杂计算拆分为`SIDE-EFFECT-FREE FUNCTIONS`可将问题规模缩减，但 [ENTITIES](../ch5/2.md) 仍残留着产生副作用的指令，使用这些指令者必须理解其后果。`ASSERTIONS`使副作用显性化，从而更易于处理。

🌼🌼🌼

诚然，不含复杂计算的命令通过检查或许相当容易理解。但在由小部件构筑大部件的设计中，一条命令可能调用其他命令。使用高级命令的开发者必须理解每个底层命令的后果。封装性至此便不复存在。由于对象接口未限制副作用，实现相同接口的两个子类可能产生不同副作用。使用这些接口的开发者需要明确区分二者以预判后果。抽象与多态性至此也告终结。

<ins>**当操作的副作用仅通过其实现隐式定义时，大量依赖委托的设计便会演变成因果关系的纠缠网。理解程序的唯一途径是追踪分支路径的执行轨迹。封装的价值就此丧失。追踪具体执行的必要性，终将击溃抽象的意义。**</ins>

我们需要一种方法来理解设计元素的含义以及执行操作的后果，而无需深入其内部机制。[INTENTION-REVEALING INTERFACES](1.md) 能帮助我们实现部分目标，但非正式的意图暗示往往不够充分。“契约式设计 (design by contract)” 学派更进一步，通过对类和方法作出开发者保证为真的 “断言 (assertions)” 来实现。[Meyer 1988](../references.md#meyer-1988) 中对此进行了详尽探讨。简言之，“后置条件 (post-conditions)” 描述操作的副作用，即调用方法时被保证的结果。“先决条件 (Preconditions)” 如同合同中的细则条款，是确保后置条件成立的必要前提。类不变式 (invariants) 则对对象在任何操作结束时的状态作出断言。不变式亦可用于定义整个 [AGGREGATES](../ch6/1.md) 的完整性规则。

所有这些断言描述的是状态而非过程，因此更易于分析。类不变量有助于阐明类的含义，并通过增强对象的可预测性来简化客户端开发者的工作。若您信任后置条件的保证，便无需担忧方法的具体实现方式。委托操作的影响应已包含在断言之中。

因此：

<ins>**声明操作的后置条件以及类和 [AGGREGATES](../ch6/1.md) 的不变量。若您的编程语言无法直接用`ASSERTIONS`编码，请为其编写自动化单元测试。根据项目开发流程的风格，将这些内容写入文档或图表中。**</ins>

<ins>**寻求具有连贯概念集的模型，这些概念能引导开发者推断出预期的`ASSERTIONS`，从而加速学习曲线并降低产生矛盾代码的风险。**</ins>

尽管许多面向对象语言目前尚未直接支持`ASSERTIONS`，但`ASSERTIONS`仍是设计思考中一种强大的方式。自动化单元测试可部分弥补语言支持的缺失。由于`ASSERTIONS`完全基于状态而非过程，使得测试编写变得简便。测试设置会预先设定好先决条件；执行后，测试将验证后置条件是否成立。

明确陈述的不变量以及前置条件和后置条件，能让开发者理解使用某项操作或对象的后果。理论上，任何不矛盾的断言集合都可适用。但人类不会仅在脑中编译谓词，他们会对模型概念进行外推和内插，因此关键在于寻找既符合人类认知又满足应用需求的模型。

### 示例：回到颜料混合

回想前一个示例中，我曾关注到`Paint`类上`mixIn(Paint)`操作的参数会发生什么变化这一问题存在歧义。

#### Figure 10.9
![Figure 10.9](../img/fig10.9.png)

接收器的体积将增加参数体积的数值。根据我们对物理颜料的一般理解，这种混合过程应使另一种颜料以相同数值减少，直至体积归零或完全消失。当前实现并未修改参数，而修改参数本就是一种风险极高的副作用。

为奠定坚实基础，让我们先明确`mixIn()`方法的后置条件 *如下* ：

执行`p1.mixIn(p2)`后：
- *`p1.volume`增加`p2.volume`的数值。*
- *`p2.volume`保持不变。*

问题在于，开发者难免会犯错，因为这些属性不符合我们引导他们思考的概念。最直接的解决方式是将其他颜料的体积设为零。虽然修改参数属于不良实践，但这种做法简单直观。我们可以声明一个不变量：

- *混合颜料后，其总体积保持不变。*

等等！就在开发者们思考这个方案时，他们有了新发现。原来最初的设计者这么做是有充分理由的， *程序最终会报告添加的未混合颜料清单。* 毕竟，这款应用的终极目的就是帮助用户确定该将哪些颜料 *放入* 混合物中。 *（译注：怀疑斜体字有错误）*

因此，若为使体积模型逻辑一致而调整，反而会使其不符合应用需求。这似乎是个两难困境。难道我们只能记录这个奇怪的后置条件，并试图通过良好沟通来弥补吗？世间万物并非尽皆直观，有时这确实是最佳解。但在此情境下，这种别扭感似乎暗示着存在概念缺失。让我们寻找新的模型吧。

#### 如今我们看得更清楚了

在探索更优模型时，我们相较于最初的设计者拥有显著优势，这得益于期间发生的知识提炼与深度洞察重构。例如，我们通过对 [VALUE OBJECT](../ch5/3.md) 执行 [SIDE-EFFECT-FREE FUNCTION](../glossary.md#side-effect-free-function) 来计算颜色。这意味着我们可在任何需要时重复计算过程，应当充分利用这一特性。

我们似乎赋予了`Paint`两个不同的基本职责。让我们尝试将它们分离。

现在只有一个命令`mixIn()`。它仅将对象添加到一个集合中，这种效果从对模型的直观理解中即可显现。所有其他操作都是`SIDE-EFFECT-FREE FUNCTIONS`。

验证 [Figure 10.10](#figure-1010) 所列`ASSERTIONS`之一的测试方法（使用 JUnit 测试框架）可能如下所示：
```java
public void testMixingVolume {
  PigmentColor yellow = new PigmentColor(0, 50, 0);
  PigmentColor blue = new PigmentColor(0, 0, 50);

  StockPaint paint1 = new StockPaint(1.0, yellow);
  StockPaint paint2 = new StockPaint(1.5, blue);
  MixedPaint mix = new MixedPaint();

  mix.mixIn(paint1);
  mix.mixIn(paint2);
  assertEquals(2.5, mix.getVolume(), 0.01);
}
```
#### Figure 10.10
![Figure 10.10](../img/fig10.10.png)

该模型能够捕捉并传达更多领域信息。其不变量和后置条件符合常识，这将使其更易于维护和使用。

[INTENTION-REVEALING INTERFACES](1.md) 的可沟通性，结合`SIDE-EFFECT-FREE FUNCTIONS`与`ASSERTIONS`提供的可预测性，应能确保封装与抽象的安全性。

可重组元素的下一个关键要素是有效的分解......

🌼🌼🌼

#### ▶[下一节](4.md)
