## 断言

#### ▶[上一节](2.md)

将复杂计算拆分为`SIDE-EFFECT-FREE FUNCTIONS`可将问题规模缩减，但`ENTITIES`仍残留着产生副作用的指令，使用这些指令者必须理解其后果。`ASSERTIONS`使副作用显性化，从而更易于处理。

🌼🌼🌼

诚然，不含复杂计算的命令通过检查或许相当容易理解。但在由小部件构筑大部件的设计中，一条命令可能调用其他命令。使用高级命令的开发者必须理解每个底层命令的后果。封装性至此便不复存在。由于对象接口未限制副作用，实现相同接口的两个子类可能产生不同副作用。使用这些接口的开发者需要明确区分二者以预判后果。抽象与多态性至此也告终结。

<ins>**当操作的副作用仅通过其实现隐式定义时，大量依赖委托的设计便会演变成因果关系的纠缠网。理解程序的唯一途径是追踪分支路径的执行轨迹。封装的价值就此丧失。追踪具体执行的必要性，终将击溃抽象的意义。**</ins>

我们需要一种方法来理解设计元素的含义以及执行操作的后果，而无需深入其内部机制。`INTENTION-REVEALING INTERFACES`能帮助我们实现部分目标，但非正式的意图暗示往往不够充分。“契约式设计 (design by contract)” 学派更进一步，通过对类和方法作出开发者保证为真的 “断言 (assertions)” 来实现。[Meyer 1988](../references.md#meyer-1988) 中对此进行了详尽探讨。简言之，“后置条件 (post-conditions)” 描述操作的副作用，即调用方法时被保证的结果。“先决条件 (Preconditions)” 如同合同中的细则条款，是确保后置条件成立的必要前提。类不变式 (invariants) 则对对象在任何操作结束时的状态作出断言。不变式亦可用于定义整个`AGGREGATES`的完整性规则。

所有这些断言描述的是状态而非过程，因此更易于分析。类不变量有助于阐明类的含义，并通过增强对象的可预测性来简化客户端开发者的工作。若您信任后置条件的保证，便无需担忧方法的具体实现方式。委托操作的影响应已包含在断言之中。

因此：

<ins>**声明操作的后置条件以及类和`AGGREGATES`的不变量。若您的编程语言无法直接用`ASSERTIONS`编码，请为其编写自动化单元测试。根据项目开发流程的风格，将这些内容写入文档或图表中。**</ins>

<ins>**寻求具有连贯概念集的模型，这些概念能引导开发者推断出预期的`ASSERTIONS`，从而加速学习曲线并降低产生矛盾代码的风险。**</ins>

尽管许多面向对象语言目前尚未直接支持`ASSERTIONS`，但`ASSERTIONS`仍是设计思考中一种强大的方式。自动化单元测试可部分弥补语言支持的缺失。由于`ASSERTIONS`完全基于状态而非过程，使得测试编写变得简便。测试设置会预先设定好先决条件；执行后，测试将验证后置条件是否成立。

明确陈述的不变量以及前置条件和后置条件，能让开发者理解使用某项操作或对象的后果。理论上，任何不矛盾的断言集合都可适用。但人类不会仅在脑中编译谓词，他们会对模型概念进行外推和内插，因此关键在于寻找既符合人类认知又满足应用需求的模型。

#### ▶[下一节](4.md)
