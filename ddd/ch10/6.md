## 闭包操作：`CLOSURE OF OPERATIONS`

#### ▶[上一节](5.md)

---
如果我们取两个实数并将它们相乘，我们会得到另一个实数。"实数包括所有有理数和所有无理数。" 因为这总是成立，我们说实数在 “乘法运算下是封闭的” ：没有办法逃出这个集合。当你将集合中的任意两个元素结合时，结果也包含在该集合中。

<p align="right">——Drexel 大学数学论坛</p>

---

当然，依赖关系是存在的，而当这种依赖关系是概念的基础时，它并非坏事。将接口简化到只处理基本类型，反而会削弱其功能。但许多不必要的依赖关系，甚至整个概念，都是在接口层引入的。

<ins>**最有趣的对象最终总会做些无法仅用基本操作来描述的事情。**</ins>

在精炼的设计中，另一种常见做法是我称之为`CLOSURE OF OPERATIONS`的概念。这个名称源自最精炼的概念体系，数学。1+1=2。加法运算在实数集下具有封闭性。数学家们极度排斥引入无关概念，而闭包的特性为他们提供了一种无需涉及其他概念即可定义运算的方式。我们早已习惯数学的严谨性，以至于难以领会其中精妙技法的强大威力。但这个原理在软件设计中同样被广泛运用。XSLT 的基本功能是将一个 XML 文档转换为另一个 XML 文档。这种 XSLT 操作在 XML 文档集合中具有闭包性。闭包性极大简化了运算的解释过程，也使得闭包运算的串联组合变得易于理解。

因此：

<ins>**在适用情况下，应定义返回类型与其参数类型相同的操作。
若实现者在计算过程中使用了状态，则该实现者实质上成为操作的参数，因此参数与返回值应与实现者具有相同类型。
此类操作在其类型实例集下具有闭包性。
封闭操作提供了高级接口，且不引入对其他概念的依赖。**</ins> *（译注：实现者就是你调用的操作）*

<ins>该模式最常应用于 [VALUE OBJECT](../ch5/3.md) 的操作。</ins>由于 [ENTITY](../ch5/2.md) 的生命周期在领域中具有重要意义，你不能随意创建新的实体来回答问题。某些操作在 [ENTITY](../ch5/2.md) 类型下具有封闭性。例如向`Employee`对象查询其主管时，会返回另一个`Employee`对象。但通常而言，[ENTITIES](../ch5/2.md) 这类概念不太可能作为计算结果存在。因此多数情况下，这正是探索 [VALUE OBJECT](../ch5/3.md) 应用场景的契机。

<ins>运算可以在抽象类型下保持封闭性，此时具体的参数可以属于不同的具体类。</ins>毕竟，加法运算在实数范围内保持封闭性，而实数既可以是有理数，也可以是无理数。

在尝试减少相互依赖、增强凝聚力的过程中，有时会形成这种模式的半成品：参数与实现者匹配，但返回类型不同；或是返回类型与接收者匹配，参数却不同。<ins>这类操作虽未完全闭包，却具备`CLOSURE`的部分优势。当额外类型是原始类型或基础库类时，其解放思维的效果几乎可媲美`CLOSURE`。</ins>

在之前的示例中，`Pigment Color`的`mixedWith()`操作被封装在`Pigment Colors`之下，书中还散落着其他几个类似示例。以下示例展示了这种设计理念的实用性，即使未达到真正的`CLOSURE`状态。

#### 示例：从集合中选择

在 Java 中，若要从`Collection`中选取子集元素，需请求一个`Iterator`。随后遍历这些元素，逐个进行检测，通常会将匹配项累积到新的`Collection`中。

```java
Set employees = (some Set of Employee objects);
Set lowPaidEmployees = new HashSet();

Iterator it = employees.iterator();
while (it.hasNext()) {
  Employee anEmployee = it.next();
  if (anEmployee.salary() < 40000)
    lowPaidEmployees.add(anEmployee);
}
```

从概念上讲，我只是从集合中选取了一个子集。为何还要引入这个额外的`Iterator`概念及其繁琐的机制？在 Smalltalk 中，我只需对`Collection`调用 “select” 操作，将测试条件作为参数传入。返回的将是包含通过测试元素的新`Collection`。

```java
employees := (some Set of Employee objects).
lowPaidEmployees := employees select:
  [:anEmployee | anEmployee salary < 40000].
```

Smalltalk 的`Collections`提供了其他此类`FUNCTIONS`，返回派生`Collections`，这些集合可以属于多个具体类。这些操作并非封闭的，因为它们接受 “块 (block)” 作为参数。但块在 Smalltalk 中属于基础库类型，因此不会增加开发者的认知负担。由于返回值与实现者匹配，它们可像一系列过滤器那样串联使用。这些操作易于编写且便于阅读，不会引入与子集选择问题无关的冗余概念。

🌼🌼🌼

本章介绍的模式展现了一种通用设计风格及设计思维方式。使软件具有直观性、可预测性和交互性，能有效实现抽象与封装。模型可进行分解，使对象既易于使用和理解，又能保持丰富的高级接口。

这些技术需要相当高超的设计能力才能应用，有时甚至需要编写客户端程序。[MODEL-DRIVEN DESIGN](../ch3/1.md) 的实用性取决于详细设计和实现决策的质量，只需少数几名思路混乱的开发人员，就足以使项目偏离既定目标。

话虽如此，对于愿意培养建模与设计能力的团队而言，这些模式及其所体现的思维方式，能催生出可供开发者反复打磨的软件，从而构建出复杂的软件系统。

#### ▶[下一节](7.md)
