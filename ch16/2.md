## 16.2 产品线工程
在实际展示如何构建各种工件之前，我们想通过本案例研究来说明第 13 章所述的产品线工程的基本原理。

容器代表一个软件系统系列。各种系统使用的容器有一些共同点，但在具体方面也有差异。例如，只有当相应的 ECU 实际连接到特定总线时，容器才会包含通过该总线进行通信的代码。通信模式也是如此。如果通信仅通过异步事件进行，那么容器中就不需要包含通过总线在不同组件实例之间调用同步操作的代码。

从产品线工程的角度来看待这个问题是有道理的。道理很简单。如果我们只有一个可以在所有场景和系统中使用的容器，那么它就构成了一个框架。正如第 16.1.4 节所述，出于性能和代码大小的考虑，这种方法并不可行。

如果每个容器都是一个完整、独特的实体，那么容器的概念就会变得荒谬。出于经济上的考虑，不同系统的容器在某些方面必须是相似的。

### 16.2.1 领域界定
首先，我们必须确定容器适用于哪些场景。为了系统地解决这个问题，我们可以使用嵌入式系统整个领域的特征建模来确定我们希望解决整个领域中的哪一部分。

在这一阶段，这一过程往往会耗费太多精力，因此我们在此采用了更为务实的方法。我们可以考虑从以下几个方面来帮助确定领域的范围：
- 操作系统。在嵌入式系统领域，直接对硬件编程而不使用操作系统的情况并不少见。操作系统为嵌入式系统提供的功能（以及性能）因操作系统而异。在我们的容器中，我们假设操作系统至少可以处理调度。我们认为内存保护以及其他更复杂的功能是可选的。
- 实时能力。系统能否实时运行<sup>[3](#3)</sup> 取决于多种因素：在分布式系统中，主要取决于底层总线（例如，FlexRay 具有实时能力）、操作系统的调度程序和应用程序的功能。我们的示例仅限于必须不满足任何硬性实时要求的系统。
- 安全问题。对于安全关键型环境中的许多应用领域来说，需要进行大量的认证。除了软件本身需要认证外，构建软件的工具和开发过程本身通常也需要认证。我们也将此类系统排除在外。
- 动态配置与静态配置。组件实例、它们之间的通信关系以及整个系统的其他各个方面既可以在运行时动态定义，也可以在配置时静态定义。出于性能考虑，我们在此只讨论静态情况，而只有生命周期状态是动态管理的。

因此，我们有意将某些场景排除在我们的领域之外。这有助于我们在开发系统族的过程中保持专注。我们将软件系统系列的重点放在具有以下特征的组件容器上：
- 无（硬）实时能力
- 非安全关键型- 静态配置
- 在至少能处理调度的操作系统上工作

### 16.2.2 可变性分析和领域结构化
既然我们现在已经熟悉了领域的边界，我们就必须分析这些系统的特征，以确定哪些特征是系统家族所有成员共有的，哪些特征是可变的。第一步是按照第 13.5 节所述，将领域划分为若干子领域：
- 通过不同总线系统进行通信及其高性能实现，以及如何将其映射到组件模型定义的抽象和机制。
- 容器服务--容器可在运行时为组件提供的附加服务。
- 部署和一致性检查--在系统节点上实现组件的最佳和一致分布。
- 与操作系统调度的集成。

对于每一个子领域，我们都应该进行可变性分析。在此，我们将以两个子领域为例：容器的通信机制和跨领域(cross-cutting)服务。

***通信范式***

连接器用于描述两个组件端口之间的通信关系，如图 16.1 所示。

![Figure 16.1](../img/f16.1.png)

通信范式（操作调用、面向消息）由两个端口的接口，特别是连接器来定义。图 16.2 中的功能模型（见第 13.5.3 节）显示了现有的通信选项。从中可以看出，首先必须确定两个特征：技术和范式。

当然，技术取决于限制条件：只能通过与相应硬件节点相连的总线系统进行通信。此外，只有当两个实例位于同一个容器（容器定义了一个地址空间）中时，才能进行本地通信。

范式则要困难一些。原则上，人们可以使用客户机/服务器或基于消息的方法进行通信。在客户端/服务器通信的情况下，必须决定是同步通信还是异步通信。如果是异步通信，则必须决定如何获知调用结果。

![Figure 16.2](../img/f16.2.png)

在进行基于消息的通信时，还必须做出上述决定和其他决定。

确定开发人员何时定义每个功能非常重要。例如，可以使用功能图的注释来实现这一点，如图 16.3 所示。

![Figure 16.3](../img/f16.3.png)

必须静态定义一些特性的原因包括代码大小、内存消耗、确定性时序特性和性能。

在某些操作系统（如 Osek）上，轮询应该是阻塞式还是非阻塞式的问题必须通过静态方式来决定，以配置操作系统，使阻塞式轮询成为可能<sup>[4](#4)</sup>。

***容器服务***

容器提供的服务是软件系统系列组件容器的另一个重要方面--见图 16.4。

![Figure 16.4](../img/f16.4.png)

首先，容器始终提供通信服务。容器还可以通过控制组件实例的激活和停用来管理其生命周期。我们将其分为三种模式：
- 简单模式（Simple）只知道 “开始”（Start）和 “停止”（Stop）事件。
- Init 还知道初始化阶段，即启动、初始化、退出、停止。
- Pause 知道暂停模式，例如节能模式。

容器可以监控协议状态机。在这种情况下，必须确定两个方面：第一，是否也要监控时序约束；第二，如何应对错误？
- StopInst 停止相应实例（为此需要生命周期管理）。
- StopSys 停止整个容器。
- Report 只是向中央错误存储库报告错误。
对于后者，容器必须具备错误存储功能。

容器还可以管理组件实例的状态。如果激活了该功能，容器就可以自动或在开发者调用特定 API 操作后持久地存储组件的状态。为此必须激活生命周期管理。

最后，容器可以参与分布式--全系统--生命周期管理。这需要在容器中进行生命周期管理。

一般来说，各自的功能都是静态绑定的，但在细节上存在差异：
- 生命周期模式必须在开发组件实现时就知道，因为我们可能希望在实现代码中对生命周期事件做出反应。
- 至于是否应在运行时监控协议状态机的问题，可以在容器生成时决定。

我们将在讨论生产计划的定义时再次讨论这个问题。

---
#### 3
在这里，我们对实时能力一词的理解是，如果截止日期没有达到，就会构成系统错误（这也被称为硬实时）。

#### 4
BCC 与 ECC，供读者中的 Osek 内部人员参考。
