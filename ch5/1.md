## 5.1 MDSD 与 CASE、4GL 和向导的比较
模型驱动软件开发的一个显著特点是，所使用的开发环境绝不是生成的和静态的，事实上，它可以支持 *任何* 目标架构、建模和目标语言、接口和运行时组件。

相比之下，CASE 或 4GL 工具将预先确定领域架构的至少一个组件 -- 在大多数情况下，是所有组件：
- DSL（建模语言）
- 转换
- 平台和目标架构

这些工具关注的领域并 *不* 具体：它们试图遵循 “一刀切” 的教条 -- 一种预谋好的组合适合所有应用。这种假设在实践中是完全不现实的，而且会导致严重的问题。通常情况下，应用的 80% 可以通过这种方式快速创建，而剩下的 20% 最终需要 80% 的努力。这是因为工具的不灵活性迫使我们采取变通方法来解决这些问题。 个别的架构要求和界面无法在此应用，更不用说领域知识了。

MDSD 意味着明确放弃所有 “一刀切” 的方法。它的重点显然是开发 *方法*，而不是开发 *环境*。

通常情况下，希望生成的所有方面都需要手动实现并至少验证一次。只有在第二步中，才会从这些方面衍生出领域架构，然后根据输入模型自动生成具体特征。因此，在传统生成方法中出现的问题可以暂时搁置：

- 系统(生成的)运行性能如何？
- 生成源代码的质量/可读性如何？

...等等。所有这些因素的好坏都与参考实现一样，转换是从参考实现中推断出的。

当然，不一定要从零开始：只要软件系统族是可生成的，它的实用性就会随着每一个可以使用其技术基础的应用（即作为该族 “成员” 的任何应用）而成倍增加。

MDSD 不能与代码向导或模式扩展器 (pattern expander) 相提并论。常用开发环境的 “有用助手” 部分，或某些 UML 工具的模式扩展，允许自动生成类骨架（例如 EJB），或生成类结构（取决于设计模式）。除 MDSD 外，这一步通常只能进行一次。这就缺少了 MDSD 所实现的可重复转换，同时又能保持定制的功能。此外，通过 MDSD 引入的额外抽象层也丢失了。
